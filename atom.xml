<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拓荒者的博客</title>
  
  <subtitle>分享自己的学习之路</subtitle>
  <link href="https://shenhongwei33.github.io/atom.xml" rel="self"/>
  
  <link href="https://shenhongwei33.github.io/"/>
  <updated>2023-01-25T10:26:06.829Z</updated>
  <id>https://shenhongwei33.github.io/</id>
  
  <author>
    <name>拓荒者</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://shenhongwei33.github.io/2023/01/25/LeetCode/"/>
    <id>https://shenhongwei33.github.io/2023/01/25/LeetCode/</id>
    <published>2023-01-25T07:29:20.000Z</published>
    <updated>2023-01-25T10:26:06.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-必读"><a href="#第一章-必读" class="headerlink" title="第一章 必读"></a>第一章 必读</h1><h2 id="学习算法和刷题的框架思维"><a href="#学习算法和刷题的框架思维" class="headerlink" title="学习算法和刷题的框架思维"></a>学习算法和刷题的框架思维</h2><h3 id="数据结构的存储方式"><a href="#数据结构的存储方式" class="headerlink" title="数据结构的存储方式"></a>数据结构的存储方式</h3><p><strong>数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。</strong></p><p>这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。</p><p>比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。<br><strong>图</strong>的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。</p><p><strong>散列表</strong>就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</p><p><strong>树</strong>，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。</p><p>了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。</p><p>综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下：</p><ul><li><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。</li><li><strong>链表</strong>因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</li></ul><h3 id="数据结构的基本操作"><a href="#数据结构的基本操作" class="headerlink" title="数据结构的基本操作"></a>数据结构的基本操作</h3><p>对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。</p><p><strong>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。</strong></p><p>如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。线性就是 for/while 迭代为代表，非线性就是递归为代表。再具体一步，无非以下几种框架：</p><h4 id="数组遍历框架，典型的线性迭代结构"><a href="#数组遍历框架，典型的线性迭代结构" class="headerlink" title="数组遍历框架，典型的线性迭代结构"></a>数组遍历框架，典型的线性迭代结构</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">int</span>[] arr)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">        <span class="comment">// 迭代访问 arr[i]  </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表遍历框架，兼具迭代和递归结构"><a href="#链表遍历框架，兼具迭代和递归结构" class="headerlink" title="链表遍历框架，兼具迭代和递归结构"></a>链表遍历框架，兼具迭代和递归结构</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的单链表节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    ListNode <span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> traverse(ListNode head) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ListNode p = head; p != <span class="literal">null</span>; p = p.<span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="comment">// 迭代访问 p.val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> traverse(ListNode head) &#123;</span><br><span class="line">    <span class="comment">// 递归访问 head.val</span></span><br><span class="line">    traverse(head.<span class="keyword">next</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树遍历框架，典型的非线性递归遍历结构"><a href="#二叉树遍历框架，典型的非线性递归遍历结构" class="headerlink" title="二叉树遍历框架，典型的非线性递归遍历结构"></a>二叉树遍历框架，典型的非线性递归遍历结构</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的二叉树节点 */</span></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode <span class="attribute">left</span>, <span class="attribute">right</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="built_in">traverse</span>(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看二叉树的递归遍历方式和链表的递归遍历方式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多几条叉，N 叉树你会不会遍历？</p><h4 id="二叉树框架可以扩展为-N-叉树的遍历框架"><a href="#二叉树框架可以扩展为-N-叉树的遍历框架" class="headerlink" title="二叉树框架可以扩展为 N 叉树的遍历框架"></a>二叉树框架可以扩展为 N 叉树的遍历框架</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的 N 叉树节点 */</span></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode<span class="selector-attr">[]</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="built_in">traverse</span>(TreeNode root) &#123;</span><br><span class="line">    for (TreeNode child : root.children)</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>N 叉树的遍历又可以扩展为图的遍历，因为图就是好几 N 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，这里就不写代码了。</p><p><strong>所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，</strong>你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了，下面会具体举例。</p><h3 id="算法刷题指南"><a href="#算法刷题指南" class="headerlink" title="算法刷题指南"></a>算法刷题指南</h3><p>首先要明确的是，数据结构是工具，算法是通过合适的工具解决特定问题的方法。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。<br>所以我建议的刷题顺序是：</p><ol><li>先学习像数组、链表这种基本数据结构的常用算法，比如单链表翻转，前缀和数组，二分搜索等。因为这些算法属于会者不难难者不会的类型，难度不大，学习它们不会花费太多时间。而且这些小而美的算法经常让你大呼精妙，能够有效培养你对算法的兴趣。</li><li>学会基础算法之后，不要急着上来就刷回溯算法、动态规划这类笔试常考题，而应该<strong>先刷二叉树，先刷二叉树，先刷二叉树</strong>，重要的事情说三遍。为什么要先刷二叉树呢，因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">traverse</span>(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。力扣第 124 题，难度困难，让你求二叉树中最大路径和，主要代码如下：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> res = Integer.MIN_VALUE;</span><br><span class="line"><span class="built_in">int</span> one<span class="constructor">SideMax(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root<span class="operator"> == </span>null) return <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> left = max(<span class="number">0</span>, one<span class="constructor">SideMax(<span class="params">root</span>.<span class="params">left</span>)</span>);</span><br><span class="line">    <span class="built_in">int</span> right = max(<span class="number">0</span>, one<span class="constructor">SideMax(<span class="params">root</span>.<span class="params">right</span>)</span>);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    res = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(res, left + right + root.<span class="keyword">val</span>);</span><br><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(left, right) + root.<span class="keyword">val</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意递归函数的位置，这就是个后序遍历嘛，无非就是把 traverse 函数名字改成 oneSideMax 了。</li></ol><p>对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，你就会发现<strong>只要涉及递归的问题，都是树的问题</strong>。</p><p>其实很多动态规划问题就是在遍历一棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。</p><p>再看看回溯算法，前文回溯算法详解干脆直接说了，回溯算法就是个 N 叉树的前后序遍历问题，没有例外。比如全排列问题吧，本质上全排列就是在遍历下面这棵树，到叶子节点的路径就是一个全排列。</p><p>综上，对于畏惧算法的同学来说，<strong>可以先刷树的相关题目，试着从框架上看问题，而不要纠结于细节问题。</strong></p><h2 id="刷题心得"><a href="#刷题心得" class="headerlink" title="刷题心得"></a>刷题心得</h2><h3 id="算法的本质"><a href="#算法的本质" class="headerlink" title="算法的本质"></a>算法的本质</h3><p>如果要让我一句话总结，我想说算法的本质就是<strong>穷举</strong>。</p><p>例外肯定是有的，比如前几天我还发了 一行代码就能解决的算法题，这些题目都是通过观察，发现规律，然后找到最优解法。再比如数学相关的算法，很多都是数学推论，然后用编程的形式表现出来了，所以它本质是数学，不是计算机算法。<br>从计算机算法的角度，结合我们大多数人的需求，这种秀智商的纯技巧题目绝对占少数，虽然很容易让人大呼精妙，但不能提炼出思考算法题的通用思维，真正通用的思维反而大道至简，就是穷举。</p><p>对计算机算法的误解也许是以前学数学留下的「后遗症」，数学题一般都是你仔细观察，找几何关系，列方程，然后算出答案。如果说你需要进行大规模穷举来寻找答案，那大概率是你的解题思路出问题了。而计算机解决问题的思维恰恰相反，有没有什么数学公式就交给你们人类去推导吧，如果能找到一些巧妙的定理那最好，但如果找不到，那就穷举呗，反正只要复杂度允许，没有什么答案是穷举不出来的。<br>技术岗笔试面试考的那些算法题，求个最大值最小值什么的，你怎么求？必须得把所有可行解穷举出来才能找到最值。</p><p>但是，你千万不要觉得穷举这个事儿很简单，<strong>穷举有两个关键难点：无遗漏、无冗余。</strong></p><p>遗漏，会直接导致答案出错；冗余，会拖慢算法的运行速度。所以，当你看到一道算法题，可以从这两个维度去思考：</p><ol><li><strong>如何穷举？即无遗漏地穷举所有可能解。</strong></li><li><strong>如何聪明地穷举？即避免所有冗余的计算。</strong></li></ol><p>不同类型的题目，难点是不同的，有的题目难在<strong>如何穷举</strong>，有的题目难在<strong>如何聪明地穷举</strong>。</p><p>什么算法的难点在<strong>如何穷举</strong>呢？<strong>一般是递归类问题，最典型的就是动态规划系列问题。</strong></p><p>前文 动态规划核心套路 阐述了动态规划系列问题的核心原理，无非就是先写出暴力穷举解法（状态转移方程），加个备忘录就成自顶向下的递归解法了，再改一改就成自底向上的递推迭代解法了， 动态规划的降维打击 里也讲过如何分析优化动态规划算法的空间复杂度。<br>上述过程就是在不断优化算法的时间、空间复杂度，也就是所谓如何聪明地穷举，这些技巧一听就会了。但很多读者留言说明白了这些原理，遇到动态规划题目还是不会做，因为第一步的暴力解法都写不出来。<br>这很正常，因为动态规划类型的题目可以千奇百怪，找状态转移方程才是难点，所以才有了 动态规划设计方法：数学归纳法 这篇文章，告诉你递归穷举的核心是数学归纳法，明确函数的定义，然后利用这个定义写递归函数，就可以穷举出所有可行解。</p><p>什么算法的难点在<strong>如何聪明地穷举</strong>呢？一些耳熟能详的非递归算法技巧，都可以归在这一类。</p><h1 id="第一章、手把手刷数据结构"><a href="#第一章、手把手刷数据结构" class="headerlink" title="第一章、手把手刷数据结构"></a>第一章、手把手刷数据结构</h1><h2 id="手把手刷链表算法"><a href="#手把手刷链表算法" class="headerlink" title="手把手刷链表算法"></a>手把手刷链表算法</h2><h3 id="双指针技巧秒杀七道链表题目"><a href="#双指针技巧秒杀七道链表题目" class="headerlink" title="双指针技巧秒杀七道链表题目"></a>双指针技巧秒杀七道链表题目</h3><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>给你输入两个有序链表，请你把他俩合并成一个新的有序链表，函数签名如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;</span><br><span class="line">        ListNode temp = new ListNode(-1),<span class="attribute">p</span>=temp;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">null</span> &amp;&amp; list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">                p.<span class="attribute">next</span>=list1;</span><br><span class="line">                <span class="attribute">list1</span>=list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p.<span class="attribute">next</span>=list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">p</span>=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.<span class="attribute">next</span>=list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.<span class="attribute">next</span>=list2;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们的 while 循环每次比较 p1 和 p2 的大小，把较小的节点接到结果链表上，这个算法的逻辑类似于「拉拉链」，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并。<br>代码中还用到一个链表的算法题中是很常见的<strong>虚拟头结点</strong>技巧，也就是 <strong>dummy 节点。你可以试试，如果不使用 dummy 虚拟节点，代码会复杂很多，</strong>而有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p><h4 id="合并-k-个有序链表"><a href="#合并-k-个有序链表" class="headerlink" title="合并 k 个有序链表"></a>合并 k 个有序链表</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        ListNode node = pq.poll();</span><br><span class="line">        p.<span class="keyword">next</span> = node;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="keyword">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            pq.add(node.<span class="keyword">next</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并 k 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 k 个节点中的最小节点，接到结果链表上？这里我们就要用到 <strong>优先级队列</strong>（二叉堆） 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点：<br>优先队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N 是这些链表的节点总数。</p><h4 id="单链表的倒数第-k-个节点"><a href="#单链表的倒数第-k-个节点" class="headerlink" title="单链表的倒数第 k 个节点"></a>单链表的倒数第 k 个节点</h4><p>首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步：</p><p><img src="/2023/01/25/LeetCode/%E8%B5%B0K%E6%AD%A5.png"></p><p>现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？趁这个时候，再用一个指针 p2 指向链表头节点 head：<br>![](LeetCode/单链表的倒数第 k 个节点.png)</p><p>接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时前进了 n - k 步，p2 也从 head 开始前进了 n - k 步，停留在第 n - k + 1 个节点上，即恰好停链表的倒数第 k 个节点上：<br>![](LeetCode/单链表的倒数第 k 个节点-1.png)</p><p>这样，只遍历了一次链表，就获得了倒数第 k 个节点 p2。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"><span class="symbol">ListNode</span> findFromEnd(ListNode head, int k) &#123;</span><br><span class="line">    ListNode <span class="built_in">p1</span> = head<span class="comment">;</span></span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    for (int i = <span class="number">0</span><span class="comment">; i &lt; k; i++) &#123;</span></span><br><span class="line">        <span class="built_in">p1</span> = <span class="built_in">p1</span>.next<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode <span class="built_in">p2</span> = head<span class="comment">;</span></span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="meta">while</span> (<span class="built_in">p1</span> != null) &#123;</span><br><span class="line">        <span class="built_in">p2</span> = <span class="built_in">p2</span>.next<span class="comment">;</span></span><br><span class="line">        <span class="built_in">p1</span> = <span class="built_in">p1</span>.next<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k 个节点</span></span><br><span class="line">    return <span class="built_in">p2</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除单链表的第K个节点"><a href="#删除单链表的第K个节点" class="headerlink" title="删除单链表的第K个节点"></a>删除单链表的第K个节点</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">public ListNode remove<span class="constructor">NthFromEnd(ListNode <span class="params">head</span>, <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> <span class="constructor">ListNode(-1)</span>;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span></span><br><span class="line">    ListNode x = find<span class="constructor">FromEnd(<span class="params">dummy</span>, <span class="params">n</span> + 1)</span>;</span><br><span class="line">    <span class="comment">// 删掉倒数第 n 个节点</span></span><br><span class="line">    x.next = x.next.next;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> ListNode find<span class="constructor">FromEnd(ListNode <span class="params">head</span>, <span class="params">int</span> <span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个逻辑就很简单了，要删除倒数第 n 个节点，就得获得倒数第 n + 1 个节点的引用，可以用我们实现的 findFromEnd 来操作。</p><p><strong>不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。</strong></p><h4 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h4><p>问题的关键也在于我们无法直接得到单链表的长度 n，常规方法也是先遍历链表计算 n，再遍历一次得到第 n / 2 个节点，也就是中间节点。</p><p>如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：<br>我们让两个指针 slow 和 fast 分别指向链表头结点 head。<strong>每当慢指针 slow 前进一步，快指针 fast 就前进两步</strong>，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。上述思路的代码实现如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode middleNode(ListNode head) &#123;</span><br><span class="line">    <span class="regexp">//</span> 快慢指针初始化指向 head</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="regexp">//</span> 快指针走到末尾时停止</span><br><span class="line">    <span class="keyword">while</span> (head != null &amp;&amp; head.<span class="keyword">next</span> != null) &#123;</span><br><span class="line">        <span class="regexp">//</span> 慢指针走一步，快指针走两步</span><br><span class="line">        slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        head = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="regexp">//</span> 慢指针指向中点</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。</p><h4 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h4><p>判断链表是否包含环属于经典问题了，解决方案也是用<strong>快慢指针</strong>：每当慢指针 slow 前进一步，快指针 fast 就前进两步。<strong>如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环</strong>。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span> hasCycle(ListNode head) &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.<span class="keyword">next</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        fast = fast.<span class="keyword">next</span>;</span><br><span class="line">        slow = slow.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。<br>我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：<br><img src="/2023/01/25/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF.png"></p><p>fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的<strong>整数倍</strong>。</p><p>假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：<br><img src="/2023/01/25/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF-1.png"></p><p>所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。</p><h4 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h4><p>给你输入两个链表的头结点 headA 和 headB，这两个链表可能存在相交。如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。<br><img src="/2023/01/25/LeetCode/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4.png"></p><p>那么我们的算法应该返回 c1 这个节点。这个题直接的想法可能是用 HashSet 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p><p>如果不用额外的空间，只使用两个指针，你如何做呢？难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：<br><img src="/2023/01/25/LeetCode/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-1.png"></p><p>如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。</p><p>解决这个问题的关键是，<strong>通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1</strong>。<br>所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：<br><img src="/2023/01/25/LeetCode/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-2.png"></p><p>那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ListNode</span> getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    ListNode <span class="built_in">p1</span> = headA, <span class="built_in">p2</span> = headB<span class="comment">;</span></span><br><span class="line">    <span class="meta">while</span> (<span class="built_in">p1</span> != <span class="built_in">p2</span>) &#123;</span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="meta">if</span> (<span class="built_in">p1</span> == null) <span class="built_in">p1</span> = headB<span class="comment">;</span></span><br><span class="line">        <span class="meta">else</span>            <span class="built_in">p1</span> = <span class="built_in">p1</span>.next<span class="comment">;</span></span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="meta">if</span> (<span class="built_in">p2</span> == null) <span class="built_in">p2</span> = headA<span class="comment">;</span></span><br><span class="line">        <span class="meta">else</span>            <span class="built_in">p2</span> = <span class="built_in">p2</span>.next<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归魔法：反转单链表"><a href="#递归魔法：反转单链表" class="headerlink" title="递归魔法：反转单链表"></a>递归魔法：反转单链表</h3><h4 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h4><p>递归反转单链表的算法：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点</span><br><span class="line">ListNode<span class="built_in"> reverse</span>(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">(head</span> == null ||<span class="built_in"> head</span>.<span class="keyword">next</span> == null) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode<span class="built_in"> last</span> =<span class="built_in"> reverse</span><span class="built_in">(head</span>.<span class="keyword">next</span>);</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span>.<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span> = null;</span><br><span class="line">    <span class="keyword">return</span><span class="built_in"> last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于递归算法，最重要的就是明确递归函数的定义。具体来说，我们的 reverse 函数定义是这样的：输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。<br>那么输入 reverse(head) 后，会在这里进行递归：<br><code>ListNode last = reverse(head.next);</code><br><img src="en-resource://database/2933:1" alt="72b54c3992c6c1cff6df7344c6193b82.png"></p><p>这个 reverse(head.next) 执行完成后，整个链表就成了这样<br><img src="en-resource://database/2935:1" alt="e8accd1505f8962b99fe9ae7e3946d66.png"></p><p>并且根据函数定义，reverse 函数会返回反转之后的头结点，我们用变量 last 接收了。现在再来看下面的代码：<code>head.next.next = head;</code><br><img src="en-resource://database/2937:1" alt="85db63b0d9ffcd5d1471728ed2ce7d09.png"></p><p>接下来：<code>head.next = null; return last;</code><br><img src="en-resource://database/2939:1" alt="772d8d8b2dd340eb92b0d5c5b84f4e6b.png"></p><p>不过其中有两个地方需要注意：</p><ol><li><p>递归函数要有 base case，也就是这句：<code>if (head == null || head.next == null) &#123;  return head;  &#125;  </code><br> 意思是如果链表为空或者只有一个节点的时候，反转结果就是它自己，直接返回即可。</p></li><li><p>当链表递归反转之后，新的头结点是 last，而之前的 head 变成了最后一个节点，别忘了链表的末尾要指向 null：</p></li></ol><p>此外还可以通过栈的数据结构反转：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span><span class="built_in">(head</span> == null)&#123;</span><br><span class="line">            <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack<span class="language-xml"><span class="tag">&lt;<span class="name">ListNode</span>&gt;</span> stack = new Stack</span><span class="language-xml"><span class="tag">&lt;<span class="name">ListNode</span>&gt;</span>();</span></span><br><span class="line"><span class="language-xml">        while(head != null)</span><span class="language-xquery">&#123;</span></span><br><span class="line"><span class="language-xquery">            stack.push<span class="built_in">(head</span>);</span></span><br><span class="line"><span class="language-xquery">           <span class="built_in"> head</span> =<span class="built_in"> head</span>.<span class="keyword">next</span>;</span></span><br><span class="line"><span class="language-xquery">        &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        head = stack.pop();</span></span><br><span class="line"><span class="language-xml">        ListNode temp = head;</span></span><br><span class="line"><span class="language-xml">        while (!stack.isEmpty())</span><span class="language-xquery">&#123;</span></span><br><span class="line"><span class="language-xquery">           <span class="built_in"> head</span>.<span class="keyword">next</span>=stack.pop();</span></span><br><span class="line"><span class="language-xquery">           <span class="built_in"> head</span> =<span class="built_in"> head</span>.<span class="keyword">next</span>;</span></span><br><span class="line"><span class="language-xquery">           <span class="built_in"> head</span>.<span class="keyword">next</span>=null;</span></span><br><span class="line"><span class="language-xquery">        &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        return temp;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br></pre></td></tr></table></figure><p>也是需要注意置空（head.next=null;），防止链表的下一节点指向原来的节点而陷入循环。</p><h4 id="反转链表前-N-个节点"><a href="#反转链表前-N-个节点" class="headerlink" title="反转链表前 N 个节点"></a>反转链表前 N 个节点</h4><p>比如说对于下图链表，执行 reverseN(head, 3)：<br><img src="en-resource://database/2941:1" alt="32a29e167d8ec2fff0f93dab796a9890.png"></p><p>解决思路和反转整个链表差不多，只要稍加修改即可：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode successor = null; // 后驱节点</span><br><span class="line"></span><br><span class="line">// 反转以<span class="built_in"> head</span> 为起点的 n 个节点，返回新的头结点</span><br><span class="line">ListNode reverseN(ListNode<span class="built_in"> head</span>, int n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        // 记录第 n + <span class="number">1</span> 个节点</span><br><span class="line">        successor =<span class="built_in"> head</span>.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // 以<span class="built_in"> head</span>.<span class="keyword">next</span> 为起点，需要反转前 n - <span class="number">1</span> 个节点</span><br><span class="line">    ListNode<span class="built_in"> last</span> = reverseN<span class="built_in">(head</span>.<span class="keyword">next</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span>.<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">    // 让反转之后的<span class="built_in"> head</span> 节点和后面的节点连起来</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span> = successor;</span><br><span class="line">    <span class="keyword">return</span><span class="built_in"> last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的区别：</p><ol><li>base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。</li><li>刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。</li></ol><p><img src="en-resource://database/2943:1" alt="17a0220408c42f2cea4e4c53dca8a423.png"></p><h4 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h4><p>现在解决我们最开始提出的问题，给一个索引区间 [m, n]（索引从 1 开始），仅仅反转区间中的链表元素。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverse<span class="constructor">Between(ListNode <span class="params">head</span>, <span class="params">int</span> <span class="params">m</span>, <span class="params">int</span> <span class="params">n</span>)</span></span><br></pre></td></tr></table></figure><p>首先，如果 m == 1，就相当于反转链表开头的 n 个元素嘛，也就是我们刚才实现的功能：</p><p>如果 m != 1 怎么办？如果我们把 head 的索引视为 1，那么我们是想从第 m 个元素开始反转对吧；如果把 head.next 的索引视为 1 呢？那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的；那么对于 head.next.next 呢……</p><p>区别于迭代思想，这就是递归思想，所以我们可以完成代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverse<span class="constructor">Between(ListNode <span class="params">head</span>, <span class="params">int</span> <span class="params">m</span>, <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (m<span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">        return reverse<span class="constructor">N(<span class="params">head</span>, <span class="params">n</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.next = reverse<span class="constructor">Between(<span class="params">head</span>.<span class="params">next</span>, <span class="params">m</span> - 1, <span class="params">n</span> - 1)</span>;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何-K-个一组反转链表"><a href="#如何-K-个一组反转链表" class="headerlink" title="如何 K 个一组反转链表"></a>如何 K 个一组反转链表</h3>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一章-必读&quot;&gt;&lt;a href=&quot;#第一章-必读&quot; class=&quot;headerlink&quot; title=&quot;第一章 必读&quot;&gt;&lt;/a&gt;第一章 必读&lt;/h1&gt;&lt;h2 id=&quot;学习算法和刷题的框架思维&quot;&gt;&lt;a href=&quot;#学习算法和刷题的框架思维&quot; class=&quot;headerlink&quot; title=&quot;学习算法和刷题的框架思维&quot;&gt;&lt;/a&gt;学习算法和刷题的框架思维&lt;/h2&gt;&lt;h3 id=&quot;数据结构的存储方式&quot;&gt;&lt;a href=&quot;#数据结构的存储方式&quot; class=&quot;headerlink&quot; title=&quot;数据结构的存储方式&quot;&gt;&lt;/a&gt;数据结构的存储方式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://shenhongwei33.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://shenhongwei33.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>django</title>
    <link href="https://shenhongwei33.github.io/2023/01/25/django/"/>
    <id>https://shenhongwei33.github.io/2023/01/25/django/</id>
    <published>2023-01-25T03:26:34.000Z</published>
    <updated>2023-01-26T01:20:05.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django框架"><a href="#Django框架" class="headerlink" title="Django框架"></a>Django框架</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>版本选择使用TLS版本，长期支持<br>安装：<br>pip3 install django==2.2.12/3.2.11<br>检查是否安装成功：pip3 freeze | grep -i ‘Django’</p><p>初始化项目：<br>在终端执行：django-admin startproject 项目名  即可</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>测试开发阶段：<br>进入项目目录文件夹后，执行python3 manage.py runserver 即可，在IDEA中同样配置即可</p><p><img src="/2023/01/25/django/IDEA%E9%85%8D%E7%BD%AE.png"></p><h3 id="项目结构-1"><a href="#项目结构-1" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="/2023/01/25/django/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p><p>manage.py：包含项目管理的子命令，执行python3 manage.py可以看到所有的命令<br>项目同名文件夹：</p><ul><li>_ init_:python包的初始化文件</li><li>wsgi.py：WEB服务网关的配置文件</li><li>urls.py：项目的主路由配置-HTTP请求进入django时优先调用</li><li>settings.py：项目的配置文件，包含项目启动时需要的配置</li></ul><p>其中，setting.py中的配置名均要大写，小写会报错，引入自定义配置的话可使用：from django.conf import settings</p><h2 id="url和视图函数"><a href="#url和视图函数" class="headerlink" title="url和视图函数"></a>url和视图函数</h2><p>urls.py默认为主路由配置，会匹配其中urlpatterns这个数组中的所有配置好的路由</p><h3 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h3><p>视图函数是一个用于接收http请求（HttpRequest对象）并通过HttpResponse对象返回响应的函数。<br>语法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xxx_view</span>(<span class="params">request[,其他参数]</span>): </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">HttpResponse</span>对象</span><br></pre></td></tr></table></figure><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><ul><li>导入：from django.urls import path</li><li>语法：path(route, views, name=None)<br>  参数：<br>  route：字符串类型，匹配的请求路径<br>  views：指定路径所对应的视图处理函数的名称<br>  name：为地址起别名，在模板中地址反向解析时使用</li></ul><h3 id="path转换器"><a href="#path转换器" class="headerlink" title="path转换器"></a>path转换器</h3><p>其实就是路径上的参数</p><ul><li>语法：&lt;转换器类型:自定义名&gt;</li><li>作用：若转换器类型匹配到对应类型的数据，则将数据按照关键字传参方式传递给视图函数<br>例如：path(‘page/&lt;int:page&gt;’,views.xxx)</li></ul><p>转换器类型：</p><table><thead><tr><th>转换器类型</th><th>作用</th><th>样例</th></tr></thead><tbody><tr><td>str</td><td>匹配除了’/‘之外的非空字符串</td><td>“v1/users/&lt; str:username&gt;” 匹配  /v1/users/guoxiaona</td></tr><tr><td>int</td><td>匹配0或任何正整数</td><td>“page/&lt; int:page&gt;” 匹配 /page/100</td></tr><tr><td>slug</td><td>匹配任意由ASCLL字母或数字以及连字符和下划线组成的短标签</td><td>“detail/&lt; slug:sl&gt;” 匹配 /detail/this-is-django</td></tr><tr><td>path</td><td>匹配非空字段，包括路径分隔符’/‘</td><td>“v1/users/&lt; path:ph&gt;” 匹配 /v1/users/a/b/c</td></tr></tbody></table><h3 id="re-path"><a href="#re-path" class="headerlink" title="re_path()"></a>re_path()</h3><p>在url的匹配过程中可以使用正则表达式进行精确匹配</p><ul><li>语法：re_path(reg,view,name=xxx)</li><li>正则表达式为命名分组模式(?P<name>pattern)；匹配提取参数后用关键字传参方式传递给视图函数</name></li></ul><p>例如：</p><h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>HttpRequest对象通过属性描述了请求的所有相关信息，视图函数的第一个参数</p><ul><li>path_info：URL字符串</li><li>method：HTTP请求方法</li><li>GET：包含get请求的所有数据</li><li>POST：包含post请求的所有数据</li><li>FILES：包含所有的上传文件信息</li><li>COOKIES：包含所有的cookies，键和值都为字符串</li><li>session：表示当前的会话</li><li>body：字符串，请求体的内容</li><li>scheme：请求协议（http、https）</li><li>request.get_full_path()：请求的完整路径</li><li>META：请求中的元数据（消息头），如request.META[‘REMOTE_ADDR’]：客户端IP地址</li></ul><p>无论是GET请求还是POST，统一都由视图函数接收请求，通过判断request.method区分具体动作。</p><p>取消scrf验证，只需要在settings.py中MIDDLEWARE中的CsrfViewsMiddleWare的中间件就行</p><p><strong>注意</strong>：</p><ol><li>应该使用request.META.get(“HTTP_XXX”)获取header中的值，其中前端传的key的值小写转为大写，横线“-”转为下划线“<em>”,并且加上前缀HTTP_，尤其注意header的key中不应该包含 HTTP前缀，以及符号”</em> “,否则会取不到对应的值</li></ol><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>djanjo中的响应对象：HttpResponse<br>构造函数格式：HttpResponse(content=响应体,content_type=响应体数据类型,status=数据类型)</p><h2 id="Django的设计模式和模板层"><a href="#Django的设计模式和模板层" class="headerlink" title="Django的设计模式和模板层"></a>Django的设计模式和模板层</h2><h3 id="模板配置"><a href="#模板配置" class="headerlink" title="模板配置"></a>模板配置</h3><p>创建模板文件夹：&lt;项目名&gt;/templates<br>在settings.py中TEMPLATES配置项</p><ol><li>BACKEND：指定模板的引擎</li><li>DIRS：模板的搜索目录</li><li>APP_DIRS：是否要在应用中的templates文件夹中搜索模板文件</li><li>OPTIONS：有关模板的选项</li></ol><p>设置DIRS：‘DIRS’：[os.path.join(BASE_DIR,’templates’)],</p><h3 id="视图函数获取模板的方法"><a href="#视图函数获取模板的方法" class="headerlink" title="视图函数获取模板的方法"></a>视图函数获取模板的方法</h3><p>1、通过loader获取模板，通过HttpResponse进行响应。</p><p>from django.template import loader</p><p>t = loader.get_template(“模板文件名”)<br>html = t.render(字典数据)<br>return HttpResponse(html)</p><p>2、通过render()直接加载并响应模板<br>在视图函数中<br>from django.shortcuts import render<br>return render(request,”模板文件名”,字典数据)</p><p>视图层与模板之间的交互：<br>视图函数中可以将python变量封装到<strong>字典</strong>中传递到模板<br>模板中我们可以使用的语法调用传递进来的参数</p><p>模板的变量可以为字符串、整型、数组、元组、字典、方法、类实例化的对象</p><h3 id="模板标签"><a href="#模板标签" class="headerlink" title="模板标签"></a>模板标签</h3><p>将一些服务器端的功能嵌入到模板中，例如流程控制等。<br>标签语法：<br><code>&#123; %  标签  % &#125;</code><br><code>...</code><br><code>&#123; %  结束标签  % &#125;</code></p><p><img src="/2023/01/25/django/if%E6%A0%87%E7%AD%BE.png"><br><img src="/2023/01/25/django/for.png"><br>在for标签里面会有特殊的内置变量：forloop<br><img src="/2023/01/25/django/forloop.png"></p><h3 id="模板过滤器"><a href="#模板过滤器" class="headerlink" title="模板过滤器"></a>模板过滤器</h3><p>在变量输出时对变量的值进行处理<br>可以通过使用过滤器来改变变量的输出显示<br><code>语法：&#123;&#123; 变量 | 过滤器1：‘参数值1’ | 过滤器2：‘参数值2’ ...  &#125;&#125;</code><br><img src="/2023/01/25/django/%E6%A8%A1%E6%9D%BF%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p><h3 id="模板的继承"><a href="#模板的继承" class="headerlink" title="模板的继承"></a>模板的继承</h3><p>模板继承可以使父模板的内容重用，子模板直接继承父模板的全部内容并可以覆盖父模板中相应的块<br>语法：父模板中：</p><ul><li>定义父模板中的block标签</li><li>标识出哪些在子模板中是允许被修改的</li><li>block标签：在父模板中定义，可以在子模板中覆盖</li></ul><p>子模块中：</p><ul><li>继承模板extends标签（写在模板文件的第一行）例如<code>&#123;%  extends 'base.html'%&#125;</code></li><li>子模板中重写父模板中的内容块<br><code>&#123;% block block_name%&#125;</code><br>子模板中用来覆盖父模板中block_name块的内容<br><code>&#123;% endblock block_name %&#125;</code></li></ul><p>重写的覆盖规则：</p><ul><li>不重写，将按照父模板的效果展示</li><li>重写，则按照重写效果显示</li></ul><p>注意：模板继承时，服务器端的动态内容无法继承，参数无法获取</p><h3 id="URL反向解析"><a href="#URL反向解析" class="headerlink" title="URL反向解析"></a>URL反向解析</h3><p>url反向解析是指在视图或者模板中，用path定义的名称来动态查找或计算出相应的路由，根据path中的name关键字传参给url确定了唯一确定的名字，在模板或视图中，可以通过名字反向推断出此url信息。<br><img src="/2023/01/25/django/URL%E5%8F%8D%E5%90%91%E8%A7%A3%E6%9E%90.png"></p><p>在视图函数中，可调用djanjo中的reverse方法进行反向解析：<br>from django.urls import reverse<br>reverse(‘别名’,args=[], kwargs={})</p><h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><h3 id="静态文件配置"><a href="#静态文件配置" class="headerlink" title="静态文件配置"></a>静态文件配置</h3><p>在settings.py中配置<br>配置静态文件的访问路径：STATIC_URL = ‘/static/‘<br>配置静态文件的存储路径：STATICFILES_DIRS<br>STATICFILES_DIRS保存的是静态文件在服务器端的存储位置</p><h3 id="模板中访问静态文件"><a href="#模板中访问静态文件" class="headerlink" title="模板中访问静态文件"></a>模板中访问静态文件</h3><p>通过<code>&#123;% static %&#125;</code>标签访问静态文件</p><ol><li>加载static - <code>&#123;% load static %&#125;</code></li><li>使用静态资源 - <code>&#123;% static '静态资源路径' %&#125;</code></li></ol><h2 id="应用以及分布式路由"><a href="#应用以及分布式路由" class="headerlink" title="应用以及分布式路由"></a>应用以及分布式路由</h2><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><ol><li>用manage.py中的子命令startapp 创建应用文件夹<br> python3 manage.py startapp music</li><li>在settings.py的INSTALLED_APPS列表中配置安装此应用</li></ol><h3 id="分布式路由"><a href="#分布式路由" class="headerlink" title="分布式路由"></a>分布式路由</h3><p>Djanjo中，主路由配置文件（urls.py）可以不处理用户具体路由，主路由配置文件可以做请求的分发（分布式请求处理），具体的请求可以由各自的应用来处理</p><h4 id="配置分布式路由"><a href="#配置分布式路由" class="headerlink" title="配置分布式路由"></a>配置分布式路由</h4><p>主路由中调用include函数<br>语法：include(‘app名字.url模块名’)<br>作用：相当于将当前路由转到各个应用的路由配置文件的urlpatterns进行分布式处理</p><p>应用下配置urls.py，应用下没有这个文件，需要手动创建，内容和主路由完全一样</p><h4 id="应用下的模板"><a href="#应用下的模板" class="headerlink" title="应用下的模板"></a>应用下的模板</h4><ol><li>应用下手动创建templates文件夹</li><li>settings.py中开启应用模板功能：TEMPLATE配置项中的’APP_DIRS’值为True即可<br>应用下templates和外层templates都存在时，优先查找外层templates下的模板，然后就会按照INSTALLED_APPS下的应用顺序逐层查找</li></ol><p>可以在应用下建一个应用同名的文件夹，防止同名的模板进行混淆</p><h2 id="模型层及ORM"><a href="#模型层及ORM" class="headerlink" title="模型层及ORM"></a>模型层及ORM</h2><p>模型层负责和数据库交互</p><h3 id="Djanjo连接MySQL"><a href="#Djanjo连接MySQL" class="headerlink" title="Djanjo连接MySQL"></a>Djanjo连接MySQL</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>linux：</p><ul><li>安装mysqlclient，安装前需要确认是否安装了python3-dev和default-libmysqlclient-dev</li><li>安装好依赖后，执行pip3 install mysqlclient就好</li></ul><p>windows安装的话，先登录<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient%E7%BD%91%E7%AB%99%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%8C">https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient网站下载安装包，</a><br><img src="/2023/01/25/django/mysqlclient.png"><br><img src="/2023/01/25/django/mysqlclient-1.png"><br>下载好后执行：<br>pip3 install mysqlclientXXX.whl 即可</p><h4 id="配置连接参数"><a href="#配置连接参数" class="headerlink" title="配置连接参数"></a>配置连接参数</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;    </span><br><span class="line">    &#x27;default&#x27;: &#123;        </span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,        </span><br><span class="line">        &#x27;NAME&#x27;: &#x27;djangoDemo&#x27;,      <span class="meta">#连接数据库的名字  </span></span><br><span class="line">        &#x27;USER&#x27;: &#x27;root&#x27;,        </span><br><span class="line">        &#x27;PASSWORD&#x27;: &#x27;123qwe!@#&#x27;,        </span><br><span class="line">        &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;,        </span><br><span class="line">        &#x27;PORT&#x27;: &#x27;<span class="number">3306</span>&#x27;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>存储引擎包括：</p><ul><li>django.db.backends.mysql</li><li>django.db.backends.sqlite3</li><li>django.db.backends.oracle</li><li>django.db.backends.postgresql</li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul><li>模型是一个Python类，她是由djanjo.db.models.Model派生出的子类</li><li>一个模型类代表数据库中的一张表</li><li>模型类中每一个类属性都代表数据库中的一个字段</li><li>模型是数据交互的接口，是表示和操作数据库的方法和方式</li></ul><h3 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h3><p>优点：</p><ul><li>只需要面向对象编程，不需要面向数据库编写代码：对数据库的操作都转化成对类属性和方法的操作，不需要编写各种数据库的sql语句</li><li>实现了数据模型与数据库的解耦，屏蔽了不同数据库操作上的差异，不在关注mysql等数据库的内部细节，并且通过简单的配置就可以轻松更换数据库，不需要修改代码</li></ul><h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><p>迁移是Djanjo同步对模型所做的更改（添加字段，删除模型等）到数据库模式的方式</p><ol><li>生成迁移文件 - 执行<br><code>python3 manage.py makemigrations /</code><br>将应用下的models.py文件生成一个中间文件，并保存在migrations文件夹中</li><li>执行迁移脚本程序 - 执行<br><code>python3 manage.py migrate</code><br>执行迁移程序实现迁移，将每个应用下的migrations目录中的中间文件同步回数据库</li></ol><p>数据库的迁移文件混乱的解决办法：<br>数据库中django_migrations表记录了migrate的’全过程’，项目个应用中的migrate文件应与之对应，否则migrate会报错<br>解决方案：</p><ol><li>删除所有migrations里所有的000?<em>XXXX.py(</em> init_.py除外)</li><li>删除数据库</li><li>重新迁移生成数据库</li></ol><h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><ul><li><p>BooleanField()<br>数据库类型：tinyint(1)<br>变成语言中：使用True或False来表示<br>在数据库中：使用1或0来表示具体的值</p></li><li><p>CharField()<br>数据库类型：varchar<br>注意：必须指定max_length参数值</p></li><li><p>DateField()<br>数据库类型：date<br>作用：表示日期<br>参数：</p></li></ul><p>1.antu_now：每次保存对象时，自动设置该字段为当前时间（取值：True/False）<br>2.auto_now_add：当对象第一次创建时自动设置当前时间（取值：True/False）<br>3.default：设置指定的时间（取值：字符串格式时间如’2019-6-1’）<br><strong>以上三个参数只能多选一</strong></p><ul><li><p>DateTimeField()<br>数据库类型：datetime(6)<br>作用：表示日期和时间<br>参数同DateField</p></li><li><p>FloatField()<br>数据库类型：double<br>编程语言中和数据库中都使用小数表示值</p></li><li><p>DecimalField()<br>数据库类型：decimal(x,y)<br>编程语言中：使用小数表示该列的值<br>在数据库中：使用小数<br>参数：</p></li></ul><p>1.max_digits：位数总数，包括小数点后的位数，该值必须大于等于decimal_places<br>2.decimal_places：小数点后的数字数量</p><ul><li><p>EmailField()<br>数据库类型：varchar<br>编程语言和数据库中使用字符串</p></li><li><p>IntegerField()<br>数据库类型：int<br>编程语言和数据库中使用整型</p></li><li><p>ImageField()<br>数据库类型：varchar(100)<br>作用：在数据库中为了保存图片的路径<br>编程语言和数据库中使用字符串</p></li><li><p>TextField()<br>数据库类型：longtext<br>作用：表示不定长的字符数据</p></li></ul><h3 id="模型类-字段选项"><a href="#模型类-字段选项" class="headerlink" title="模型类-字段选项"></a>模型类-字段选项</h3><p>字段选项：指定创建的列的额外的信息<br>允许出现多个字段选项，多个选项之间使用，隔开</p><ul><li><p>primary_key<br>如果设置为True，表示该列为主键，如果指定一个字段为主键，则此数据库不会创建id字段</p></li><li><p>blank<br>设置为True时，字段可以为空，设置为False时，字段是必须填写的</p></li><li><p>null<br>如果设置为True，表示该列允许为空，默认为False，如果此选项为False，建议加入default选项来设置默认值</p></li><li><p>default<br>设置所在列的默认值</p></li><li><p>db_index<br>如果设置为True，表示为该列增加索引</p></li><li><p>unique<br>如果设置为True，表示该字段在数据库中的值必须唯一（不能重复出现）</p></li><li><p>db_cloumn<br>指定列的名称，如果不指定的话则采用属性名作为列名</p></li><li><p>verbose_name<br>设置此字段在admin界面上的显示名称</p><h3 id="模型类-Meta类"><a href="#模型类-Meta类" class="headerlink" title="模型类-Meta类"></a>模型类-Meta类</h3><p>使用内部Meta类来给模型赋予属性，Meta类下有很多内建的类属性，可对模型类做一些控制。<br><img src="/2023/01/25/django/%E6%A8%A1%E5%9E%8B%E7%B1%BB-Meta%E7%B1%BB.png"></p></li></ul><h3 id="管理器对象"><a href="#管理器对象" class="headerlink" title="管理器对象"></a>管理器对象</h3><p>每个继承自models.Model的模型类，都会有一个oblects对象被同样继承下来，这个对象叫管理器对象。数据库的增删改查可以通过模型的管理器实现</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">MyModel</span>(<span class="title">models</span>.<span class="type">Model</span>):</span></span><br><span class="line"><span class="class">    ...</span></span><br><span class="line"><span class="class"><span class="type">MyModel</span>.objects.create(...)  #objects是管理器对象</span></span><br></pre></td></tr></table></figure><h4 id="Django-Shell"><a href="#Django-Shell" class="headerlink" title="Django Shell"></a>Django Shell</h4><p>在Django提供了一个交互式的操作项目叫Django Shell，它能够在交互模式用项目工程的代码执行相应的操作，利用Django Shell可以代替编写view的代码来进行直接操作<br>注意：项目代码发生变化时，重新进入Django Shell<br>启动方式：python manage.py shell</p><h4 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h4><p>Django ORM使用一种直观的方式把数据库中的数据表示成Python对象，创建数据中每一条记录就是创建一个数据对象<br><strong>方案1</strong>：MyModel.objects.create(属性1=值1,属性2=值2,…)<br>成功则返回创建好的实体对象，失败则抛出异常<br><strong>方案2</strong>：创建MyModel实例对象，并调用save()进行保存<br>obj = MyModel(属性=值,属性=值)<br>obj.属性= 值<br>obj.save()</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>通过MyModel.objects管理器方法调用查询方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>all()</td><td>查询全部记录，返回QuerySet查询对象</td></tr><tr><td>get()</td><td>查询符合条件的单一记录</td></tr><tr><td>filter()</td><td>查询符合条件的多条记录</td></tr><tr><td>exclude()</td><td>查询符合条件之外的全部记录</td></tr></tbody></table><ul><li><p>all()方法<br>用法：MyModel.objects.all()<br>作用：查询MyModel实体中所有的数据<br>返回值：QuerySet容器对象，内部存放MyModel实例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from music<span class="selector-class">.models</span> import Song</span><br><span class="line">songs = Song<span class="selector-class">.objects</span><span class="selector-class">.all</span>()</span><br><span class="line"><span class="keyword">for</span> song <span class="keyword">in</span> songs:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;歌名&quot;</span>,song<span class="selector-class">.name</span>, <span class="string">&#x27;价格：&#x27;</span>,song.price)</span><br></pre></td></tr></table></figure><p>为了方便显示，可以在模型类中定义_str_方法，自定义QuerySet中的输出格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_str_</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s%s%S&#x27;</span>%(self.name,self.author,self.price)</span><br></pre></td></tr></table></figure></li><li><p>values(‘列1’, ‘列2’,…)<br>用法：MyModel.objects.values(…)<br>作用：查询部分列的数据并返回<br>返回值：QuerySet，返回查询结果容器，容器内存字典，每个字典代表一条数据</p></li><li><p>values_list(‘列1’,’列2’,…)<br>用法：MyModel.objects.values_list(…)<br>作用：返回元组形式的查询结果<br>返回值：QuerySet容器对象，内部存放元组</p></li><li><p>order_by()<br>用法：MyModel.objects.order_by(‘-列’,列’’)<br>作用：与all()方法不同，它会用SQL语句的ORDER BY子句对查询结果进行根据某个字段选择性的进行排序，默认是按照升序排序，降序排序则需要在列前增加’-‘表示</p></li></ul><p>输出结果只要是QuerySet，就可以连续使用下一个排序或者其他方法</p><ul><li><p>filter(条件)<br>语法：MyModel.objects.filter(属性1=值1,属性2=值2)<br>作用：返回包含此条件的全部数据集<br>返回值：QuerySet容器对象，内部存放MyModel实例，当多个属性在一起时为“与”关系</p></li><li><p>exclude(条件)<br>语法：MyModel.objects.exclude(条件)<br>作用：返回不包含此条件的全部数据集</p></li><li><p>get(条件)<br>语法：MyModel.objects.get(条件)<br>作用：返回满足条件的唯一一条数据<br>说明：该方法只能返回一条数据，查询结果多余一条数据则抛出出Model.MultipleObjectsReturned异常，查询结果如果没有数据则抛出Model.DoseNotExist异常</p></li></ul><h5 id="查询谓词"><a href="#查询谓词" class="headerlink" title="查询谓词"></a>查询谓词</h5><p>定义：做更灵活的条件查询时需要使用查询谓词<br>说明：每一个查询谓词是一个独立的查询功能<br>类属性__ exact：等值匹配<br>__ contains：包含指定值<br>__ startswith：以 XXX开始<br>__ endsswith：以 XXX结束<br>__ gt：大于指定值<br>__ gte：大于等于<br>__ lt：小于<br>__ lte：小于等于<br>__ in：查找数据是否在指定范围内<br>__ range：查找数据是否在指定的区间范围内<br>例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Song.objects.<span class="keyword">filter</span>(id_exact=<span class="number">1</span>)</span><br><span class="line">#等同于<span class="keyword">select</span> * <span class="keyword">from</span> song <span class="keyword">where</span> id = <span class="number">1</span>`</span><br><span class="line"></span><br><span class="line">Song.objects.<span class="keyword">filter</span>(name__contains=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">#等同于<span class="keyword">select</span> * <span class="keyword">from</span> song <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">&#x27;%w%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2023/01/25/django/%E6%9F%A5%E8%AF%A2%E8%B0%93%E8%AF%8D.png"></p><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p><strong>修改单个实体的某些字段值得步骤</strong>：</p><ol><li>查：通过get()得到要修改的实体对象</li><li>改：通过对象.属性的方式修改数据</li><li>保存：通过对象.save()保存数据</li></ol><p><strong>批量更新数据</strong>：</p><ol><li>直接调用QuerySet的update(属性=值)实现批量修改</li></ol><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p><strong>单个数据删除</strong>：</p><ol><li>查找查询结果对应的一个对象</li><li>调用这个数据对象的delete()方法实现删除</li></ol><p><strong>伪删除</strong>：<br>通常不会轻易的在业务李把数据真正删掉，取而代之的是做伪删除，即在表中添加一个布尔型字段(is_active)，默认为True，执行删除时，将欲删除数据的is_active字段置为False<br><strong>注意</strong>：用伪删除时，确保显示数据的地方，均加了is_active=True的过滤查询</p><h3 id="F对象和Q对象"><a href="#F对象和Q对象" class="headerlink" title="F对象和Q对象"></a>F对象和Q对象</h3><h4 id="F对象"><a href="#F对象" class="headerlink" title="F对象"></a>F对象</h4><p>一个F对象代表数据库中某条记录的字段的信息<br>作用：</p><ul><li>通常是对数据库中的字段值在获取的情况下进行操作</li><li>用于类属性(字段)之间的比较</li></ul><p>语法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from django<span class="selector-class">.db</span><span class="selector-class">.models</span> inport F</span><br><span class="line"><span class="function"><span class="title">F</span><span class="params">(<span class="string">&#x27;列名&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure><p><img src="/2023/01/25/django/F%E5%AF%B9%E8%B1%A1.png"><br>可以配合MySQL（行锁)实现多线程共享数据的更新<br><img src="/2023/01/25/django/%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png"></p><p><img src="/2023/01/25/django/%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0-%E7%A4%BA%E4%BE%8B.png"></p><h4 id="Q对象"><a href="#Q对象" class="headerlink" title="Q对象"></a>Q对象</h4><p>当在获取查询结果集使用复杂的逻辑或|、逻辑非<del>等操作时可以借助于Q对象进行操作<br>Q对象在数据包django.db.models中，需要先导入在使用<br>如果想找出定价低于20元或清华大学出版社的全部书，可以写成：<br><code>Book.objects.filter(Q(price__lt=20)|Q(pub=&quot;清华大学出版社&quot;))</code><br>作用：在条件中用来实现除and(&amp;)以外的or(|)或not(</del>)操作<br>运算符：<br>&amp; 与操作<br>|  或操作<br>~ 非操作<br><img src="/2023/01/25/django/Q%E5%AF%B9%E8%B1%A1.png"></p><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p>聚合查询是指对一个数据表中的一个字段的数据进行部分或全部进行统计查询，查bookstore_book数据表中的全部书的平均价格，查询所有书的总个数等，都要使用聚合查询<br>聚合查询分为整表聚合和分组聚合</p><h4 id="整表聚合"><a href="#整表聚合" class="headerlink" title="整表聚合"></a>整表聚合</h4><p>不带分组的聚合查询是指将全部数据进行集中统计查询<br>聚合函数：导入方法：from django.db.models import *<br>       聚合函数：Sum, Avg, Count, Max, Min<br>语法：MyModel.objects.aggregate(结果变量名=聚合函数(‘列’))<br>返回结果：结果变量名和值组成的字典，格式为：{“结果变量名”：值}<br><img src="/2023/01/25/django/%E6%95%B4%E8%A1%A8%E8%81%9A%E5%90%88.png"></p><h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>分组聚合是指通过计算查询结果中每一个对象所关联的对象集合，从而得出总计值(也可以是平均值或总和)，即为查询集的每一项生成聚合。<br>语法：QuerySet.annotate(结果变量名=聚合函数(‘列’))<br>返回值：QuerySet</p><p>步骤：</p><ol><li>通过先用查询结果MyModel.objects.values查找查询要分组聚合的列，例如MyModel.objects.values(‘列1’,’列2’)</li><li>通过返回结果的QuerySet.annotate方法分组聚合得到分组结果<br><img src="/2023/01/25/django/%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88.png"><h3 id="原生数据库查询"><a href="#原生数据库查询" class="headerlink" title="原生数据库查询"></a>原生数据库查询</h3>Django也可以支持直接使用sql语句的方式通信数据库，<br>查询：使用MyModel.objects.raw()进行数据库查询操作查询<br>语法：MyModel.objects.raw(sql语句,拼接参数)<br>返回值：RawQuerySet集合对象【只支持基础操作，比如循环】</li></ol><p><strong>注意：使用原生语句时小心SQL注入</strong><br><img src="/2023/01/25/django/%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5.png"></p><h4 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h4><p>完全跨过模型类操作数据库-查询/更新/删除</p><ol><li><p>导入cursor所在的包：<br><code>from django.db import connection</code></p></li><li><p>用创建cursor类的构造函数创建cursor对象，在使用cursor对象，为保证在出现异常时能释放cursor资源，通常使用with语句进行创建操作</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">    cur.execute(<span class="string">&#x27;&#x27;</span>执行SQL语句,<span class="string">&#x27;拼接参数&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/01/25/django/cursor.png"></p></li></ol><h3 id="关系映射"><a href="#关系映射" class="headerlink" title="关系映射"></a>关系映射</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一表示现实事物间存在的一对一的对应关系<br>语法：OneToOneFiels(类名, on_delete = xxx)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="constructor">A(<span class="params">model</span>.Model)</span>:<span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator">    </span></span><br><span class="line"><span class="operator"> </span><span class="keyword">class</span> <span class="constructor">B(<span class="params">model</span>.Model)</span>:</span><br><span class="line">    属性 = models.<span class="constructor">OneToOneField(A , <span class="params">on_delete</span> = <span class="params">xxx</span>)</span></span><br></pre></td></tr></table></figure><p>on_delete级联删除的动作有：</p><ol><li>models.CASCADE，级联删除，Django模拟SQL约束ON DELETE CASCADE的行为，并删除包含ForeignKey的对象，注意：<strong>仅仅是Django代码层面的模拟，并不是设置Mysql为级联</strong></li><li>models.PROTECT，抛出ProtectedError以阻止被引用对象的删除，等同于MySQL默认的RESTRICT</li><li>SET_NULL，设置ForignKey null，需要指定null = True</li><li>SET_DEFAULT 将ForeignKey设置为其默认值，必须设置ForeignKey的默认值</li></ol><h5 id="创建数据-1"><a href="#创建数据-1" class="headerlink" title="创建数据"></a>创建数据</h5><ul><li>无外键的模型：</li></ul><p><code>author = Author.objects.create(name=&#39;王老师&#39;)</code></p><ul><li>有外键的模型类：</li></ul><p><code>wife1 = Wife.objects.create(name=&#39;王夫人&#39;, author = author)</code><br><code>wife1 = Wife.objects.create(name=&#39;王夫人&#39;,author_id=1)</code></p><h5 id="查询数据-1"><a href="#查询数据-1" class="headerlink" title="查询数据"></a>查询数据</h5><p>正向查询：<br><img src="/2023/01/25/django/%E6%AD%A3%E5%90%91%E6%9F%A5%E8%AF%A2.png"><br>反向查询：<br><img src="/2023/01/25/django/%E5%8F%8D%E5%90%91%E6%9F%A5%E8%AF%A2.png"></p><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>当一个A对象可以关联多个B对象<br>语法：<br><code>属性 = models.ForeignKey(类名 ， on_delete=xxx)</code></p><h5 id="创建数据-2"><a href="#创建数据-2" class="headerlink" title="创建数据"></a>创建数据</h5><p>先创建一，在创建多<br><img src="/2023/01/25/django/%E5%85%88%E5%88%9B%E4%B8%80%E5%9C%A8%E5%88%9B%E5%A4%9A.png"></p><h5 id="查询数据-2"><a href="#查询数据-2" class="headerlink" title="查询数据"></a>查询数据</h5><p>正向查询：<br><img src="/2023/01/25/django/%E6%AD%A3%E5%90%91%E6%9F%A5%E8%AF%A2-1.png"><br>反向查询：<br><img src="/2023/01/25/django/%E5%8F%8D%E5%90%91%E6%9F%A5%E8%AF%A2-1.png"><br>规则为对应的另外一个类名的小写加下划线加set，获取的集合可以继续操作，例如filter等</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>mysql多对多通常需要多增加一张表来映射，而django自动完成多对多的关联<br>语法：在关联的两个类中的任意一个类中，增加：<br><code>属性 = models.ManyToManyField(MyModel)</code></p><h5 id="创建数据-3"><a href="#创建数据-3" class="headerlink" title="创建数据"></a>创建数据</h5><p><img src="/2023/01/25/django/%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE.png"></p><h5 id="查询数据-3"><a href="#查询数据-3" class="headerlink" title="查询数据"></a>查询数据</h5><p>正向查询：<br>有多对多属性的对象查另一方<br><img src="/2023/01/25/django/%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E6%AD%A3%E5%90%91%E6%9F%A5%E8%AF%A2.png"><br>反向查询：<br><img src="/2023/01/25/django/%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E5%8F%8D%E5%90%91%E6%9F%A5%E8%AF%A2.png"></p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>Django提供了Paginator类可以方便的实现分页功能。<br>Paginator类位于django.core.paginator模块中。</p><h4 id="Paginator对象"><a href="#Paginator对象" class="headerlink" title="Paginator对象"></a>Paginator对象</h4><p>负责分页数据整体的管理<br>对象的构造方法：<br><code>paginator = Paginator(object_list, per_page)</code><br>参数：</p><ul><li>object_list：需要分页数据的对象列表</li><li>per_page 每页数据个数</li></ul><p>返回值：Paginator的对象</p><p>Paginator的属性：</p><ul><li>count：需要分页数据的对象总数</li><li>num_pages：分页后的页面总数</li><li>page_range：从1开始的range对象，用于记录当前页码数</li><li>per_page：每页数据的个数</li></ul><p>Paginator方法：<br>paginator对象.page(number)：<br>参数number为页码信息（从1开始），返回当前number页对应的页信息，如果提供的页码不存在，抛出InvalidPage异常<br>InvalidPage：总的异常基类，包含两个异常子类：</p><ul><li>PageNotAnInteger：当向page()传入一个不是整数的值时抛出</li><li>EmptyPage：当向page()提供一个有效值，但是那个页面上没有任何对象时抛出</li></ul><h4 id="page对象"><a href="#page对象" class="headerlink" title="page对象"></a>page对象</h4><p>负责具体某一页的数据的管理。<br><strong>创建对象</strong>：<br>Paginator对象的page()方法返回Page对象<br>page = paginator.page(页码)<br><strong>Page对象属性</strong>：<br>object_list：当前页上所有数据对象的列表<br>number：当前页的序号，从1开始<br>paginator：当前page对象相关的Paginator对象<br><strong>Page对象方法</strong>：<br>has_next()：如果有下一页返回True<br>has_previous()：如果有上一页返回True<br>has_other_pages()：如果有上一页或下一页返回True<br>next_page_number()：返回下一页的页码，如果下一页不存在，抛出InvalidPage异常<br>previous_page_number()：返回上一页的页码，如果上一页不存在，抛出InvalidPage异常</p><h2 id="admin管理后台"><a href="#admin管理后台" class="headerlink" title="admin管理后台"></a>admin管理后台</h2><p>django提供了比较完善的后台管理数据库的接口，可供开发过程中调用和测试使用<br>django会搜集所有已注册的模型类，为这些模型类提供数据管理界面，供开发者使用</p><h3 id="admin配置步骤"><a href="#admin配置步骤" class="headerlink" title="admin配置步骤"></a>admin配置步骤</h3><ul><li>创建后台管理账号，该账号为管理后台最高权限账号<br><code>python manage.py createsuperuser</code><br>根据提示设置用户名和密码就行<br>然后启动django项目，输入<a href="http://127.0.0.1:8000/admin/%E5%B0%B1%E4%BC%9A%E8%BF%9B%E5%85%A5%E9%BB%98%E8%AE%A4%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2">http://127.0.0.1:8000/admin/就会进入默认登录页面</a><h3 id="注册自定义模型类"><a href="#注册自定义模型类" class="headerlink" title="注册自定义模型类"></a>注册自定义模型类</h3>若要自己定义的模型类也能在/admin后台管理界面中显示和管理，需要将自己的类注册到后台管理界面<br>注册步骤：</li></ul><ol><li>在应用app中的admin.py中导入注册要管理的模型models类，如from .models import Book</li><li>调用admin.site.register方法进行注册，如：admin.site.register(自定义模型类)</li></ol><p>此时显示的样式非常粗糙，可以通过<strong>模型管理器</strong>类来增加<br>作用：为后台管理界面添加便于操作的新功能<br>说明：后台管理器类须继承自django.contrib.admin里的ModelAdmin类<br>使用方法：</p><ol><li><p>在应用app下的admin.py里定义模型管理器类</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">XXXManager</span>(<span class="title">admin</span>.<span class="type">ModelAdmin</span>)</span></span><br><span class="line"><span class="class">    ...</span></span><br></pre></td></tr></table></figure></li><li><p>绑定注册模型管理器和模型类</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> <span class="keyword">admin</span></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">admin</span>.site.register(模型类,XXXManager)</span><br></pre></td></tr></table></figure><p>通常模型管理器类与模型类一一对应<br>模型管理器类常用的属性：</p></li></ol><ul><li>list_display：数组，指示列名</li><li>list_display_links：数组，显示点击后可以编辑数据的字段</li><li>list_filter：数组，可以以哪些字段进行过滤</li><li>search_fields：数组，可以以哪些字段进行模糊搜索</li><li>list_editable：数组，设置哪些列可以直接在列表里调整</li></ul><h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><p>Cookie可以通过HttpResponse设置</p><h3 id="session配置"><a href="#session配置" class="headerlink" title="session配置"></a>session配置</h3><ol><li><p>setting.py中配置<br>向INSTALLED_APPS列表中添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">INSTALLED_APPS</span> = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>向MIDDLEWARE列表中添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MIDDLEWARE</span> = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="/2023/01/25/django/session%E4%BD%BF%E7%94%A8.png"></p></li></ol><p>settings.py中相关配置项：<br>SESSION_COOKIE_AGE：指定sessionid在cookie中的保存时长（默认是两周），如：SESSION_COOKIE_AGE=60* 60* 24* 7* 2<br>SESSION_EXPIRE_AT_BROWSER_CLOSE = True，设置只要浏览器关闭时，session就失效（默认为False）<br><strong>注意：Django中的session数据存储在数据库中，所以使用session前需要确保已执行过migrate</strong></p><p>Django session的问题：</p><ol><li>django_session表是单表设计，且该表数据量持续增持【浏览器故意删掉sessionid&amp;过期数据未删除】</li><li>可以每晚执行python manage.py clearsessions【该命令可删除已过期的session数据】</li></ol><p><img src="/2023/01/25/django/CSRF.png"><br><img src="/2023/01/25/django/CSRF-1.png"></p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h4><p>将缓存的数据粗出在数据库中，尽管存储介质没有更换，但是当把一次负责查询的结果直接存储到表里，比如多个条件的过滤查询结果，可避免重复进行复杂查询，提升效率<br>配置如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHES = &#123;    </span><br><span class="line">    &#x27;default&#x27;: &#123;        </span><br><span class="line">        &#x27;BACKEND&#x27;: &#x27;django.core.cache.backends.db.DatabaseCache&#x27;,</span><br><span class="line">        &#x27;LOCATION&#x27;: &#x27;my_cache_table&#x27;,        </span><br><span class="line">        &#x27;TIMEOUT&#x27;: <span class="number">300</span>,        </span><br><span class="line">        &#x27;OPTIONS&#x27;: &#123;            &#x27;</span><br><span class="line">            MAX_ENTRIES&#x27;: <span class="number">10000</span>,            </span><br><span class="line">            &#x27;CULL_FREQUENCY&#x27;: <span class="number">5</span>        </span><br><span class="line">         &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库缓存设置后需要手动执行命令创建缓存表：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> manage.<span class="keyword">py</span> createcachetable</span><br></pre></td></tr></table></figure><h4 id="本地内存缓存"><a href="#本地内存缓存" class="headerlink" title="本地内存缓存"></a>本地内存缓存</h4><p><img src="/2023/01/25/django/%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98.png"></p><h4 id="文件系统缓存"><a href="#文件系统缓存" class="headerlink" title="文件系统缓存"></a>文件系统缓存</h4><p><img src="/2023/01/25/django/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98.png"></p><h3 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h3><h4 id="整体缓存"><a href="#整体缓存" class="headerlink" title="整体缓存"></a>整体缓存</h4><h5 id="视图函数-1"><a href="#视图函数-1" class="headerlink" title="视图函数"></a>视图函数</h5><p>使用装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"></span><br><span class="line"><span class="meta">@cache_page(<span class="params"><span class="number">30</span></span>)     </span><span class="comment">#30s后过期</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_view</span>(<span class="params">request</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h5 id="路由中"><a href="#路由中" class="headerlink" title="路由中"></a>路由中</h5><p><img src="/2023/01/25/django/%E8%B7%AF%E7%94%B1%E4%B8%AD.png"></p><h4 id="局部缓存"><a href="#局部缓存" class="headerlink" title="局部缓存"></a>局部缓存</h4><p><strong>先引入cache对象</strong><br>方式一：<br>使用caches[‘CACHE配置key’]导入具体对象</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django<span class="selector-class">.core</span><span class="selector-class">.cache</span> import caches</span><br><span class="line"></span><br><span class="line">cache1 = caches<span class="selector-attr">[<span class="string">&#x27;myalias&#x27;</span>]</span></span><br></pre></td></tr></table></figure><p>方式2：<br>from django.core.cache import cache 相当于直接引入CACHES配置项中的‘default’项</p><p><strong>缓存api的使用</strong></p><ol><li><p>cache.set(key, value, timeout)存储缓存<br>key：缓存的key，字符串类型<br>value: Python对象<br>timeout: 缓存存储时间（s），默认为CACHES中的TIMEOUT值<br>返回值：None</p></li><li><p>cache.get(key)获取缓存，如果没有数据，则返回None</p></li><li><p>cache.add(key, value)，存储缓存，只在key不存在时生效，返回值True时存储成功，false为存储失败</p></li><li><p>cache.get_or_set(key, value, timeout)，如果未获取到数据则进行set操作，返回值为value</p></li><li><p>cache.set_many(dict, timeout)，批量存储缓存<br>dict：key和value的字典<br>timeout：存储时间（s）<br>返回值;插入不成功的key的数组</p></li><li><p>cache.get_many(key_list)，批量获取缓存数据<br>key_list：包含key的数组<br>返回值：取到的key和value的字典</p></li><li><p>cache.delete(key)，删除key的缓存数据，返回值为None</p></li><li><p>cache.delete_many(key_list)，批量删除，返回值，None</p></li></ol><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul><li>中间件是django请求/响应处理的钩子框架。它是一个轻量级的、低级的插件系统，用于全局改变Django的输入或输出</li><li>中间件以类的形式体现</li><li>每个中间件组件负责做一些特定的功能</li></ul><h3 id="编写中间件"><a href="#编写中间件" class="headerlink" title="编写中间件"></a>编写中间件</h3><ul><li>中间件类必须继承自django.utils.deprecation.MiddelwareMixin类</li><li>中间件类必须实现下列五个方法中的一个或多个：<ol><li>  process_request(self, request):执行路由之前被调用，在每个请求上调用，返回None或HttpResponse对象</li><li>  process_view(self, request, callback, callback_args, callback_kwargs)：调用视图之前被调用，在每个请求上调用，返回None或HttpResponse对象</li><li>  process_response(self, request, response)：所有响应返回浏览器被调用，在每个请求上调用，返回HttpResponse对象</li><li>  process_exception(self, request, exception)：当处理过程中抛出异常时调用，返回一个HttpResponse对象</li><li>  process_template_response(self, request, response)：在视图函数执行完毕且视图返回的对象中包含render方法时被调用，该方法需要返回实现了render方法的响应对象</li></ol>  <strong>注意：中间件中的大多数方法在返回None时表示忽略当前操作进入下一项事件，当返回HttpResponse对象时表示此请求结束，直接返回给客户端</strong></li></ul><h3 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h3><p>settings.py中需要注册一下自定义的中间件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MIDDLEWARE</span> <span class="operator">=</span> [</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注意：配置为数组，中间件被调用时以‘先上到下’再‘由下到上’的顺序调用</p><h2 id="rest-framework"><a href="#rest-framework" class="headerlink" title="rest framework"></a>rest framework</h2><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><ol><li>  在安装机器上安装和配置同版本的环境（python，数据库等）</li><li>  django项目迁移，把项目文件夹放置在服务器</li><li>  用uwsgi替代python manage.py runserver方法启动服务器</li><li>  配置nginx反向代理服务器</li><li>  用nginx配置静态文件路径，解决静态路径问题</li></ol><h3 id="WSGI定义"><a href="#WSGI定义" class="headerlink" title="WSGI定义"></a>WSGI定义</h3><p>WSGI Web服务器网关接口，是Python应用程序或框架和web服务器之间的一种接口，被广泛使用。<br>当开发结束后，完善的项目代码需要在一个搞笑稳定的环境中运行，这时可以使用WSGI</p><h3 id="uWSGI定义"><a href="#uWSGI定义" class="headerlink" title="uWSGI定义"></a>uWSGI定义</h3><p>uWSGI是WSGI的一种，它实现了http协议、WSGI协议以及uwsgi协议，uWSGI功能完善，支持协议众多，在python web圈热度极高，uWSGI主要以学习配置为主</p><h3 id="uWSGI安装"><a href="#uWSGI安装" class="headerlink" title="uWSGI安装"></a>uWSGI安装</h3><p>执行：<code>pip3 install uwsgi==版本号</code><br>检查是否安装成功：<code>pip3 freeze | grep -i &#39;uwsgi&#39;</code></p><h3 id="配置uWSGI"><a href="#配置uWSGI" class="headerlink" title="配置uWSGI"></a>配置uWSGI</h3><p>添加配置文件 项目同名文件夹/uwsgi.ini<br>如：mysite1/mysite1/uwsgi.ini<br>文件以[uwsgi]开头，有如下配置项：<br>套接字方式的IP地址：端口号,此模式需要有nginx<br><code>socket=127.0.0.1:8000</code><br>Http通信方式的IP地址:端口号<br><code>http=127.0.0.1:8000</code><br>项目当前工作目录：<br><code>chdir=/home/.../my_project</code><br>项目中wsgi.py文件的目录，相对于当前工作目录,是相对于chdir的相对路径<br><code>wsgi-file=my_project/wsgi.py</code><br>进程个数：<br><code>process=4</code><br>每个进程的线程个数：<br><code>threads=2</code><br>服务的pid记录文件<br><code>pidfile=uwsgi.pid</code><br>服务的目标日志文件位置：<br><code>daemonize=uwsgi.log</code><br>开启主进程管理模式：<br><code>master=true</code><br><img src="/2023/01/25/django/%E9%85%8D%E7%BD%AEuWSGI.png"></p><h3 id="uWSGI的运行管理"><a href="#uWSGI的运行管理" class="headerlink" title="uWSGI的运行管理"></a>uWSGI的运行管理</h3><p><strong>启动uwsgi</strong>:<br>cd 到uWSGI的配置文件所在目录：<br><code>uwsgi --ini uwsgi.ini</code><br><strong>停止uwsgi</strong>：<br>cd 到uWSGI的配置文件所在目录：<br><code>uwsgi --stop uwsgi.pid</code><br><img src="/2023/01/25/django/uWSGI%E7%9A%84%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86.png"></p><h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><p><img src="/2023/01/25/django/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9.png"><br><img src="/2023/01/25/django/nginx%E5%93%8D%E5%BA%94.png"></p><h4 id="静态文件配置-1"><a href="#静态文件配置-1" class="headerlink" title="静态文件配置"></a>静态文件配置</h4><p>django框架settings.py中debug=False后，静态文件会无法正常加载了，样式会丢失，可以使用nginx加载静态文件<br>配置步骤：</p><ol><li>创建新路径，主要存放Django所有静态文件，如：/home/…/项目名_static/</li><li>在Django的settings.py中添加新配置<br><code>STATIC_ROOT = &#39;/home/.../项目名_static/static&#39;</code><br>注意，此路径为存放所有正式环境中需要的配置文件</li><li>进入项目，执行<br><code>python manage.py collectstatic</code><br>Django将项目所有静态文件复制到STATIC_ROOT中，包括Django内建的静态文件</li><li>Nginx配置添加新配置<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    location <span class="string">/static</span> &#123;</span><br><span class="line">        <span class="comment"># root 第一步创建文件夹的绝对路径</span></span><br><span class="line">        root <span class="string">/home/.../</span>项目名_static;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/25/django/%E5%AE%9A%E4%B9%89%E5%92%8C%E9%85%8D%E7%BD%AE.png"><br>邮件告警：<br><img src="/2023/01/25/django/%E5%AE%9A%E4%B9%89%E5%92%8C%E9%85%8D%E7%BD%AE-1.png"><br><img src="/2023/01/25/django/%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF.png"><br><img src="/2023/01/25/django/%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.png"><br><img src="/2023/01/25/django/%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF-POST.png"></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Django框架&quot;&gt;&lt;a href=&quot;#Django框架&quot; class=&quot;headerlink&quot; title=&quot;Django框架&quot;&gt;&lt;/a&gt;Django框架&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;版本选择使用TLS版本，长期支持&lt;br&gt;安装：&lt;br&gt;pip3 install django==2.2.12/3.2.11&lt;br&gt;检查是否安装成功：pip3 freeze | grep -i ‘Django’&lt;/p&gt;
&lt;p&gt;初始化项目：&lt;br&gt;在终端执行：django-admin startproject 项目名  即可&lt;/p&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h2&gt;</summary>
    
    
    
    <category term="python" scheme="https://shenhongwei33.github.io/categories/python/"/>
    
    
    <category term="django" scheme="https://shenhongwei33.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="https://shenhongwei33.github.io/2023/01/25/python%E5%9F%BA%E7%A1%80/"/>
    <id>https://shenhongwei33.github.io/2023/01/25/python%E5%9F%BA%E7%A1%80/</id>
    <published>2023-01-25T03:20:17.000Z</published>
    <updated>2023-01-25T03:25:51.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>保证安装了gcc命令，如果没没有安装gcc命令，可以执行  yum install gcc<br>先安装gcc命令</p><ol><li><p>安装可能需要的依赖：yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel</p></li><li><p>从python官网上下载python3.5.1的tar包：wget<br><u><a href="https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz">https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz</a></u></p></li><li><p>将tar包解压到/usr/local目录下： tar -zxvf Python-3.5.1.tgz –C /usr/local/</p></li><li><p>在/usr/local/Python3.5.1目录下执行./configure命令</p></li><li><p>接着执行make命令</p></li><li><p>接着执行make install命令</p></li><li><p>取代原python2.7的软连接，当在命令行输入python的时候，默认启动python3.5.1 ：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf <span class="regexp">/usr/</span>bin/python</span><br><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>Python3.<span class="number">5</span> <span class="regexp">/usr/</span>bin/python</span><br></pre></td></tr></table></figure><p>具体Python3.5到目录下去找，看好首字母是大写还是小写</p></li><li><p>在命令行输入python 查看是不是启动了python3.5.1</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3></li></ol><ul><li>单行注释 以#号开头的后面的就是注释</li><li>python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。</li></ul><p>输出中文编码，解决方法为只要在文件开头加入 # -<em>- coding: UTF-8 -</em>- 或者 # coding=utf-8 就行了</p><blockquote><p>注意：# coding=utf-8 的 = 号两边不要空格。</p></blockquote><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python </span></span><br><span class="line"># -*- coding: UTF-<span class="number">8</span> -*- </span><br><span class="line"></span><br><span class="line">print( <span class="string">&quot;你好，世界&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="Python2-x-中使用-Python3-x-的-print-函数"><a href="#Python2-x-中使用-Python3-x-的-print-函数" class="headerlink" title="Python2.x 中使用 Python3.x 的 print 函数"></a>Python2.x 中使用 Python3.x 的 print 函数</h4><p>如果 Python2.x 版本想使用使用 Python3.x 的 print 函数，可以导入 __ future __ 包，该包禁用 Python2.x 的 print 语句，采用 Python3.x 的 print 函数：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list =[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]&gt;&gt;&gt; <span class="built_in">print</span> list    # python2.x 的 <span class="built_in">print</span> 语句</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> __future__ import print_function  # 导入 __future__ 包&gt;&gt;&gt; <span class="built_in">print</span> list     # Python2.x 的 <span class="built_in">print</span> 语句被禁用，使用报错  </span><br><span class="line">      File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1    </span><br><span class="line">         <span class="built_in">print</span> list             </span><br><span class="line">                 ^</span><br><span class="line"> SyntaxError: invalid syntax</span><br><span class="line"> &gt;&gt;&gt; <span class="built_in">print</span> (list)   # 使用 Python3.x 的 <span class="built_in">print</span> 函数</span><br><span class="line"> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="Python-标识符"><a href="#Python-标识符" class="headerlink" title="Python 标识符"></a>Python 标识符</h4><p>在 Python 里，标识符由字母、数字、下划线组成。</p><p>在 Python 中，所有标识符可以包括英文、数字以及下划线(、_、)，但不能以数字开头。Python 中的标识符是区分大小写的。</p><p>以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。</p><p>以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 <strong>foo</strong> 代表 Python 里特殊方法专用的标识，如 <strong>init</strong>() 代表类的构造函数。<br>Python 可以同一行显示多条语句，方法是用分号 ; 分开。</p><h4 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h4><p>Python语句中一般以新行作为语句的结束符。但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + <span class="string">\</span></span><br><span class="line">        item_two + <span class="string">\</span></span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">days</span> = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Friday&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="Python-引号"><a href="#Python-引号" class="headerlink" title="Python 引号"></a>Python 引号</h4><p>Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须是相同类型的。<br>其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">word</span> = <span class="string">&#x27;word&#x27;</span></span><br><span class="line"><span class="attr">sentence</span> = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line"><span class="attr">paragraph</span> = <span class="string">&quot;&quot;&quot;这是一个段落。</span></span><br><span class="line"><span class="string">包含了多个语句&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Python空行"><a href="#Python空行" class="headerlink" title="Python空行"></a>Python空行</h4><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。记住：空行也是程序代码的一部分。</p><h4 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h4><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 ,。</p><h4 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h4><p>缩进相同的一组语句构成一个代码块，我们称之代码组。<br>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。我们将首行及后面的代码组称为一个子句(clause)。</p><h4 id="Python-变量类型"><a href="#Python-变量类型" class="headerlink" title="Python 变量类型"></a>Python 变量类型</h4><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><p>Python 中的变量赋值不需要类型声明。<br>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><h5 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h5><p>Python有五个标准的数据类型：</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><h6 id="Python-数字"><a href="#Python-数字" class="headerlink" title="Python 数字"></a>Python 数字</h6><p>Python Number 数据类型用于存储数值。<br>数字数据类型用于存储数值，他们是不可改变的数据类型，这意味着改变数字数据类型会<strong>分配一个新的对象</strong>。当你指定一个值时，Number 对象就会被创建。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">var2</span> <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>您也可以使用del语句删除一些对象的引用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">del</span> <span class="selector-tag">var</span></span><br><span class="line"><span class="selector-tag">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><p>Python支持四种不同的数字类型：</p><ul><li>int（有符号整型）</li><li>long（长整型，也可以代表八进制和十六进制）</li><li>float（浮点型）</li><li>complex（复数）</li></ul><p>Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。</p><blockquote><p>long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。</p></blockquote><p><strong>Python math 模块、cmath 模块</strong></p><p>Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。<br>Python math 模块提供了许多对浮点数的数学运算函数。<br>Python cmath 模块包含了一些用于复数运算的函数。</p><p>cmath 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数，math 模块运算的是数学运算。</p><p>要使用 math 或 cmath 函数必须先导入</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure><p>查看 math 查看包中的内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(math)</span><br><span class="line">[<span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;copysign&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;degrees&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;erf&#x27;</span>, <span class="string">&#x27;erfc&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;fabs&#x27;</span>, <span class="string">&#x27;factorial&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;frexp&#x27;</span>, <span class="string">&#x27;fsum&#x27;</span>, <span class="string">&#x27;gamma&#x27;</span>, <span class="string">&#x27;gcd&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;inf&#x27;</span>, <span class="string">&#x27;isclose&#x27;</span>, <span class="string">&#x27;isfinite&#x27;</span>, <span class="string">&#x27;isinf&#x27;</span>, <span class="string">&#x27;isnan&#x27;</span>, <span class="string">&#x27;ldexp&#x27;</span>, <span class="string">&#x27;lgamma&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log2&#x27;</span>, <span class="string">&#x27;modf&#x27;</span>, <span class="string">&#x27;nan&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;radians&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>, <span class="string">&#x27;tau&#x27;</span>, <span class="string">&#x27;trunc&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>Python数学函数</strong></p><table><thead><tr><th>函数</th><th>返回值</th></tr></thead><tbody><tr><td>abs(x)</td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td>ceil(x)</td><td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td>cmp(x, y)</td><td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1</td></tr><tr><td>exp(x)</td><td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td>fabs(x)</td><td>返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td>floor(x)</td><td>返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td>log(x)</td><td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td>log10(x)</td><td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td>max(x1, x2,…)</td><td>返回给定参数的最大值，参数可以为序列。</td></tr><tr><td>min(x1, x2,…)</td><td>返回给定参数的最小值，参数可以为序列。</td></tr><tr><td>modf(x)</td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td>pow(x, y)</td><td>x** y 运算后的值。</td></tr><tr><td>round(x [,n])</td><td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td></tr><tr><td>sqrt(x)</td><td>返回数字x的平方根</td></tr></tbody></table><p><strong>Python随机数函数</strong></p><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>choice(seq)</td><td>从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td>randrange ([start,] stop [,step])</td><td>从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td></tr><tr><td>random()</td><td>随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td>seed([x])</td><td>改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td>shuffle(lst)</td><td>将序列的所有元素随机排序</td></tr><tr><td>uniform(x, y)</td><td>随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table><p><strong>Python三角函数</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>acos(x)</td><td>返回x的反余弦弧度值。</td></tr><tr><td>asin(x)</td><td>返回x的反正弦弧度值。</td></tr><tr><td>atan(x)</td><td>返回x的反正切弧度值。</td></tr><tr><td>atan2(y, x)</td><td>返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td>cos(x)</td><td>返回x的弧度的余弦值。</td></tr><tr><td>hypot(x, y)</td><td>返回欧几里德范数 sqrt(x* x + y* y)。</td></tr><tr><td>sin(x)</td><td>返回的x弧度的正弦值。</td></tr><tr><td>tan(x)</td><td>返回x弧度的正切值。</td></tr><tr><td>degrees(x)</td><td>将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td></tr><tr><td>radians(x)</td><td>将角度转换为弧度</td></tr></tbody></table><p><strong>Python数学常量</strong></p><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>pi</td><td>数学常量 pi（圆周率，一般以π来表示）</td></tr><tr><td>e</td><td>数学常量 e，e即自然常数（自然常数）。</td></tr></tbody></table><h6 id="Python字符串"><a href="#Python字符串" class="headerlink" title="Python字符串"></a>Python字符串</h6><p>python的字串列表有2种取值顺序:</p><ul><li>从左到右索引默认0开始的，最大范围是字符串长度少1</li><li>从右到左索引默认-1开始的，最大范围是字符串开头</li></ul><p>如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="string">&#x27;abcdef&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s[<span class="number">1</span>:<span class="number">5</span>]</span></span><br><span class="line">&#x27;bcde&#x27;</span><br></pre></td></tr></table></figure><p>当使用以冒号分隔的字符串，python 返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="type">string</span> = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(<span class="type">string</span>[:<span class="number">-1</span>])</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure><p>加号（+）是字符串连接运算符，星号（* ）是重复操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="type">string</span> = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> (<span class="type">string</span> * <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(<span class="type">string</span> + <span class="string">&quot;TEST&quot;</span>)</span><br><span class="line">abcdefabcdef</span><br><span class="line">abcdefTEST</span><br></pre></td></tr></table></figure><p>Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。</p><p><strong>Python 字符串格式化</strong></p><p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> (<span class="string">&quot;My name is %s and weight is %d kg!&quot;</span> % (<span class="string">&#x27;Zara&#x27;</span>, <span class="number">21</span>) )</span><br><span class="line">My name <span class="keyword">is</span> Zara and weight <span class="keyword">is</span> <span class="number">21</span> kg!</span><br></pre></td></tr></table></figure><p>python 字符串格式化符号:</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>%c</td><td>格式化字符及其ASCII码</td></tr><tr><td>%s</td><td>格式化字符串</td></tr><tr><td>%d</td><td>格式化整数</td></tr><tr><td>%u</td><td>格式化无符号整型</td></tr><tr><td>%o</td><td>格式化无符号八进制数</td></tr><tr><td>%x</td><td>格式化无符号十六进制数</td></tr><tr><td>%X</td><td>格式化无符号十六进制数（大写）</td></tr><tr><td>%f</td><td>格式化浮点数字，可指定小数点后的精度</td></tr><tr><td>%e</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%E</td><td>作用同%e，用科学计数法格式化浮点数</td></tr><tr><td>%g</td><td>%f和%e的简写</td></tr><tr><td>%G</td><td>%F 和 %E 的简写</td></tr><tr><td>%p</td><td>用十六进制数格式化变量的地址</td></tr></tbody></table><p>格式化操作符辅助指令:</p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>定义宽度或者小数点精度</td></tr><tr><td>-</td><td>用做左对齐</td></tr><tr><td>+</td><td>在正数前面显示加号( + )</td></tr><tr><td><sp></sp></td><td>在正数前面显示空格</td></tr><tr><td>#</td><td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td>0</td><td>显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td>%</td><td>‘%%’输出一个单一的’%’</td></tr><tr><td>(var)</td><td>映射变量(字典参数)</td></tr><tr><td>m.n.</td><td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。</p><p><strong>Python 三引号</strong></p><p>Python 中三引号可以将复杂的字符串进行赋值。Python 三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。</p><p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。一个典型的用例是，当你需要一块HTML或者SQL时，这时当用三引号标记，使用传统的转义字符体系将十分费神。</p><p><strong>python的字符串内建函数</strong></p><p>这些方法实现了string模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对Unicode的支持，有一些甚至是专门用于Unicode的。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr><td>string.count(str, beg=0, end=len(string))</td><td>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td>string.decode(encoding=’UTF-8’, errors=’strict’)</td><td>以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td></tr><tr><td>string.encode(encoding=’UTF-8’, errors=’strict’)</td><td>以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td>string.endswith(obj, beg=0, end=len(string))</td><td>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td>string.find(str, beg=0, end=len(string))</td><td>检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td>string.format()</td><td>格式化字符串</td></tr><tr><td>string.index(str, beg=0, end=len(string))</td><td>跟find()方法一样，只不过如果str不在 string中会报一个异常.</td></tr><tr><td>string.isspace()</td><td>如果 string 中只包含空格，则返回 True，否则返回 False.</td></tr><tr><td>string.join(seq)</td><td>以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td>string.partition(str)</td><td>有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.</td></tr><tr><td>string.replace(str1, str2,  num=string.count(str1))</td><td>把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td></tr><tr><td>string.rfind(str, beg=0,end=len(string) )</td><td>类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。</td></tr><tr><td>string.rstrip()</td><td>删除 string 字符串末尾的空格.</td></tr><tr><td>string.split(str=””, num=string.count(str))</td><td>以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+1 个子字符串</td></tr><tr><td>string.strip([obj])</td><td>在 string 上执行 lstrip()和 rstrip()</td></tr><tr><td>string.translate(str, del=””)</td><td>根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td></tr></tbody></table><h6 id="Python列表"><a href="#Python列表" class="headerlink" title="Python列表"></a>Python列表</h6><p>List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。<br>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。<br>列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。列表的数据项不需要具有相同的类型。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;myList = <span class="selector-attr">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(myList<span class="selector-attr">[1:4]</span>)</span><br><span class="line"><span class="selector-attr">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span></span><br></pre></td></tr></table></figure><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;myList = <span class="selector-attr">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(myList<span class="selector-attr">[1:4:2]</span>)</span><br><span class="line"><span class="selector-attr">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span></span><br></pre></td></tr></table></figure><p>加号 + 是列表连接运算符，星号 * 是重复操作。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;myList = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;tinylist = [<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;print (tinylist * <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;print(tinylist + myList)</span><br><span class="line">[<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line">[<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br></pre></td></tr></table></figure><p>你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项；<br>可以使用 del 语句来删除列表的元素；</p><p><strong>Python列表函数&amp;方法</strong></p><p>Python包含以下函数:</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>cmp(list1, list2)</td><td>比较两个列表的元素</td></tr><tr><td>len(list)</td><td>列表元素个数</td></tr><tr><td>max(list)</td><td>返回列表元素最大值</td></tr><tr><td>min(list)</td><td>返回列表元素最小值</td></tr><tr><td>list(seq)</td><td>将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>list.append(obj)</td><td>在列表末尾添加新的对象</td></tr><tr><td>list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>list.extend(seq)</td><td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>list.index(obj)</td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>list.insert(index, obj)</td><td>将对象插入列表</td></tr><tr><td>list.pop([index=-1])</td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>list.remove(obj)</td><td>移除列表中某个值的第一个匹配项</td></tr><tr><td>list.reverse()</td><td>反向列表中元素</td></tr><tr><td>list.sort(cmp=None, key=None, reverse=False)</td><td>对原列表进行排序</td></tr></tbody></table><h6 id="Python-元组"><a href="#Python-元组" class="headerlink" title="Python 元组"></a>Python 元组</h6><p>元组是另一个数据类型，类似于 List（列表）。元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于<strong>只读列表</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line">&gt;&gt;&gt;tinytuple = (<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> (tinytuple * <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(tinytuple + <span class="built_in">tuple</span>)</span><br><span class="line">(<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>)</span><br><span class="line">(<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span>)</span><br></pre></td></tr></table></figure><p>元组中只包含一个元素时，需要在元素后面添加逗号，元组与字符串类似，下标索引从0开始，可以进行截取，组合等。<br>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合<br>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组</p><p><strong>元组内置函数</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>cmp(tuple1, tuple2)</td><td>比较两个元组元素。</td></tr><tr><td>len(tuple)</td><td>计算元组元素个数。</td></tr><tr><td>max(tuple)</td><td>返回元组中元素最大值。</td></tr><tr><td>min(tuple)</td><td>返回元组中元素最小值。</td></tr><tr><td>tuple(seq)</td><td>将列表转换为元组。</td></tr></tbody></table><h6 id="Python-字典"><a href="#Python-字典" class="headerlink" title="Python 字典"></a>Python 字典</h6><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成，键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一，值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;dict = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt;dict<span class="selector-attr">[<span class="string">&#x27;one&#x27;</span>]</span> = <span class="string">&quot;This is one&quot;</span></span><br><span class="line">&gt;&gt;&gt;dict<span class="selector-attr">[2]</span> = <span class="string">&quot;This is two&quot;</span></span><br><span class="line">&gt;&gt;&gt;tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">6734</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;sales&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;print (dict<span class="selector-attr">[2]</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(tinydict<span class="selector-class">.keys</span>())</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(tinydict<span class="selector-class">.values</span>())</span><br><span class="line">This is two</span><br><span class="line"><span class="function"><span class="title">dict_keys</span><span class="params">([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;dept&#x27;</span>])</span></span></span><br><span class="line"><span class="function"><span class="title">dict_values</span><span class="params">([<span class="string">&#x27;runoob&#x27;</span>, <span class="number">6734</span>, <span class="string">&#x27;sales&#x27;</span>])</span></span></span><br></pre></td></tr></table></figure><p>把相应的键放入熟悉的方括弧，就可以访问字典里的值</p><p>能删单一的元素也能清空字典，清空只需一项操作。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">del</span> tinydict[<span class="string">&#x27;Name&#x27;</span>]  <span class="comment"># 删除键是&#x27;Name&#x27;的条目</span></span><br><span class="line">tinydict.clear()  <span class="comment"># 清空字典所有条目</span></span><br><span class="line"><span class="built_in">del</span> tinydict  <span class="comment"># 删除字典</span></span><br></pre></td></tr></table></figure><p>字典值可以没有限制地取任何 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。<br>两个重要的点需要记住</p><ol><li>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</li><li>键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行</li></ol><p><strong>字典内置函数&amp;方法</strong></p><p>Python字典包含了以下内置函数：<br>| 函数              | 描述                                               |<br>| —————– | ————————————————– |<br>| cmp(dict1, dict2) | 比较两个字典元素。                                 |<br>| len(dict)         | 计算字典元素个数，即键的总数。                     |<br>| str(dict)         | 输出字典可打印的字符串表示。                       |<br>| type(variable)    | 返回输入的变量类型，如果变量是字典就返回字典类型。 |</p><p>Python字典包含了以下内置方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>dict.clear()</td><td>删除字典内所有元素</td></tr><tr><td>dict.copy()</td><td>返回一个字典的浅复制</td></tr><tr><td>dict.fromkeys(seq[, val])</td><td>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td>dict.get(key, default=None)</td><td>返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td>dict.has_key(key)</td><td>如果键在字典dict里返回true，否则返回false</td></tr><tr><td>dict.items()</td><td>以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td>dict.keys()</td><td>以列表返回一个字典所有的键</td></tr><tr><td>dict.setdefault(key, default=None)</td><td>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td>dict.update(dict2)</td><td>把字典dict2的键/值对更新到dict里</td></tr><tr><td>dict.values()</td><td>以列表返回字典中的所有值</td></tr><tr><td>pop(key[,default])</td><td>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td>popitem()</td><td>返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h6 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h6><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x [,base])</td><td>将x转换为一个整数</td></tr><tr><td>long(x [,base] )</td><td>将x转换为一个长整数</td></tr><tr><td>float(x)</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将对象 x 转换为字符串</td></tr><tr><td>repr(x)</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列 s 转换为一个列表</td></tr><tr><td>set(s)</td><td>转换为可变集合</td></tr><tr><td>dict(d)</td><td>创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td>frozenset(s)</td><td>转换为不可变集合</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>unichr(x)</td><td>将一个整数转换为Unicode字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h4 id="Python-运算符"><a href="#Python-运算符" class="headerlink" title="Python 运算符"></a>Python 运算符</h4><p>Python语言支持以下类型的运算符:</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>赋值运算符</li><li>逻辑运算符</li><li>位运算符</li><li>成员运算符</li><li>身份运算符</li><li>运算符优先级</li></ul><h5 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h5><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂，如a** b 为10的20次方</td></tr><tr><td>//</td><td>取整除 - 返回商的整数部分（向下取整），如9//2的结果为4</td></tr></tbody></table><blockquote><p>Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。</p></blockquote><p>python3返回对应的数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> (1/2)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(1.0/2)</span><br><span class="line">0.5</span><br><span class="line">0.5</span><br></pre></td></tr></table></figure><h5 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h5><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>等于 - 比较对象是否相等</td></tr><tr><td>!=</td><td>不等于 - 比较两个对象是否不相等</td></tr><tr><td>&lt;&gt;</td><td>不等于 - 比较两个对象是否不相等。<strong>python3 已废弃</strong>。</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr></tbody></table><h5 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h5><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符</td></tr><tr><td>+=</td><td>加法赋值运算符</td></tr><tr><td>-=</td><td>减法赋值运算符</td></tr><tr><td>* =</td><td>乘法赋值运算符</td></tr><tr><td>/=</td><td>除法赋值运算符</td></tr><tr><td>%=</td><td>取模赋值运算符</td></tr><tr><td>** =</td><td>幂赋值运算符</td></tr><tr><td>//=</td><td>取整除赋值运算符</td></tr></tbody></table><h5 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h5><p>按位运算符是把数字看作二进制来进行计算的</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td></tr><tr><td>|</td><td>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td></tr><tr><td>^</td><td>按位异或运算符：当两对应的二进位相异时，结果为1</td></tr><tr><td>~</td><td>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数</td></tr></tbody></table><h5 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h5><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” : 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或” : 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” : 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td></tr></tbody></table><h5 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h5><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line">list = <span class="selector-attr">[1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="selector-tag">a</span> <span class="keyword">in</span> list ):    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;变量 a 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;变量 a 不在给定的列表中 list 中&quot;</span>)</span><br><span class="line"></span><br><span class="line">输出：变量 <span class="selector-tag">a</span> 不在给定的列表中 list 中</span><br></pre></td></tr></table></figure><h5 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h5><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td></tr></tbody></table><p>注： id() 函数用于获取对象内存地址。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = <span class="number">20</span></span><br><span class="line"><span class="selector-tag">b</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> <span class="selector-tag">a</span> is <span class="selector-tag">b</span>:    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 和 b 有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(id(a)</span></span>)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="selector-tag">a</span> 和 <span class="selector-tag">b</span> 有相同的标识</span><br><span class="line"><span class="number">1893215680</span></span><br></pre></td></tr></table></figure><p><strong>is 与 == 区别</strong>：is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。</p><h4 id="Python-条件语句"><a href="#Python-条件语句" class="headerlink" title="Python 条件语句"></a>Python 条件语句</h4><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。<br>Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。<br>Python 编程中 if 语句用于控制程序的执行，基本形式为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure><p>当判断条件为多个值时，可以使用以下形式：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if 判断条件1</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">执行语句1……</span></span><br><span class="line"><span class="attribute">elif 判断条件2</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">执行语句2……</span></span><br><span class="line"><span class="attribute">elif 判断条件3</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">执行语句3……</span></span><br><span class="line"><span class="attribute">else</span><span class="punctuation">:</span></span><br><span class="line">    执行语句4……</span><br></pre></td></tr></table></figure><p>由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。<br>当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于&gt;（大于）、&lt;（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。</p><h4 id="Python-循环语句"><a href="#Python-循环语句" class="headerlink" title="Python 循环语句"></a>Python 循环语句</h4><p>Python 提供了 for 循环和 while 循环（在 Python 中没有 do..while 循环）:</p><table><thead><tr><th>循环类型</th><th>描述</th></tr></thead><tbody><tr><td>while 循环</td><td>在给定的判断条件为 true 时执行循环体，否则退出循环体。</td></tr><tr><td>for 循环</td><td>重复执行语句</td></tr><tr><td>嵌套循环</td><td>你可以在while循环体中嵌套for循环</td></tr></tbody></table><h5 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h5><p>循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：</p><table><thead><tr><th>控制语句</th><th>描述</th></tr></thead><tbody><tr><td>break 语句</td><td>在语句块执行过程中终止循环，并且跳出整个循环</td></tr><tr><td>continue 语句</td><td>在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。</td></tr><tr><td>pass 语句</td><td>pass是空语句，是为了保持程序结构的完整性。</td></tr></tbody></table><h5 id="Python-While-循环语句"><a href="#Python-While-循环语句" class="headerlink" title="Python While 循环语句"></a>Python While 循环语句</h5><p>在 python 中，while … else 在循环条件为 false 时执行 else 语句块：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">count</span> &lt; <span class="number">3</span>:    </span><br><span class="line">    print(<span class="built_in">count</span>, <span class="string">&quot; is  less than 3&quot;</span>)    </span><br><span class="line">    <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">    print(<span class="built_in">count</span>, <span class="string">&quot; is not less than 3&quot;</span>)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span>  <span class="keyword">is</span>  <span class="keyword">less than</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="keyword">is</span>  <span class="keyword">less than</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span>  <span class="keyword">is</span>  <span class="keyword">less than</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">less than</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="Python-for-循环语句"><a href="#Python-for-循环语句" class="headerlink" title="Python for 循环语句"></a>Python for 循环语句</h5><p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。<br>for循环的语法格式如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">for</span> <span class="variable">iterating_var</span> <span class="variable"><span class="keyword">in</span></span> <span class="variable">sequence</span>:</span><br><span class="line">   <span class="function"><span class="title">statements</span>(<span class="variable">s</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,  <span class="string">&#x27;mango&#x27;</span>]</span><br><span class="line">for fruit in fruits:    </span><br><span class="line">    print(<span class="string">&#x27;当前水果: %s&#x27;</span> <span class="comment">% fruit)</span></span><br><span class="line">输出：</span><br><span class="line">当前水果: banana</span><br><span class="line">当前水果: apple</span><br><span class="line">当前水果: mango</span><br></pre></td></tr></table></figure><h6 id="通过序列索引迭代"><a href="#通过序列索引迭代" class="headerlink" title="通过序列索引迭代"></a>通过序列索引迭代</h6><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,  <span class="string">&#x27;mango&#x27;</span>]</span><br><span class="line">for <span class="keyword">index</span> <span class="keyword">in</span> <span class="meta">range</span>(le<span class="meta">n</span>(fruits)):   </span><br><span class="line">    pr<span class="meta">int</span>(<span class="string">&#x27;当前水果 : %s&#x27;</span> % fruits[<span class="keyword">index</span>])</span><br><span class="line">输出：</span><br><span class="line">当前水果 : banana</span><br><span class="line">当前水果 : apple</span><br><span class="line">当前水果 : mango</span><br></pre></td></tr></table></figure><p>以上实例我们使用了内置函数 len() 和 range(),函数 len() 返回列表的长度，即元素的个数。 range返回一个序列的数。</p><p>在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。</p><h4 id="Python-break-语句"><a href="#Python-break-语句" class="headerlink" title="Python break 语句"></a>Python break 语句</h4><p>Python break语句，就像在C语言中，打破了最小封闭for或while循环。</p><p>break语句用来终止循环语句，即循环条件没有False条件或者序列还没被完全递归完，也会停止执行循环语句。break语句用在while和for循环中。如果您使用嵌套循环，break语句将停止执行最深层的循环，并开始执行下一行代码。</p><h4 id="Python-continue-语句"><a href="#Python-continue-语句" class="headerlink" title="Python continue 语句"></a>Python continue 语句</h4><p>Python continue 语句跳出本次循环，而break跳出整个循环。continue 语句用来告诉Python跳过当前循环的剩余语句，然后继续进行下一轮循环。continue语句用在while和for循环中。</p><h4 id="Python-pass-语句"><a href="#Python-pass-语句" class="headerlink" title="Python pass 语句"></a>Python pass 语句</h4><p>Python pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。Python 语言 pass 语句语法格式如下。</p><h4 id="Python-日期和时间"><a href="#Python-日期和时间" class="headerlink" title="Python 日期和时间"></a>Python 日期和时间</h4><p>Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。</p><p>时间间隔是以秒为单位的浮点小数。每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳, </p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import <span class="built_in">time</span></span><br><span class="line">&gt;&gt;&gt;ticket = <span class="built_in">time</span>.<span class="built_in">time</span>()</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(ticket)</span><br><span class="line"><span class="number">1639988201</span>.<span class="number">8350108</span></span><br></pre></td></tr></table></figure><p>时间戳单位最适于做日期运算。</p><h5 id="什么是时间元组？"><a href="#什么是时间元组？" class="headerlink" title="什么是时间元组？"></a>什么是时间元组？</h5><p>很多Python函数用一个元组装起来的9组数字处理时间:</p><table><thead><tr><th>序号</th><th>字段</th><th>值</th></tr></thead><tbody><tr><td>0</td><td>4位数年</td><td>2008</td></tr><tr><td>1</td><td>月</td><td>1 到 12</td></tr><tr><td>2</td><td>日</td><td>1到31</td></tr><tr><td>3</td><td>小时</td><td>0到23</td></tr><tr><td>4</td><td>分钟</td><td>0到59</td></tr><tr><td>5</td><td>秒</td><td>0到61 (60或61 是闰秒)</td></tr><tr><td>6</td><td>一周的第几日</td><td>0到6 (0是周一)</td></tr><tr><td>7</td><td>一年的第几日</td><td>1到366 (儒略历)</td></tr><tr><td>8</td><td>夏令时</td><td>-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><p>上述也就是struct_time元组。这种结构具有如下属性：</p><table><thead><tr><th>序号</th><th>属性</th><th>值</th></tr></thead><tbody><tr><td>0</td><td>tm_year</td><td>2008</td></tr><tr><td>1</td><td>tm_mon</td><td>1 到 12</td></tr><tr><td>2</td><td>tm_mday</td><td>1 到 31</td></tr><tr><td>3</td><td>tm_hour</td><td>0 到 23</td></tr><tr><td>4</td><td>tm_min</td><td>0 到 59</td></tr><tr><td>5</td><td>tm_sec</td><td>0 到 61 (60或61 是闰秒)</td></tr><tr><td>6</td><td>tm_wday</td><td>0到6 (0是周一)</td></tr><tr><td>7</td><td>tm_yday</td><td>1 到 366(儒略历)</td></tr><tr><td>8</td><td>tm_isdst</td><td>-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><h5 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h5><p>从返回浮点数的时间戳方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;localtime = time.localtime(time.time())</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(localtime)</span><br><span class="line">time.struct_time(<span class="attribute">tm_year</span>=2021, <span class="attribute">tm_mon</span>=12, <span class="attribute">tm_mday</span>=20, <span class="attribute">tm_hour</span>=16, <span class="attribute">tm_min</span>=33, <span class="attribute">tm_sec</span>=9, <span class="attribute">tm_wday</span>=0, <span class="attribute">tm_yday</span>=354, <span class="attribute">tm_isdst</span>=0)</span><br></pre></td></tr></table></figure><h5 id="获取格式化的时间"><a href="#获取格式化的时间" class="headerlink" title="获取格式化的时间"></a>获取格式化的时间</h5><p>你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime():</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">localtime</span> = <span class="type">time</span>.asctime( <span class="type">time</span>.<span class="built_in">localtime</span>(<span class="type">time</span>.time()) )</span><br><span class="line">&gt;&gt;&gt;print(<span class="built_in">localtime</span>)</span><br><span class="line">Mon <span class="type">Dec</span> <span class="number">20</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">32</span> <span class="number">2021</span></span><br></pre></td></tr></table></figure><h5 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h5><p>我们可以使用 time 模块的 strftime 方法来格式化日期：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">time</span><span class="selector-class">.strftime</span>(format<span class="selector-attr">[, t]</span>)</span><br></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> (time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime()))</span><br><span class="line"><span class="number">2021</span>-<span class="number">12</span>-<span class="number">20</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">43</span></span><br></pre></td></tr></table></figure><p>python中时间日期格式化符号：</p><ul><li>%y 两位数的年份表示（00-99）</li><li>%Y 四位数的年份表示（000-9999）</li><li>%m 月份（01-12）</li><li>%d 月内中的一天（0-31）</li><li>%H 24小时制小时数（0-23)</li><li>%I 12小时制小时数（01-12）</li><li>%M 分钟数（00-59）</li><li>%S 秒（00-59）</li><li>%a 本地简化星期名称</li><li>%A 本地完整星期名称</li><li>%b 本地简化的月份名称</li><li>%B 本地完整的月份名称</li><li>%c 本地相应的日期表示和时间表示</li><li>%j 年内的一天（001-366）</li><li>%p 本地A.M.或P.M.的等价符</li><li>%U 一年中的星期数（00-53）星期天为星期的开始</li><li>%w 星期（0-6），星期天为星期的开始</li><li>%W 一年中的星期数（00-53）星期一为星期的开始</li><li>%x 本地相应的日期表示</li><li>%X 本地相应的时间表示</li><li>%Z 当前时区的名称</li><li>%% %号本身</li></ul><h5 id="日历（Calendar）模块"><a href="#日历（Calendar）模块" class="headerlink" title="日历（Calendar）模块"></a>日历（Calendar）模块</h5><h6 id="获取某月日历"><a href="#获取某月日历" class="headerlink" title="获取某月日历"></a>获取某月日历</h6><p>Calendar模块有很广泛的方法用来处理年历和月历,例如打印某月的月历：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import calendar</span><br><span class="line">&gt;&gt;&gt;cal = calendar.month(2021, 12)</span><br><span class="line">&gt;&gt;&gt;print(cal)</span><br><span class="line">   December 2021</span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line">      <span class="number"> 1 </span><span class="number"> 2 </span><span class="number"> 3 </span><span class="number"> 4 </span> 5</span><br><span class="line"><span class="number"> 6 </span><span class="number"> 7 </span><span class="number"> 8 </span><span class="number"> 9 </span>10<span class="number"> 11 </span>12</span><br><span class="line">13<span class="number"> 14 </span>15<span class="number"> 16 </span>17<span class="number"> 18 </span>19</span><br><span class="line">20<span class="number"> 21 </span>22<span class="number"> 23 </span>24<span class="number"> 25 </span>26</span><br></pre></td></tr></table></figure><p>星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>calendar.calendar(year,w=2,l=1,c=6)</td><td>返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。</td></tr><tr><td>calendar.firstweekday( )</td><td>返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。</td></tr><tr><td>calendar.isleap(year)</td><td>是闰年返回 True，否则为 False。</td></tr><tr><td>calendar.leapdays(y1,y2)</td><td>返回在Y1，Y2两年之间的闰年总数。</td></tr><tr><td>calendar.month(year,month,w=2,l=1)</td><td>返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。</td></tr><tr><td>calendar.monthcalendar(year,month)</td><td>返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。</td></tr><tr><td>calendar.monthrange(year,month)</td><td>返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。</td></tr><tr><td>calendar.prcal(year,w=2,l=1,c=6)</td><td>相当于 print calendar.calendar(year,w=2,l=1,c=6)。</td></tr><tr><td>calendar.prmonth(year,month,w=2,l=1)</td><td>相当于 print calendar.month(year,month,w=2,l=1) 。</td></tr><tr><td>calendar.setfirstweekday(weekday)</td><td>设置每周的起始日期码。0（星期一）到6（星期日）。</td></tr><tr><td>calendar.timegm(tupletime)</td><td>和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。</td></tr><tr><td>calendar.weekday(year,month,day)</td><td>返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。</td></tr></tbody></table><h5 id="Time-模块"><a href="#Time-模块" class="headerlink" title="Time 模块"></a>Time 模块</h5><p>Time 模块包含了以下内置函数，既有时间处理的，也有转换时间格式的：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>time.altzone</td><td>返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。</td></tr><tr><td>time.asctime([tupletime])</td><td>接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。</td></tr><tr><td>time.clock( )</td><td>用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。</td></tr><tr><td>time.ctime([secs])</td><td>作用相当于asctime(localtime(secs))，未给参数相当于asctime()</td></tr><tr><td>time.gmtime([secs])</td><td>接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0</td></tr><tr><td>time.localtime([secs])</td><td>接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。</td></tr><tr><td>time.mktime(tupletime)</td><td>接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。</td></tr><tr><td>time.sleep(secs)</td><td>推迟调用线程的运行，secs指秒数。</td></tr><tr><td>time.strftime(fmt[,tupletime])</td><td>接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。</td></tr><tr><td>time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’)</td><td>根据fmt的格式把一个时间字符串解析为时间元组。</td></tr><tr><td>time.time( )</td><td>返回当前时间的时间戳（1970纪元后经过的浮点秒数）。</td></tr><tr><td>time.tzset()</td><td>根据环境变量TZ重新初始化时间相关设置。</td></tr></tbody></table><p>Time模块包含了以下2个非常重要的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>time.timezone</td><td>属性 time.timezone 是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲&lt;=0大部分欧洲，亚洲，非洲）。</td></tr><tr><td>time.tzname</td><td>属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</td></tr></tbody></table><h4 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a>Python 函数</h4><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p><h5 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h5><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p><ul><li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。</li><li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params"> parameters </span>): </span><br><span class="line">    <span class="string">&quot;函数_文档字符串&quot;</span> </span><br><span class="line">    function_suite </span><br><span class="line">    <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><p>在 python 中，类型属于对象，变量是没有类型的。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="attr">a</span>=<span class="string">&quot;Runoob&quot;</span></span><br></pre></td></tr></table></figure><p>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。</p><h6 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h6><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li><strong>不可变类型</strong>：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</li><li><strong>可变类型</strong>：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li><strong>不可变类型</strong>：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li><li><strong>可变类型</strong>：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li></ul><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>以下是调用函数时可使用的正式参数类型：</p><ul><li>必备参数</li><li>关键字参数</li><li>默认参数</li><li>不定长参数</li></ul><p><strong>必备参数</strong></p><p>必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样，不然会出现语法错误。</p><p><strong>关键字参数</strong></p><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明 </span></span><br><span class="line">def printinfo( name, age ): </span><br><span class="line">    <span class="string">&quot;打印任何传入的字符串&quot;</span> </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Name: &quot;</span>, name </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Age &quot;</span>, age </span><br><span class="line">    return </span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数 </span></span><br><span class="line">printinfo( <span class="attribute">age</span>=50, <span class="attribute">name</span>=<span class="string">&quot;miki&quot;</span> )</span><br></pre></td></tr></table></figure><p><strong>默认参数</strong></p><p>调用函数时，默认参数的值如果没有传入，则被认为是默认值。</p><p><strong>不定长参数</strong></p><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def functionname([<span class="keyword">formal</span><span class="number">_</span>args,] *var<span class="number">_</span>args<span class="number">_</span>tuple ): </span><br><span class="line">    <span class="string">&quot;函数_文档字符串&quot;</span> </span><br><span class="line">    <span class="keyword">function</span><span class="number">_</span>suite </span><br><span class="line">    <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><p>加了星号（* ）的变量名会存放所有未命名的变量参数。不定长参数实例如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 可写函数说明 </span></span><br><span class="line">def printinfo( arg1, *vartuple ): </span><br><span class="line">    <span class="string">&quot;打印任何传入的参数&quot;</span> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;输出: &quot;</span> </span><br><span class="line">    <span class="keyword">print</span> arg1 </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">var</span> <span class="keyword">in</span> vartuple: </span><br><span class="line">        <span class="keyword">print</span> <span class="built_in">var</span> </span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line"><span class="meta"># 调用printinfo 函数 </span></span><br><span class="line">printinfo( <span class="number">10</span> ) </span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br></pre></td></tr></table></figure><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>python 使用 lambda 来创建匿名函数。</p><ul><li>lambda只是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><p>lambda函数的语法只包含一个语句，如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lambda</span> [arg1 [,arg2,.....argn]]<span class="symbol">:expression</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> )</span><br></pre></td></tr></table></figure><h5 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h5><p>return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。</p><h5 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h5><p>一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：</p><ul><li>全局变量</li><li>局部变量</li></ul><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。<br>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。</p><h4 id="Python-模块"><a href="#Python-模块" class="headerlink" title="Python 模块"></a>Python 模块</h4><p>Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。</p><p>模块让你能够有逻辑地组织你的 Python 代码段。把相关的代码分配到一个模块里能让你的代码更好用，更易懂。模块能定义函数，类和变量，模块里也能包含可执行的代码。</p><h5 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h5><p>模块定义好后，我们可以使用 import 语句来引入模块，语法如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">module</span><span class="number">1</span>[, <span class="keyword">module</span><span class="number">2</span>[,... moduleN]]</span><br></pre></td></tr></table></figure><p>比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名.函数名</span><br></pre></td></tr></table></figure><p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端.</p><p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p><h6 id="from…import-语句"><a href="#from…import-语句" class="headerlink" title="from…import 语句"></a>from…import 语句</h6><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="built_in">math</span> <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h6 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h6><p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是：</p><ul><li>当前目录</li><li>如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。</li><li>如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li></ul><p>模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。<br>作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。<br>在 UNIX 系统，典型的 PYTHONPATH 如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PYTHONPATH=<span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>python</span><br></pre></td></tr></table></figure><h6 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h6><p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。<br>Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。因此，如果要给函数内的全局变量赋值，必须使用 global 语句。<br>global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句前的注释符就能解决这个问题。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Money</span> = <span class="number">2000</span></span><br><span class="line">def  AddMoney() :    </span><br><span class="line">    # 想改正代码就取消以下注释:    </span><br><span class="line">    <span class="keyword">global</span> <span class="type">Money</span>    </span><br><span class="line">    <span class="type">Money</span> = <span class="type">Money</span> + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">print(<span class="type">Money</span>)</span><br><span class="line">AddMoney()</span><br><span class="line">print(<span class="type">Money</span>)</span><br></pre></td></tr></table></figure><h6 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h6><p>dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有模块，变量和函数。</p><h6 id="globals-和-locals-函数"><a href="#globals-和-locals-函数" class="headerlink" title="globals() 和 locals() 函数"></a>globals() 和 locals() 函数</h6><p>根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。如果在函数内部调用 globals()，返回的是所有在该函数里能访问的全局名字。两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。</p><h6 id="reload-函数"><a href="#reload-函数" class="headerlink" title="reload() 函数"></a>reload() 函数</h6><p>当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。因此，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块。语法如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">reload</span><span class="params">(module_name)</span></span></span><br></pre></td></tr></table></figure><h6 id="Python中的包"><a href="#Python中的包" class="headerlink" title="Python中的包"></a>Python中的包</h6><p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。简单来说，包就是文件夹，但该文件夹下必须存在 __ init __ .py 文件, 该文件的内容可以为空。__ init __ .py 用于标识当前文件夹是一个包。例如：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="keyword">py</span></span><br><span class="line">package_runoob</span><br><span class="line">|-- __init__.<span class="keyword">py</span></span><br><span class="line">|-- runoob1.<span class="keyword">py</span></span><br><span class="line">|-- runoob2.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 Phone 包 </span></span><br><span class="line"><span class="keyword">from</span> package_runoob.runoob1 <span class="keyword">import</span> runoob1 </span><br><span class="line"><span class="keyword">from</span> package_runoob.runoob2 <span class="keyword">import</span> runoob2 </span><br><span class="line">runoob1() </span><br><span class="line">runoob2()</span><br></pre></td></tr></table></figure><h4 id="Python-文件I-O"><a href="#Python-文件I-O" class="headerlink" title="Python 文件I/O"></a>Python 文件I/O</h4><h5 id="打印到屏幕"><a href="#打印到屏幕" class="headerlink" title="打印到屏幕"></a>打印到屏幕</h5><p>最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式。</p><h5 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h5><p>Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下：</p><ul><li>raw_input</li><li>input</li></ul><h6 id="raw-input函数"><a href="#raw-input函数" class="headerlink" title="raw_input函数"></a>raw_input函数</h6><p>raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str_my = raw_input(<span class="string">&quot;请输入：&quot;</span>)</span><br><span class="line">print (<span class="string">&quot;你输入的内容是: &quot;</span>, str_my)</span><br></pre></td></tr></table></figure><p>其中python2才具有该函数，python3仅包含input函数</p><h6 id="input函数"><a href="#input函数" class="headerlink" title="input函数"></a>input函数</h6><p>input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，在python2中 input 可以接收一个Python表达式作为输入，并将运算结果返回，python3中仅仅将输入作为字符串</p><h5 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h5><p>Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。</p><h6 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h6><p>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写，具体语法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file <span class="selector-tag">object</span> = <span class="built_in">open</span>(file_name <span class="selector-attr">[, access_mode]</span><span class="selector-attr">[, buffering]</span>)</span><br></pre></td></tr></table></figure><p>各个参数的细节如下：</p><ul><li>file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。</li><li>access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li><li>buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</li></ul><p>完整的语法格式为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(file, <span class="attribute">mode</span>=<span class="string">&#x27;r&#x27;</span>, <span class="attribute">buffering</span>=-1, <span class="attribute">encoding</span>=None, <span class="attribute">errors</span>=None, <span class="attribute">newline</span>=None, <span class="attribute">closefd</span>=<span class="literal">True</span>, <span class="attribute">opener</span>=None)</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>file: 必需，文件路径（相对或者绝对路径）。</li><li>mode: 可选，文件打开模式</li><li>buffering: 设置缓冲</li><li>encoding: 一般使用utf8</li><li>errors: 报错级别</li><li>newline: 区分换行符</li><li>closefd: 传入的file参数类型</li><li>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</li></ul><p>不同模式打开文件的完全列表：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>t</td><td>文本模式 (默认)。</td></tr><tr><td>x</td><td>写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td>b</td><td>二进制模式。</td></tr><tr><td>+</td><td>打开一个文件进行更新(可读可写)。</td></tr><tr><td>U</td><td>通用换行模式（不推荐）。</td></tr><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p><img src="/2023/01/25/python%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6.png"></p><h5 id="File对象的属性"><a href="#File对象的属性" class="headerlink" title="File对象的属性"></a>File对象的属性</h5><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。<br>以下是和file对象相关的所有属性的列表：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>file.closed</td><td>返回true如果文件已被关闭，否则返回false。</td></tr><tr><td>file.mode</td><td>返回被打开文件的访问模式。</td></tr><tr><td>file.name</td><td>返回文件的名称。</td></tr><tr><td>file.softspace</td><td>如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td></tr></tbody></table><h6 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h6><p>File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。语法：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.<span class="keyword">close</span>()</span><br></pre></td></tr></table></figure><h6 id="write-方法"><a href="#write-方法" class="headerlink" title="write()方法"></a>write()方法</h6><p>write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。<br>write()方法不会在字符串的结尾添加换行符(‘\n’)：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.<span class="built_in">write</span>(<span class="built_in">string</span>)</span><br></pre></td></tr></table></figure><h6 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h6><p>read()方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.<span class="built_in">read</span>([<span class="built_in">count</span>])</span><br></pre></td></tr></table></figure><p>在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。</p><h6 id="file对象常用函数"><a href="#file对象常用函数" class="headerlink" title="file对象常用函数"></a>file对象常用函数</h6><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>file.close()</td><td>关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td>2</td><td>file.flush()</td><td>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入</td></tr><tr><td>3</td><td>file.fileno()</td><td>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td>4</td><td>file.isatty()</td><td>如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td>5</td><td>file.next()</td><td>返回文件下一行。</td></tr><tr><td>6</td><td>file.read([size])</td><td>从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td>7</td><td>file.readline([size])</td><td>读取整行，包括 “\n” 字符。</td></tr><tr><td>8</td><td>file.readlines([sizeint])</td><td>读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。</td></tr><tr><td>9</td><td>file.seek(offset[, whence])</td><td>设置文件当前位置</td></tr><tr><td>10</td><td>file.tell()</td><td>返回文件当前位置。</td></tr><tr><td>11</td><td>file.truncate([size])</td><td>截取文件，截取的字节通过size指定，默认为当前文件位置。</td></tr><tr><td>12</td><td>file.write(str)</td><td>将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td>13</td><td>file.writelines(sequence)</td><td>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table><h5 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h5><p>tell()方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python# -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = fo.read(<span class="number">10</span>)<span class="built_in">print</span> <span class="string">&quot;读取的字符串是 : &quot;</span>, <span class="built_in">str</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查找当前位置</span></span><br><span class="line">position = fo.tell()<span class="built_in">print</span> <span class="string">&quot;当前文件位置 : &quot;</span>, position</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把指针再次重新定位到文件开头</span></span><br><span class="line">position = fo.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">str</span> = fo.read(<span class="number">10</span>)<span class="built_in">print</span> <span class="string">&quot;重新读取字符串 : &quot;</span>, <span class="built_in">str</span></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><h5 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h5><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。</p><h6 id="rename-方法"><a href="#rename-方法" class="headerlink" title="rename() 方法"></a>rename() 方法</h6><p>rename() 方法需要两个参数，当前的文件名和新文件名。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.rename(current_file_name, <span class="keyword">new</span><span class="type">_file_name</span>)</span><br></pre></td></tr></table></figure><h6 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h6><p>你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.<span class="built_in">remove</span>(file_name)</span><br></pre></td></tr></table></figure><h5 id="Python里的目录"><a href="#Python里的目录" class="headerlink" title="Python里的目录"></a>Python里的目录</h5><p>所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。</p><h6 id="mkdir-方法"><a href="#mkdir-方法" class="headerlink" title="mkdir()方法"></a>mkdir()方法</h6><p>可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.mkdir(<span class="string">&quot;newdir&quot;</span>)</span><br></pre></td></tr></table></figure><h6 id="chdir-方法"><a href="#chdir-方法" class="headerlink" title="chdir()方法"></a>chdir()方法</h6><p>可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.chdir(<span class="string">&quot;newdir&quot;</span>)</span><br></pre></td></tr></table></figure><p>getcwd()方法：getcwd()方法显示当前的工作目录。</p><h6 id="rmdir-方法"><a href="#rmdir-方法" class="headerlink" title="rmdir()方法"></a>rmdir()方法</h6><p>rmdir()方法删除目录，目录名称以参数传递。在删除这个目录之前，它的所有内容应该先被清除。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.rmdir(<span class="string">&#x27;dirname&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Python-异常处理"><a href="#Python-异常处理" class="headerlink" title="Python 异常处理"></a>Python 异常处理</h4><p>python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误。</p><ul><li>异常处理</li><li>断言</li></ul><p>异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。异常是Python对象，表示一个错误。当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>捕捉异常可以使用try/except语句。try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。如果你不想在异常发生时结束你的程序，只需在try里捕获它。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line"><span class="variable">&lt;语句&gt;</span>        <span class="comment">#运行别的代码</span></span><br><span class="line">except <span class="variable">&lt;名字&gt;</span>：</span><br><span class="line"><span class="variable">&lt;语句&gt;</span>        <span class="comment">#如果在try部份引发了&#x27;name&#x27;异常</span></span><br><span class="line">except <span class="variable">&lt;名字&gt;</span>，<span class="variable">&lt;数据&gt;</span>:</span><br><span class="line"><span class="variable">&lt;语句&gt;</span>        <span class="comment">#如果引发了&#x27;name&#x27;异常，获得附加的数据</span></span><br><span class="line">else:</span><br><span class="line"><span class="variable">&lt;语句&gt;</span>        <span class="comment">#如果没有异常发生</span></span><br></pre></td></tr></table></figure><p>try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。</p><ul><li>如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</li><li>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。</li><li>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fh = <span class="built_in">open</span>(<span class="string">&quot;testfile&quot;</span>, <span class="string">&quot;w&quot;</span>)    </span><br><span class="line">    fh.write(<span class="string">&quot;这是一个测试文件，用于测试异常!!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> IOError:    </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Error: 没有找到文件或读取文件失败&quot;</span></span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;内容写入文件成功&quot;</span>    </span><br><span class="line">    fh.close()</span><br></pre></td></tr></table></figure><h5 id="使用except而带多种异常类型"><a href="#使用except而带多种异常类型" class="headerlink" title="使用except而带多种异常类型"></a>使用except而带多种异常类型</h5><p>你可以不带任何异常类型使用except，如下实例：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    正常的操作</span><br><span class="line">   <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</span><br><span class="line">except:</span><br><span class="line">    发生异常，执行这块代码</span><br><span class="line">   <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure><p>以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。</p><h5 id="使用except而带多种异常类型-1"><a href="#使用except而带多种异常类型-1" class="headerlink" title="使用except而带多种异常类型"></a>使用except而带多种异常类型</h5><p>你也可以使用相同的except语句来处理多个异常信息，如下所示：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">try:</span><br><span class="line">    正常的操作</span><br><span class="line">   <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</span><br><span class="line">except(Exception1<span class="meta">[</span>, Exception2<span class="meta">[</span>,<span class="params">...</span>ExceptionN<span class="meta">]</span>]):</span><br><span class="line">   发生以上多个异常中的一个，执行这块代码</span><br><span class="line">   ......................</span><br><span class="line">else:</span><br><span class="line">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure><h5 id="try-finally-语句"><a href="#try-finally-语句" class="headerlink" title="try-finally 语句"></a>try-finally 语句</h5><p>try-finally 语句无论是否发生异常都将执行最后的代码。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">try</span>:</span><br><span class="line"><span class="section">&lt;语句&gt;</span></span><br><span class="line"><span class="attribute">finally</span>:</span><br><span class="line"><span class="section">&lt;语句&gt;</span>    <span class="comment">#退出try时总会执行</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    fh = <span class="built_in">open</span>(<span class="string">&quot;testfile&quot;</span>, <span class="string">&quot;w&quot;</span>)    </span><br><span class="line">    <span class="keyword">try</span>:        </span><br><span class="line">        fh.write(<span class="string">&quot;这是一个测试文件，用于测试异常!!&quot;</span>)    </span><br><span class="line">    <span class="keyword">finally</span>:        </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;关闭文件&quot;</span>        </span><br><span class="line">        fh.close()</span><br><span class="line"><span class="keyword">except</span> IOError:    </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Error: 没有找到文件或读取文件失败&quot;</span></span><br></pre></td></tr></table></figure><p>当在try块中抛出一个异常，立即执行finally块代码。finally块中的所有语句执行后，异常被再次触发，并执行except块代码。参数的内容不同于异常。</p><h5 id="异常的参数"><a href="#异常的参数" class="headerlink" title="异常的参数"></a>异常的参数</h5><p>一个异常可以带上参数，可作为输出的异常信息参数。你可以通过except语句来捕获异常的参数，如下所示：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    正常的操作</span><br><span class="line">   <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</span><br><span class="line">except ExceptionType, Argument:</span><br><span class="line">    你可以在这输出 Argument 的值<span class="params">...</span></span><br></pre></td></tr></table></figure><p>变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。元组通常包含错误字符串，错误数字，错误位置。</p><h5 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h5><p>我们可以使用raise语句自己触发异常，raise语法格式如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise <span class="comment">[Exception <span class="comment">[, args <span class="comment">[, traceback]</span>]</span>]</span></span><br></pre></td></tr></table></figure><p>语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。</p><p>一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。定义一个异常非常简单，如下所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def functionName( <span class="keyword">level</span> ):    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">level</span> &lt; <span class="number">1</span>:        </span><br><span class="line">        <span class="keyword">raise</span> <span class="keyword">Exception</span>(&quot;Invalid level!&quot;, <span class="keyword">level</span>)        </span><br><span class="line">        # 触发异常后，后面的代码就不会再执行</span><br></pre></td></tr></table></figure><blockquote><p>注意：为了能够捕获异常，”except”语句必须有用相同的异常来抛出类对象或者字符串。</p></blockquote><p>例如我们捕获以上异常，”except”语句如下所示：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    正常逻辑<span class="keyword">except</span> Exception,err:</span><br><span class="line">    触发自定义异常    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    其余代码</span><br></pre></td></tr></table></figure><h5 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h5><p>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Networkerror</span>(<span class="title class_">RuntimeError</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, arg</span>):</span><br><span class="line">        <span class="variable language_">self</span>.args = arg</span><br></pre></td></tr></table></figure><h2 id="Python-面向对象"><a href="#Python-面向对象" class="headerlink" title="Python 面向对象"></a>Python 面向对象</h2><h3 id="面向对象技术简介"><a href="#面向对象技术简介" class="headerlink" title="面向对象技术简介"></a>面向对象技术简介</h3><ul><li>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li>数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。</li><li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>局部变量：定义在方法中的变量，只作用于当前实例的类。</li><li>实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</li><li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li>实例化：创建一个类的实例，类的具体对象。</li><li>方法：类中定义的函数。</li><li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">   <span class="string">&#x27;类的帮助信息&#x27;</span>   <span class="meta">#类文档字符串</span></span><br><span class="line">   class_suite  <span class="meta">#类体</span></span><br></pre></td></tr></table></figure><p>类的帮助信息可以通过ClassName.__ doc__查看。class_suite 由类成员，方法，数据属性组成。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>: </span><br><span class="line">    <span class="string">&#x27;所有员工的基类&#x27;</span> </span><br><span class="line">    empCount = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, name, salary</span>): </span><br><span class="line">        <span class="variable language_">self</span>.name = name </span><br><span class="line">        <span class="variable language_">self</span>.salary = salary </span><br><span class="line">        <span class="title class_">Employee</span>.empCount += <span class="number">1</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">displayCount</span>(<span class="params"><span class="variable language_">self</span></span>): </span><br><span class="line">        print <span class="string">&quot;Total Employee %d&quot;</span> % <span class="title class_">Employee</span>.empCount </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">displayEmployee</span>(<span class="params"><span class="variable language_">self</span></span>): </span><br><span class="line">        print <span class="string">&quot;Name : &quot;</span>, <span class="variable language_">self</span>.name, <span class="string">&quot;, Salary: &quot;</span>, <span class="variable language_">self</span>.salary</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。</li><li>第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法</li><li>self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</li></ul><h4 id="self代表类的实例，而非类"><a href="#self代表类的实例，而非类" class="headerlink" title="self代表类的实例，而非类"></a>self代表类的实例，而非类</h4><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>(<span class="params"><span class="variable language_">self</span></span>): </span><br><span class="line">        print(<span class="variable language_">self</span>) </span><br><span class="line">        print(<span class="variable language_">self</span>.__class__) </span><br><span class="line">        </span><br><span class="line">t = <span class="title class_">Test</span>() </span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test<span class="built_in"> instance </span>at 0x10d066878&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure><p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.__ class__ 则指向类。self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:</p><h3 id="创建实例对象"><a href="#创建实例对象" class="headerlink" title="创建实例对象"></a>创建实例对象</h3><p>实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。以下使用类的名称 Employee 来实例化，并通过 __ init__ 方法接收参数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;创建 Employee 类的第一个对象&quot;</span></span><br><span class="line">emp1 = Employee(<span class="string">&quot;Zara&quot;</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="string">&quot;创建 Employee 类的第二个对象&quot;</span></span><br><span class="line">emp2 = Employee(<span class="string">&quot;Manni&quot;</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h4 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h4><p>您可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emp1.display<span class="constructor">Employee()</span></span><br><span class="line">emp2.display<span class="constructor">Employee()</span></span><br><span class="line">print <span class="string">&quot;Total Employee %d&quot;</span> % <span class="module-access"><span class="module"><span class="identifier">Employee</span>.</span></span>empCount</span><br></pre></td></tr></table></figure><p>你可以添加，删除，修改类的属性，如下所示：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emp1.age = <span class="number">7</span>  <span class="meta"># 添加一个 <span class="string">&#x27;age&#x27;</span> 属性</span></span><br><span class="line">emp1.age = <span class="number">8</span>  <span class="meta"># 修改 <span class="string">&#x27;age&#x27;</span> 属性</span></span><br><span class="line">del emp1.age  <span class="meta"># 删除 <span class="string">&#x27;age&#x27;</span> 属性</span></span><br></pre></td></tr></table></figure><p>你也可以使用以下函数的方式来访问属性：</p><ul><li>getattr(obj, name[, default]) : 访问对象的属性。</li><li>setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。</li><li>delattr(obj, name) : 删除属性。</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hasattr(emp1, <span class="string">&#x27;age&#x27;</span>) # 如果存在 <span class="string">&#x27;age&#x27;</span> 属性返回 <span class="literal">True</span>。 </span><br><span class="line">getattr(emp1, <span class="string">&#x27;age&#x27;</span>) # 返回 <span class="string">&#x27;age&#x27;</span> 属性的值 </span><br><span class="line">setattr(emp1, <span class="string">&#x27;age&#x27;</span>, <span class="number">8</span>) # 添加属性 <span class="string">&#x27;age&#x27;</span> 值为 <span class="number">8</span> </span><br><span class="line">delattr(emp1, <span class="string">&#x27;age&#x27;</span>) # 删除属性 <span class="string">&#x27;age&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Python内置类属性"><a href="#Python内置类属性" class="headerlink" title="Python内置类属性"></a>Python内置类属性</h4><ul><li>__ dict__ : 类的属性（包含一个字典，由类的数据属性组成）</li><li>__ doc__ :类的文档字符串</li><li>__ name__: 类名</li><li>__ module__: 类定义所在的模块（类的全名是’<strong>main</strong>.className’，如果类位于一个导入模块mymod中，那么className.<strong>module</strong> 等于 mymod）</li><li>__ bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li></ul><h4 id="python对象销毁-垃圾回收"><a href="#python对象销毁-垃圾回收" class="headerlink" title="python对象销毁(垃圾回收)"></a>python对象销毁(垃圾回收)</h4><p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 Python 内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是”立即”的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。<br>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</p><p>析构函数 __ del__ ，__del__在对象销毁的时候被调用，当对象不再被使用时，__del__方法运行。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。</p><p>继承语法：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名(基类名)</span></span><br><span class="line"><span class="class">    ...</span></span><br></pre></td></tr></table></figure><p>在python中继承中的一些特点：</p><p>1、如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看： python 子类继承父类构造函数说明。<br>子类不重写 __ init__，实例化子类时，会自动调用父类定义的 __ init__。<br>如果重写了__init__ 时，实例化子类，就不会调用父类已经定义的 __ init__。<br>如果重写了__init__ 时，要继承父类的构造方法，可以使用 super 关键字：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">super</span><span class="params">(子类，self)</span></span>.<span class="built_in">__init__</span>(参数<span class="number">1</span>，参数<span class="number">2</span>，....)</span><br></pre></td></tr></table></figure><p>还有一种经典写法：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类名称.__init__(<span class="built_in">self</span>,参数<span class="number">1</span>，参数<span class="number">2</span>，<span class="params">...</span>)</span><br></pre></td></tr></table></figure><p>2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数<br>3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。</p><p>如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。<br>派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">SubClassName</span> (<span class="type">ParentClass1</span>[, <span class="type">ParentClass2</span>, ...]):</span></span><br><span class="line"><span class="class">    ...</span></span><br></pre></td></tr></table></figure><p>你可以使用issubclass()或者isinstance()方法来检测。</p><ul><li>issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup)</li><li>isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。</li></ul><h4 id="基础重载方法"><a href="#基础重载方法" class="headerlink" title="基础重载方法"></a>基础重载方法</h4><p>下表列出了一些通用的功能，你可以在自己的类重写：</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>__ init__ ( self [,args…] )</td><td>构造函数简单的调用方法: obj = className(args)</td></tr><tr><td>2</td><td>__ del__( self )</td><td>析构方法, 删除一个对象简单的调用方法 : del obj</td></tr><tr><td>3</td><td>__ repr__( self )</td><td>转化为供解释器读取的形式简单的调用方法 : repr(obj)</td></tr><tr><td>4</td><td>__ str__( self )</td><td>用于将值转化为适于人阅读的形式简单的调用方法 : str(obj)</td></tr><tr><td>5</td><td>__ cmp__ ( self, x )</td><td>对象比较简单的调用方法 : cmp(obj, x)</td></tr></tbody></table><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>Python同样支持运算符重载，实例如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/usr/bin/python </span><br><span class="line"><span class="keyword">class</span> Vector: </span><br><span class="line">    def <span class="constructor">__init__(<span class="params">self</span>, <span class="params">a</span>, <span class="params">b</span>)</span>: </span><br><span class="line">        self.a = a </span><br><span class="line">        self.b = b </span><br><span class="line">        </span><br><span class="line">    def <span class="constructor">__str__(<span class="params">self</span>)</span>: </span><br><span class="line">        return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b) </span><br><span class="line">        </span><br><span class="line">    def <span class="constructor">__add__(<span class="params">self</span>,<span class="params">other</span>)</span>: </span><br><span class="line">        return <span class="constructor">Vector(<span class="params">self</span>.<span class="params">a</span> + <span class="params">other</span>.<span class="params">a</span>, <span class="params">self</span>.<span class="params">b</span> + <span class="params">other</span>.<span class="params">b</span>)</span> </span><br><span class="line">        </span><br><span class="line">v1 = <span class="constructor">Vector(2,10)</span> </span><br><span class="line">v2 = <span class="constructor">Vector(5,-2)</span> </span><br><span class="line">print v1 + v2</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下所示:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Vector</span><span class="params">(<span class="number">7</span>,<span class="number">8</span>)</span></span></span><br></pre></td></tr></table></figure><h4 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h4><h5 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h5><p>__ private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__ private_attrs。</p><h5 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h5><p>在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数</p><h5 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h5><p>__ private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.__ private_methods</p><p>Python不允许实例化的类访问私有数据，但你可以使用 object._ className__attrName（ 对象名._ 类名__私有属性名 ）访问属性，参考以下:</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/python# -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Runoob:</span><br><span class="line">    __site = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line"></span><br><span class="line">runoob = Runoob()</span><br><span class="line">print runoob._Runoob__site</span><br></pre></td></tr></table></figure><p><strong>单下划线、双下划线、头尾双下划线说明：</strong></p><ul><li>__ foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 <strong>init</strong>() 之类的。</li><li>_ foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *</li><li>__ foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</li></ul><h2 id="Python-CGI编程"><a href="#Python-CGI编程" class="headerlink" title="Python CGI编程"></a>Python CGI编程</h2><p>CGI 目前由 NCSA 维护，NCSA 定义 CGI 如下：CGI(Common Gateway Interface)，通用网关接口，它是一段程序，运行在服务器上如：HTTP 服务器，提供同客户端 HTML 页面的接口。</p><h2 id="Python-多线程"><a href="#Python-多线程" class="headerlink" title="Python 多线程"></a>Python 多线程</h2><p>Python中使用线程有两种方式：函数或者用类来包装线程对象。</p><p>Python3 线程中常用的两个模块为：</p><ul><li>_ thread</li><li>threading(推荐使用)</li></ul><p>函数式：调用thread模块中的start_new_thread()函数来产生新线程。语法如下:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_thread.start_new_thread ( <span class="function"><span class="keyword">function</span>, <span class="title">args</span><span class="params">[, kwargs]</span> )</span></span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>function - 线程函数。</li><li>args - 传递给线程函数的参数,他必须是个tuple类型。</li><li>kwargs - 可选参数。</li></ul><p>线程的结束一般依靠线程函数的自然结束；也可以在线程函数中调用thread.exit()，他抛出SystemExit exception，达到退出线程的目的。</p><h3 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h3><p>Python3 通过两个标准库 _ thread 和 threading 提供对线程的支持。_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。threading 模块除了包含 _ thread 模块中的所有方法外，还提供的其他方法：</p><ul><li>threading.currentThread(): 返回当前的线程变量。</li><li>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</li><li>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</li></ul><p>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</p><ul><li>run(): 用以表示线程活动的方法。</li><li>start():启动线程活动</li><li>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</li><li>isAlive(): 返回线程是否活动的。</li><li>getName(): 返回线程名。</li><li>setName(): 设置线程名。</li></ul><h3 id="使用-threading-模块创建线程"><a href="#使用-threading-模块创建线程" class="headerlink" title="使用 threading 模块创建线程"></a>使用 threading 模块创建线程</h3><p>我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span> (threading.Thread):    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, threadID, name, delay</span>):                                                      threading.Thread.__init__(self)        </span><br><span class="line">        self.threadID = threadID        </span><br><span class="line">        self.name = name        </span><br><span class="line">        self.delay = delay    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        </span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开始线程：&quot;</span> + self.name)        </span><br><span class="line">        print_time(self.name, self.delay, <span class="number">5</span>)        </span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;退出线程：&quot;</span> + self.name)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_time</span>(<span class="params">threadName, delay, counter</span>):    </span><br><span class="line">    <span class="keyword">while</span> counter:        </span><br><span class="line">    <span class="keyword">if</span> exitFlag:            </span><br><span class="line">        threadName.exit()        </span><br><span class="line">    time.sleep(delay)        </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))        </span><br><span class="line">    counter -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment"># 创建新线程</span></span><br><span class="line"> thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line"> thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"> <span class="comment"># 开启新线程</span></span><br><span class="line"> thread1.start()</span><br><span class="line"> thread2.start()</span><br><span class="line"> thread1.join()</span><br><span class="line"> thread2.join()</span><br><span class="line"> <span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。考虑这样一种情况：一个列表里所有元素都是0，线程”set”从后向前把所有元素改成1，而线程”print”负责从前往后读取列表并打印。那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。锁有两种状态——锁定和未锁定。每当一个线程比如”set”要访问共享数据时，必须先获得锁定；如果已经有别的线程比如”print”获得锁定了，那么就让线程”set”暂停，也就是同步阻塞；等到线程”print”访问完毕，释放锁以后，再让线程”set”继续。经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span> (threading.Thread):    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, threadID, name, delay</span>):                                                      threading.Thread.__init__(self)        </span><br><span class="line">        self.threadID = threadID        </span><br><span class="line">        self.name = name        </span><br><span class="line">        self.delay = delay    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        </span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开始线程：&quot;</span> + self.name)        </span><br><span class="line">        <span class="comment"># 获取锁，用于线程同步</span></span><br><span class="line">        threadLock.acquire()</span><br><span class="line">        print_time(self.name, self.delay, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line">        threadLock.release()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_time</span>(<span class="params">threadName, delay, counter</span>):    </span><br><span class="line">    <span class="keyword">while</span> counter:        </span><br><span class="line">    <span class="keyword">if</span> exitFlag:            </span><br><span class="line">        threadName.exit()        </span><br><span class="line">    time.sleep(delay)        </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))        </span><br><span class="line">    counter -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment"># 创建新线程</span></span><br><span class="line"> thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line"> thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"> threadLock = threading.Lock()</span><br><span class="line"> threads = []</span><br><span class="line"> <span class="comment"># 开启新线程thread1.start()</span></span><br><span class="line"> thread2.start()</span><br><span class="line"> <span class="comment"># 添加线程到线程列表</span></span><br><span class="line"> threads.append(thread1)</span><br><span class="line"> threads.append(thread2)</span><br><span class="line"> <span class="comment"># 等待所有线程完成</span></span><br><span class="line"> <span class="keyword">for</span> t <span class="keyword">in</span> threads:    </span><br><span class="line">    t.join()</span><br><span class="line">    </span><br><span class="line"> <span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="线程优先级队列（-Queue）"><a href="#线程优先级队列（-Queue）" class="headerlink" title="线程优先级队列（ Queue）"></a>线程优先级队列（ Queue）</h3><p>Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。Queue 模块中的常用方法:</p><ul><li>Queue.qsize() 返回队列的大小</li><li>Queue.empty() 如果队列为空，返回True,反之False</li><li>Queue.full() 如果队列满了，返回True,反之False</li><li>Queue.full 与 maxsize 大小对应</li><li>Queue.get([block[, timeout]])获取队列，timeout等待时间</li><li>Queue.get_nowait() 相当Queue.get(False)</li><li>Queue.put(item) 写入队列，timeout等待时间</li><li>Queue.put_nowait(item) 相当Queue.put(item, False)</li><li>Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</li><li>Queue.join() 实际上意味着等到队列为空，再执行别的操作</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;python&quot;&gt;&lt;a href=&quot;#python&quot; class=&quot;headerlink&quot; title=&quot;python&quot;&gt;&lt;/a&gt;python&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;保证安装了gcc命令，如果没没有安装gcc命令，可以执行  yum install gcc&lt;br&gt;先安装gcc命令&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装可能需要的依赖：yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从python官网上下载python3.5.1的tar包：wget&lt;br&gt;&lt;u&gt;&lt;a href=&quot;https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz&quot;&gt;https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将tar包解压到/usr/local目录下： tar -zxvf Python-3.5.1.tgz –C /usr/local/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在/usr/local/Python3.5.1目录下执行./configure命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着执行make命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着执行make install命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;取代原python2.7的软连接，当在命令行输入python的时候，默认启动python3.5.1 ：&lt;/p&gt;
&lt;figure class=&quot;highlight awk&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rm -rf &lt;span class=&quot;regexp&quot;&gt;/usr/&lt;/span&gt;bin/python&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ln -s &lt;span class=&quot;regexp&quot;&gt;/usr/&lt;/span&gt;local&lt;span class=&quot;regexp&quot;&gt;/bin/&lt;/span&gt;Python3.&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;regexp&quot;&gt;/usr/&lt;/span&gt;bin/python&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体Python3.5到目录下去找，看好首字母是大写还是小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在命令行输入python 查看是不是启动了python3.5.1&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;h3 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;单行注释 以#号开头的后面的就是注释&lt;/li&gt;
&lt;li&gt;python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="python" scheme="https://shenhongwei33.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://shenhongwei33.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>gin框架</title>
    <link href="https://shenhongwei33.github.io/2023/01/25/gin%E6%A1%86%E6%9E%B6/"/>
    <id>https://shenhongwei33.github.io/2023/01/25/gin%E6%A1%86%E6%9E%B6/</id>
    <published>2023-01-25T02:56:42.000Z</published>
    <updated>2023-01-25T03:18:28.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>创建项目目录，进入目录后执行<code>go mod init 项目名</code><br>然后用golang打开，设置下载代理<a href="https://goproxy.cn,创建入口文件main.go,并放置main方法/">https://goproxy.cn，创建入口文件main.go，并放置main方法</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接可以引入依赖，比如：<code>import &quot;github.com/gin-gonic/gin&quot;</code><br>此时依赖标红，然后下载依赖，同时会在go.mod里面显示增加的依赖，代码中也没有报错<br>然后代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;       </span><br><span class="line">    r := gin.Default()       </span><br><span class="line">    r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;              </span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123; </span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,              </span><br><span class="line">        &#125;)       </span><br><span class="line">    &#125;)       </span><br><span class="line">    r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go run .\main.go</code>，如果不出错，且可以访问，那么基本就可以了。</p><h1 id="gin路由"><a href="#gin路由" class="headerlink" title="gin路由"></a>gin路由</h1><h2 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h2><p>gin 框架中采用的路由库是基于<a href="https://github.com/julienschmidt/httprouter">httprouter</a>做的。</p><h2 id="API参数"><a href="#API参数" class="headerlink" title="API参数"></a>API参数</h2><p>可以通过Context的Param方法来获取API参数<br>例如：localhost:8000/xxx/zhangsan</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    r := gin.<span class="keyword">Default</span>()</span><br><span class="line">    r.<span class="built_in">GET</span>(<span class="string">&quot;/user/:name/*action&quot;</span>, func(c *gin.Context) &#123;</span><br><span class="line">        <span class="built_in">name</span> := c.<span class="built_in">Param</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        <span class="built_in">action</span> := c.<span class="built_in">Param</span>(<span class="string">&quot;action&quot;</span>)</span><br><span class="line">        <span class="comment">//截取/</span></span><br><span class="line">        <span class="built_in">action</span> = strings.<span class="built_in">Trim</span>(<span class="built_in">action</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">        c.String(http.StatusOK, <span class="built_in">name</span>+<span class="string">&quot; is &quot;</span>+<span class="built_in">action</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//默认为监听8080端口</span></span><br><span class="line">    r.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URL参数"><a href="#URL参数" class="headerlink" title="URL参数"></a>URL参数</h2><p>URL参数可以通过DefaultQuery()或Query()方法获取，其中DefaultQuery()若参数不存在，返回默认值，Query()若不存在，返回空串<br>格式为：API?name=zs</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    r := gin<span class="selector-class">.Default</span>()</span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/user&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        <span class="comment">//指定默认值</span></span><br><span class="line">        <span class="comment">//http://localhost:8080/user 才会打印出来默认的值</span></span><br><span class="line">        name := c<span class="selector-class">.DefaultQuery</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;枯藤&quot;</span>)</span><br><span class="line">        c<span class="selector-class">.String</span>(http<span class="selector-class">.StatusOK</span>, fmt<span class="selector-class">.Sprintf</span>(<span class="string">&quot;hello %s&quot;</span>, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    r<span class="selector-class">.Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表单参数"><a href="#表单参数" class="headerlink" title="表单参数"></a>表单参数</h2><p>表单传输为post请求，http常见的传输格式为四种：</p><ul><li>application/json</li><li>application/x-www-form-urlencoded</li><li>application/xml</li><li>multipart/form-data</li></ul><p>表单参数可以通过PostForm()方法获取，该方法默认解析的是x-www-form-urlencoded或from-data格式的参数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    r := gin.<span class="built_in">Default</span>()</span><br><span class="line">    r.<span class="built_in">POST</span>(<span class="string">&quot;/form&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        types := c.<span class="built_in">DefaultPostForm</span>(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;post&quot;</span>)</span><br><span class="line">        username := c.<span class="built_in">PostForm</span>(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">        password := c.<span class="built_in">PostForm</span>(<span class="string">&quot;userpassword&quot;</span>)</span><br><span class="line">        // c.<span class="built_in">String</span>(http.StatusOK, fmt.<span class="built_in">Sprintf</span>(<span class="string">&quot;username:%s,password:%s,type:%s&quot;</span>, username, password, types))</span><br><span class="line">        c.<span class="built_in">String</span>(http.StatusOK, fmt.<span class="built_in">Sprintf</span>(<span class="string">&quot;username:%s,password:%s,type:%s&quot;</span>, username, password, types))</span><br><span class="line">    &#125;)</span><br><span class="line">    r<span class="selector-class">.Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传单个文件"><a href="#上传单个文件" class="headerlink" title="上传单个文件"></a>上传单个文件</h2><p>multipart/form-data格式用于文件上传<br>gin文件上传与原生的net/http方法类似，不同在于gin把原生的request封装到c.Request中</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    <span class="attribute">r</span> := gin<span class="variable">.Default</span>()</span><br><span class="line">    //限制上传最大尺寸</span><br><span class="line">    r<span class="variable">.MaxMultipartMemory</span> = 8 &lt;&lt; 20</span><br><span class="line">    r<span class="variable">.POST</span>(&quot;/upload&quot;, func(c *gin<span class="variable">.Context</span>) &#123;</span><br><span class="line">        file, err := c<span class="variable">.FormFile</span>(&quot;file&quot;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            c<span class="variable">.String</span>(500, &quot;上传图片出错&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        // c<span class="variable">.JSON</span>(200, gin<span class="variable">.H</span>&#123;&quot;message&quot;: file<span class="variable">.Header</span><span class="variable">.Context</span>&#125;)</span><br><span class="line">        c<span class="variable">.SaveUploadedFile</span>(file, file<span class="variable">.Filename</span>)</span><br><span class="line">        c<span class="variable">.String</span>(http<span class="variable">.StatusOK</span>, file<span class="variable">.Filename</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    r<span class="variable">.Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上传特定文件"><a href="#上传特定文件" class="headerlink" title="上传特定文件"></a>上传特定文件</h3><p>有的用户上传文件需要限制上传文件的类型以及上传文件的大小，但是gin框架暂时没有这些函数(也有可能是我没找到)，因此基于原生的函数写法自己写了一个可以限制大小以及文件类型的上传函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    r := gin<span class="selector-class">.Default</span>()</span><br><span class="line">    r<span class="selector-class">.POST</span>(<span class="string">&quot;/upload&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        _, headers, err := c<span class="selector-class">.Request</span><span class="selector-class">.FormFile</span>(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            log<span class="selector-class">.Printf</span>(<span class="string">&quot;Error when try to get file: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//headers.Size 获取文件大小</span></span><br><span class="line">        <span class="keyword">if</span> headers<span class="selector-class">.Size</span> &gt; <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span> &#123;</span><br><span class="line">            fmt<span class="selector-class">.Println</span>(<span class="string">&quot;文件太大了&quot;</span>)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//headers.Header.Get(&quot;Content-Type&quot;)获取上传文件的类型</span></span><br><span class="line">        <span class="keyword">if</span> headers<span class="selector-class">.Header</span><span class="selector-class">.Get</span>(<span class="string">&quot;Content-Type&quot;</span>) != <span class="string">&quot;image/png&quot;</span> &#123;</span><br><span class="line">            fmt<span class="selector-class">.Println</span>(<span class="string">&quot;只允许上传png图片&quot;</span>)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        c<span class="selector-class">.SaveUploadedFile</span>(headers, <span class="string">&quot;./video/&quot;</span>+headers.Filename)</span><br><span class="line">        c<span class="selector-class">.String</span>(http<span class="selector-class">.StatusOK</span>, headers.Filename)</span><br><span class="line">    &#125;)</span><br><span class="line">    r<span class="selector-class">.Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   <span class="comment">// 1.创建路由</span></span><br><span class="line">   <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">   r := gin.Default()</span><br><span class="line">   <span class="comment">// 限制表单上传大小 8MB，默认为32MB</span></span><br><span class="line">   r.MaxMultipartMemory = 8 &lt;&lt; 20</span><br><span class="line">   r.<span class="keyword">POST</span>(<span class="string">&quot;/upload&quot;</span>, func(c *gin.Context) &#123;</span><br><span class="line">      <span class="keyword">form</span>, <span class="keyword">err</span> := c.MultipartForm()</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">         c.<span class="built_in">String</span>(http.StatusBadRequest, fmt.Sprintf(<span class="string">&quot;get err %s&quot;</span>, <span class="keyword">err</span>.<span class="keyword">Error</span>()))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取所有图片</span></span><br><span class="line">      files := <span class="keyword">form</span>.<span class="keyword">File</span>[<span class="string">&quot;files&quot;</span>]</span><br><span class="line">      <span class="comment">// 遍历所有图片</span></span><br><span class="line">      <span class="keyword">for</span> _, <span class="keyword">file</span> := <span class="keyword">range</span> files &#123;</span><br><span class="line">         <span class="comment">// 逐个存</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">err</span> := c.SaveUploadedFile(<span class="keyword">file</span>, <span class="keyword">file</span>.Filename); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">            c.<span class="built_in">String</span>(http.StatusBadRequest, fmt.Sprintf(<span class="string">&quot;upload err %s&quot;</span>, <span class="keyword">err</span>.<span class="keyword">Error</span>()))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      c.<span class="built_in">String</span>(200, fmt.Sprintf(<span class="string">&quot;upload ok %d files&quot;</span>, len(files)))</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="comment">//默认端口号是8080</span></span><br><span class="line">   r.<span class="keyword">Run</span>(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="routes-group"><a href="#routes-group" class="headerlink" title="routes group"></a>routes group</h2><p>routes group是为了管理一些相同的URL</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// gin的helloWorld</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">   <span class="comment">// 1.创建路由</span></span><br><span class="line">   <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">   r := gin<span class="selector-class">.Default</span>()</span><br><span class="line">   <span class="comment">// 路由组1 ，处理GET请求</span></span><br><span class="line">   v1 := r<span class="selector-class">.Group</span>(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">   <span class="comment">// &#123;&#125; 是书写规范</span></span><br><span class="line">   &#123;</span><br><span class="line">      v1<span class="selector-class">.GET</span>(<span class="string">&quot;/login&quot;</span>, login)</span><br><span class="line">      v1<span class="selector-class">.GET</span>(<span class="string">&quot;submit&quot;</span>, submit)</span><br><span class="line">   &#125;</span><br><span class="line">   v2 := r<span class="selector-class">.Group</span>(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      v2<span class="selector-class">.POST</span>(<span class="string">&quot;/login&quot;</span>, login)</span><br><span class="line">      v2<span class="selector-class">.POST</span>(<span class="string">&quot;/submit&quot;</span>, submit)</span><br><span class="line">   &#125;</span><br><span class="line">   r<span class="selector-class">.Run</span>(<span class="string">&quot;:8000&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">login</span>(c *gin.Context) &#123;</span><br><span class="line">   name := c<span class="selector-class">.DefaultQuery</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jack&quot;</span>)</span><br><span class="line">   c<span class="selector-class">.String</span>(<span class="number">200</span>, fmt<span class="selector-class">.Sprintf</span>(<span class="string">&quot;hello %s\n&quot;</span>, name))&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">submit</span>(c *gin.Context) &#123;</span><br><span class="line">   name := c<span class="selector-class">.DefaultQuery</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lily&quot;</span>)</span><br><span class="line">   c<span class="selector-class">.String</span>(<span class="number">200</span>, fmt<span class="selector-class">.Sprintf</span>(<span class="string">&quot;hello %s\n&quot;</span>, name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由拆分与注册"><a href="#路由拆分与注册" class="headerlink" title="路由拆分与注册"></a>路由拆分与注册</h2><h3 id="基本的路由注册"><a href="#基本的路由注册" class="headerlink" title="基本的路由注册"></a>基本的路由注册</h3><p>下面最基础的gin路由注册方式，适用于路由条目比较少的简单项目或者项目demo。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello www.topgoer.com!&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/topgoer&quot;</span>, helloHandler)</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由拆分成单独文件或包"><a href="#路由拆分成单独文件或包" class="headerlink" title="路由拆分成单独文件或包"></a>路由拆分成单独文件或包</h3><p>当项目的规模增大后就不太适合继续在项目的main.go文件中去实现路由注册相关逻辑了，我们会倾向于把路由部分的代码都拆分出来，形成一个单独的文件或包：<br>我们在routers.go文件中定义并注册路由信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello www.topgoer.com!&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupRouter</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/topgoer&quot;</span>, helloHandler)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时main.go中调用上面定义好的setupRouter函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := setupRouter()</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的目录结构：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">mod</span></span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">sum</span></span><br><span class="line">├── main.<span class="built_in">go</span></span><br><span class="line">└── routers.<span class="built_in">go</span></span><br></pre></td></tr></table></figure><p>把路由部分的代码单独拆分成包的话也是可以的，拆分后的目录结构如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">mod</span></span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">sum</span></span><br><span class="line">├── main.<span class="built_in">go</span></span><br><span class="line">└── routers</span><br><span class="line">    └── routers.<span class="built_in">go</span></span><br></pre></td></tr></table></figure><p>routers/routers.go需要注意此时setupRouter需要改成首字母大写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello www.topgoer.com&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupRouter 配置路由信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupRouter</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/topgoer&quot;</span>, helloHandler)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.go文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;gin_demo/routers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := routers.SetupRouter()</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由拆分成多个文件"><a href="#路由拆分成多个文件" class="headerlink" title="路由拆分成多个文件"></a>路由拆分成多个文件</h3><p>当我们的业务规模继续膨胀，单独的一个routers文件或包已经满足不了我们的需求了，</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func SetupRouter() *gin.Engine &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.<span class="built_in">GET</span>(<span class="string">&quot;/topgoer&quot;</span>, helloHandler)</span><br><span class="line">  r.<span class="built_in">GET</span>(<span class="string">&quot;/xx1&quot;</span>, xxHandler1)</span><br><span class="line">  <span class="built_in">..</span>.</span><br><span class="line">  r.<span class="built_in">GET</span>(<span class="string">&quot;/xx30&quot;</span>, xxHandler30)</span><br><span class="line">    return r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们把所有的路由注册都写在一个SetupRouter函数中的话就会太复杂了。我们可以分开定义多个路由文件，例如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">mod</span></span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">sum</span></span><br><span class="line">├── main.<span class="built_in">go</span></span><br><span class="line">└── routers</span><br><span class="line">    ├── blog.<span class="built_in">go</span></span><br><span class="line">    └── shop.<span class="built_in">go</span></span><br></pre></td></tr></table></figure><p>routers/shop.go中添加一个LoadShop的函数，将shop相关的路由注册到指定的路由器：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="constructor">LoadShop(<span class="params">e</span> <span class="operator">*</span><span class="params">gin</span>.Engine)</span>  &#123;</span><br><span class="line">    e.<span class="constructor">GET(<span class="string">&quot;/hello&quot;</span>, <span class="params">helloHandler</span>)</span></span><br><span class="line">  e.<span class="constructor">GET(<span class="string">&quot;/goods&quot;</span>, <span class="params">goodsHandler</span>)</span></span><br><span class="line">  e.<span class="constructor">GET(<span class="string">&quot;/checkout&quot;</span>, <span class="params">checkoutHandler</span>)</span><span class="operator"></span></span><br><span class="line"><span class="operator">  ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure><p>routers/blog.go中添加一个LoadBlog的函数，将blog相关的路由注册到指定的路由器：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="constructor">LoadBlog(<span class="params">e</span> <span class="operator">*</span><span class="params">gin</span>.Engine)</span> &#123;</span><br><span class="line">    e.<span class="constructor">GET(<span class="string">&quot;/post&quot;</span>, <span class="params">postHandler</span>)</span></span><br><span class="line">  e.<span class="constructor">GET(<span class="string">&quot;/comment&quot;</span>, <span class="params">commentHandler</span>)</span><span class="operator"></span></span><br><span class="line"><span class="operator">  ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure><p>在main函数中实现最终的注册逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    routers.LoadBlog(r)</span><br><span class="line">    routers.LoadShop(r)</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由拆分到不同的APP"><a href="#路由拆分到不同的APP" class="headerlink" title="路由拆分到不同的APP"></a>路由拆分到不同的APP</h3><p>有时候项目规模实在太大，那么我们就更倾向于把业务拆分的更详细一些，例如把不同的业务代码拆分成不同的APP。<br>因此我们在项目目录下单独定义一个app目录，用来存放我们不同业务线的代码文件，这样就很容易进行横向扩展。大致目录结构如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── app</span><br><span class="line">│   ├── blog</span><br><span class="line">│   │   ├── handler.<span class="built_in">go</span></span><br><span class="line">│   │   └── router.<span class="built_in">go</span></span><br><span class="line">│   └── shop</span><br><span class="line">│       ├── handler.<span class="built_in">go</span></span><br><span class="line">│       └── router.<span class="built_in">go</span></span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">mod</span></span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">sum</span></span><br><span class="line">├── main.<span class="built_in">go</span></span><br><span class="line">└── routers</span><br><span class="line">    └── routers.<span class="built_in">go</span></span><br></pre></td></tr></table></figure><p>其中app/blog/router.go用来定义post相关路由信息，具体内容如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func <span class="constructor">Routers(<span class="params">e</span> <span class="operator">*</span><span class="params">gin</span>.Engine)</span> &#123;</span><br><span class="line">    e.<span class="constructor">GET(<span class="string">&quot;/post&quot;</span>, <span class="params">postHandler</span>)</span></span><br><span class="line">    e.<span class="constructor">GET(<span class="string">&quot;/comment&quot;</span>, <span class="params">commentHandler</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app/shop/router.go用来定义shop相关路由信息，具体内容如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func <span class="constructor">Routers(<span class="params">e</span> <span class="operator">*</span><span class="params">gin</span>.Engine)</span> &#123;</span><br><span class="line">    e.<span class="constructor">GET(<span class="string">&quot;/goods&quot;</span>, <span class="params">goodsHandler</span>)</span></span><br><span class="line">    e.<span class="constructor">GET(<span class="string">&quot;/checkout&quot;</span>, <span class="params">checkoutHandler</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>routers/routers.go中根据需要定义Include函数用来注册子app中定义的路由，Init函数用来进行路由的初始化操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*gin.Engine)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = []Option&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册app的路由配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Include</span><span class="params">(opts ...Option)</span></span> &#123;</span><br><span class="line">    options = <span class="built_in">append</span>(options, opts...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">    r := gin.New()</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> options &#123;</span><br><span class="line">        opt(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.go中按如下方式先注册子app中的路由，然后再进行路由的初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加载多个APP的路由配置</span></span><br><span class="line">    routers.Include(shop.Routers, blog.Routers)</span><br><span class="line">    <span class="comment">// 初始化路由</span></span><br><span class="line">    r := routers.Init()</span><br><span class="line">    <span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gin数据解析与绑定"><a href="#gin数据解析与绑定" class="headerlink" title="gin数据解析与绑定"></a>gin数据解析与绑定</h1><h2 id="Json-数据解析和绑定"><a href="#Json-数据解析和绑定" class="headerlink" title="Json 数据解析和绑定"></a>Json 数据解析和绑定</h2><h3 id="客户端传参，后端接收并解析到结构体"><a href="#客户端传参，后端接收并解析到结构体" class="headerlink" title="客户端传参，后端接收并解析到结构体"></a>客户端传参，后端接收并解析到结构体</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">   &quot;net/http&quot;)</span><br><span class="line"></span><br><span class="line">// 定义接收数据的结构体</span><br><span class="line"><span class="keyword">type</span> <span class="keyword">Login</span> struct &#123;</span><br><span class="line">   // binding:&quot;required&quot;修饰的字段，若接收为空值，则报错，是必须字段</span><br><span class="line">   <span class="keyword">User</span>    string `form:&quot;username&quot; <span class="type">json</span>:&quot;user&quot; uri:&quot;user&quot; <span class="type">xml</span>:&quot;user&quot; binding:&quot;required&quot;`</span><br><span class="line">   Pssword string `form:&quot;password&quot; <span class="type">json</span>:&quot;password&quot; uri:&quot;password&quot; <span class="type">xml</span>:&quot;password&quot; binding:&quot;required&quot;`&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   // <span class="number">1.</span>创建路由</span><br><span class="line">   // 默认使用了<span class="number">2</span>个中间件Logger(), Recovery()</span><br><span class="line">   r := gin.<span class="keyword">Default</span>()</span><br><span class="line">   // <span class="type">JSON</span>绑定</span><br><span class="line">   r.POST(&quot;loginJSON&quot;, func(c *gin.Context) &#123;</span><br><span class="line">      // 声明接收的变量</span><br><span class="line">      var <span class="type">json</span> <span class="keyword">Login</span></span><br><span class="line">      // 将request的body中的数据，自动按照<span class="type">json</span>格式解析到结构体</span><br><span class="line">      <span class="keyword">if</span> err := c.ShouldBindJSON(&amp;<span class="type">json</span>); err != nil &#123;</span><br><span class="line">         // 返回错误信息</span><br><span class="line">         // gin.H封装了生成<span class="type">json</span>数据的工具</span><br><span class="line">         c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      // 判断用户名密码是否正确</span><br><span class="line">      <span class="keyword">if</span> <span class="type">json</span>.<span class="keyword">User</span> != &quot;root&quot; || <span class="type">json</span>.Pssword != &quot;admin&quot; &#123;</span><br><span class="line">         c.JSON(http.StatusBadRequest, gin.H&#123;&quot;status&quot;: &quot;304&quot;&#125;)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;200&quot;&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">   r.Run(&quot;:8000&quot;)&#125;</span><br></pre></td></tr></table></figure><h3 id="表单数据解析和绑定"><a href="#表单数据解析和绑定" class="headerlink" title="表单数据解析和绑定"></a>表单数据解析和绑定</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接收数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> Login struct &#123;</span><br><span class="line">    <span class="comment">// binding:&quot;required&quot;修饰的字段，若接收为空值，则报错，是必须字段</span></span><br><span class="line">    User    string `<span class="keyword">form</span>:<span class="string">&quot;username&quot;</span> json:<span class="string">&quot;user&quot;</span> uri:<span class="string">&quot;user&quot;</span> xml:<span class="string">&quot;user&quot;</span> binding:<span class="string">&quot;required&quot;</span>`</span><br><span class="line">    Pssword string `<span class="keyword">form</span>:<span class="string">&quot;password&quot;</span> json:<span class="string">&quot;password&quot;</span> uri:<span class="string">&quot;password&quot;</span> xml:<span class="string">&quot;password&quot;</span> binding:<span class="string">&quot;required&quot;</span>`&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line">    <span class="comment">// JSON绑定</span></span><br><span class="line">    r.<span class="keyword">POST</span>(<span class="string">&quot;/loginForm&quot;</span>, func(c *gin.Context) &#123;</span><br><span class="line">        <span class="comment">// 声明接收的变量</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">form</span> Login</span><br><span class="line">        <span class="comment">// Bind()默认解析并绑定form格式</span></span><br><span class="line">        <span class="comment">// 根据请求头中content-type自动推断</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">err</span> := c.Bind(&amp;<span class="keyword">form</span>); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.<span class="keyword">H</span>&#123;<span class="string">&quot;error&quot;</span>: <span class="keyword">err</span>.<span class="keyword">Error</span>()&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断用户名密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">form</span>.User != <span class="string">&quot;root&quot;</span> || <span class="keyword">form</span>.Pssword != <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.<span class="keyword">H</span>&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;304&quot;</span>&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.JSON(http.StatusOK, gin.<span class="keyword">H</span>&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;200&quot;</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.<span class="keyword">Run</span>(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="URI数据解析和绑定"><a href="#URI数据解析和绑定" class="headerlink" title="URI数据解析和绑定"></a>URI数据解析和绑定</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">    &quot;github.com/gin-gonic/gin&quot;)</span><br><span class="line"></span><br><span class="line">// 定义接收数据的结构体</span><br><span class="line"><span class="keyword">type</span> <span class="keyword">Login</span> struct &#123;</span><br><span class="line">    // binding:&quot;required&quot;修饰的字段，若接收为空值，则报错，是必须字段</span><br><span class="line">    <span class="keyword">User</span>    string `form:&quot;username&quot; <span class="type">json</span>:&quot;user&quot; uri:&quot;user&quot; <span class="type">xml</span>:&quot;user&quot; binding:&quot;required&quot;`</span><br><span class="line">    Pssword string `form:&quot;password&quot; <span class="type">json</span>:&quot;password&quot; uri:&quot;password&quot; <span class="type">xml</span>:&quot;password&quot; binding:&quot;required&quot;`&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // <span class="number">1.</span>创建路由</span><br><span class="line">    // 默认使用了<span class="number">2</span>个中间件Logger(), Recovery()</span><br><span class="line">    r := gin.<span class="keyword">Default</span>()</span><br><span class="line">    // <span class="type">JSON</span>绑定</span><br><span class="line">    r.<span class="keyword">GET</span>(&quot;/:user/:password&quot;, func(c *gin.Context) &#123;</span><br><span class="line">        // 声明接收的变量</span><br><span class="line">        var <span class="keyword">login</span> <span class="keyword">Login</span></span><br><span class="line">        // Bind()默认解析并绑定form格式</span><br><span class="line">        // 根据请求头中content-<span class="keyword">type</span>自动推断</span><br><span class="line">        <span class="keyword">if</span> err := c.ShouldBindUri(&amp;<span class="keyword">login</span>); err != nil &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        // 判断用户名密码是否正确</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">login</span>.<span class="keyword">User</span> != &quot;root&quot; || <span class="keyword">login</span>.Pssword != &quot;admin&quot; &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;&quot;status&quot;: &quot;304&quot;&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;200&quot;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run(&quot;:8000&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gin-渲染"><a href="#gin-渲染" class="headerlink" title="gin 渲染"></a>gin 渲染</h1><h2 id="各种数据格式的响应"><a href="#各种数据格式的响应" class="headerlink" title="各种数据格式的响应"></a>各种数据格式的响应</h2><p>json、结构体、XML、YAML类似于java的properties、ProtoBuf</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin/testdata/protoexample&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多种响应方式func main() &#123;</span></span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin<span class="selector-class">.Default</span>()</span><br><span class="line">    <span class="comment">// 1.json</span></span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/someJSON&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        c<span class="selector-class">.JSON</span>(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;someJSON&quot;</span>, <span class="string">&quot;status&quot;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 2. 结构体响应</span></span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/someStruct&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        <span class="selector-tag">var</span> msg struct &#123;</span><br><span class="line">            Name    string</span><br><span class="line">            Message string</span><br><span class="line">            Number  int</span><br><span class="line">        &#125;</span><br><span class="line">        msg<span class="selector-class">.Name</span> = <span class="string">&quot;root&quot;</span></span><br><span class="line">        msg<span class="selector-class">.Message</span> = <span class="string">&quot;message&quot;</span></span><br><span class="line">        msg<span class="selector-class">.Number</span> = <span class="number">123</span></span><br><span class="line">        c<span class="selector-class">.JSON</span>(<span class="number">200</span>, msg)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 3.XML</span></span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/someXML&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        c<span class="selector-class">.XML</span>(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;abc&quot;</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 4.YAML响应</span></span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/someYAML&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        c<span class="selector-class">.YAML</span>(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhangsan&quot;</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 5.protobuf格式,谷歌开发的高效存储读取的工具</span></span><br><span class="line">    <span class="comment">// 数组？切片？如果自己构建一个传输格式，应该是什么格式？</span></span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/someProtoBuf&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        reps := <span class="selector-attr">[]</span>int64&#123;<span class="built_in">int64</span>(<span class="number">1</span>), <span class="built_in">int64</span>(<span class="number">2</span>)&#125;</span><br><span class="line">        <span class="comment">// 定义数据</span></span><br><span class="line">        <span class="selector-tag">label</span> := <span class="string">&quot;label&quot;</span></span><br><span class="line">        <span class="comment">// 传protobuf格式数据</span></span><br><span class="line">        data := &amp;protoexample.Test&#123;</span><br><span class="line">            Label: &amp;<span class="selector-tag">label</span>,</span><br><span class="line">            Reps:  reps,</span><br><span class="line">        &#125;</span><br><span class="line">        c<span class="selector-class">.ProtoBuf</span>(<span class="number">200</span>, data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r<span class="selector-class">.Run</span>(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTML模板渲染"><a href="#HTML模板渲染" class="headerlink" title="HTML模板渲染"></a>HTML模板渲染</h2><ul><li>gin支持加载HTML模板, 然后根据模板参数进行配置并返回相应的数据，本质上就是字符串替换</li><li>LoadHTMLGlob()方法可以加载模板文件</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    r := gin<span class="selector-class">.Default</span>()</span><br><span class="line">    r<span class="selector-class">.LoadHTMLGlob</span>(<span class="string">&quot;tem/*&quot;</span>)</span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        c<span class="selector-class">.HTML</span>(http<span class="selector-class">.StatusOK</span>, <span class="string">&quot;index.html&quot;</span>, gin.H&#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;我是测试&quot;</span>, <span class="string">&quot;ce&quot;</span>: <span class="string">&quot;123456&quot;</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r<span class="selector-class">.Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要引入静态文件需要定义一个静态文件目录</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="keyword">Static</span>(<span class="string">&quot;/assets&quot;</span>, <span class="string">&quot;./assets&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    r := gin<span class="selector-class">.Default</span>()</span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/index&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        c<span class="selector-class">.Redirect</span>(http<span class="selector-class">.StatusMovedPermanently</span>, <span class="string">&quot;http://www.5lmh.com&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    r<span class="selector-class">.Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h2><ul><li>goroutine机制可以方便地实现异步处理</li><li>另外，在启动新的goroutine时，不应该使用原始上下文，必须使用它的只读副本</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line">    <span class="comment">// 1.异步</span></span><br><span class="line">    r.GET(<span class="string">&quot;/long_async&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 需要搞一个副本</span></span><br><span class="line">        copyContext := c.Copy()</span><br><span class="line">        <span class="comment">// 异步处理</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">            log.Println(<span class="string">&quot;异步执行：&quot;</span> + copyContext.Request.URL.Path)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 2.同步</span></span><br><span class="line">    r.GET(<span class="string">&quot;/long_sync&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">        log.Println(<span class="string">&quot;同步执行：&quot;</span> + c.Request.URL.Path)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gin-中间件"><a href="#gin-中间件" class="headerlink" title="gin 中间件"></a>gin 中间件</h1><h2 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h2><p>所有请求都经过此中间件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中间</span></span><br><span class="line">func <span class="built_in">MiddleWare</span>() gin<span class="selector-class">.HandlerFunc</span> &#123;</span><br><span class="line">    return <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        t := <span class="selector-tag">time</span><span class="selector-class">.Now</span>()</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;中间件开始执行了&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置变量到Context的key中，可以通过Get()取</span></span><br><span class="line">        c<span class="selector-class">.Set</span>(<span class="string">&quot;request&quot;</span>, <span class="string">&quot;中间件&quot;</span>)</span><br><span class="line">        status := c<span class="selector-class">.Writer</span><span class="selector-class">.Status</span>()</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;中间件执行完毕&quot;</span>, status)</span><br><span class="line">        t2 := <span class="selector-tag">time</span><span class="selector-class">.Since</span>(t)</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;time:&quot;</span>, t2)</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin<span class="selector-class">.Default</span>()</span><br><span class="line">    <span class="comment">// 注册中间件</span></span><br><span class="line">    r<span class="selector-class">.Use</span>(<span class="built_in">MiddleWare</span>())</span><br><span class="line">    <span class="comment">// &#123;&#125;为了代码规范</span></span><br><span class="line">    &#123;</span><br><span class="line">        r<span class="selector-class">.GET</span>(<span class="string">&quot;/ce&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">            <span class="comment">// 取值</span></span><br><span class="line">            req, _ := c<span class="selector-class">.Get</span>(<span class="string">&quot;request&quot;</span>)</span><br><span class="line">            fmt<span class="selector-class">.Println</span>(<span class="string">&quot;request:&quot;</span>, req)</span><br><span class="line">            <span class="comment">// 页面接收</span></span><br><span class="line">            c<span class="selector-class">.JSON</span>(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;request&quot;</span>: req&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    r<span class="selector-class">.Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Next-方法"><a href="#Next-方法" class="headerlink" title="Next()方法"></a>Next()方法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;       </span><br><span class="line">    r := gin<span class="selector-class">.Default</span>()       </span><br><span class="line">    m1 := <span class="built_in">func</span>(c *gin.Context) &#123;              </span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;m1 start&quot;</span>)              </span><br><span class="line">        <span class="comment">//c.Next()会跳过当前中间件后续的逻辑，类似defer，最后再执行c.Next后面的逻辑             </span></span><br><span class="line">        <span class="comment">//多个c.Next()谁在前面谁后执行，跟defer很像，类似先进后出的栈              </span></span><br><span class="line">        c<span class="selector-class">.Next</span>()              </span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;m1 end&quot;</span>)      </span><br><span class="line">    &#125;       </span><br><span class="line">    m2 := <span class="built_in">func</span>(c *gin.Context) &#123;              </span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;m2 start&quot;</span>)              </span><br><span class="line">        <span class="comment">//该方法会阻止业务逻辑以及该中间件后面中间件执行，但是不会阻止该中间件后面的逻辑执行包括c.Next()             </span></span><br><span class="line">        <span class="comment">//c.Abort()              </span></span><br><span class="line">        c<span class="selector-class">.Next</span>()              </span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;m2 end&quot;</span>)      </span><br><span class="line">    &#125;       </span><br><span class="line">    m3 := <span class="built_in">func</span>(c *gin.Context) &#123;              </span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;m3 start&quot;</span>)              </span><br><span class="line">        c<span class="selector-class">.Next</span>()              </span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;m3 end&quot;</span>)       </span><br><span class="line">    &#125;       </span><br><span class="line">    r<span class="selector-class">.Use</span>(m1, m2, m3)       </span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/&quot;</span>, <span class="built_in">func</span>(context *gin<span class="selector-class">.Context</span> &#123;              </span><br><span class="line">        context<span class="selector-class">.Next</span>()              </span><br><span class="line">        context<span class="selector-class">.JSON</span>(http<span class="selector-class">.StatusOK</span>, gin.H&#123;                      </span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;demo&quot;</span>,              </span><br><span class="line">        &#125;)              </span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;hello world!!&quot;</span>)       </span><br><span class="line">    &#125;)       </span><br><span class="line">    r<span class="selector-class">.Run</span>(<span class="string">&quot;:8081&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[GIN-<span class="keyword">debug</span>] Listening <span class="keyword">and</span> serving HTTP <span class="keyword">on</span> :<span class="number">8081</span> </span><br><span class="line">m1 <span class="keyword">start</span> </span><br><span class="line">m2 <span class="keyword">start</span> </span><br><span class="line">m3 <span class="keyword">start</span> </span><br><span class="line">hello world!! </span><br><span class="line">m3 <span class="keyword">end</span> </span><br><span class="line">m2 <span class="keyword">end</span> </span><br><span class="line">m1 <span class="keyword">end</span> </span><br><span class="line">[GIN] <span class="number">2021</span>/<span class="number">03</span>/<span class="number">26</span> - <span class="number">12</span>:<span class="number">40</span>:<span class="number">40</span> |?[<span class="number">97</span>;<span class="number">42</span>m <span class="number">200</span> ?[<span class="number">0</span>m| <span class="number">1.5781</span>ms | <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> |?[<span class="number">97</span>;<span class="number">44</span>m <span class="keyword">GET</span> ?[<span class="number">0</span>m &quot;/&quot;</span><br></pre></td></tr></table></figure><h2 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中间</span></span><br><span class="line">func <span class="built_in">MiddleWare</span>() gin<span class="selector-class">.HandlerFunc</span> &#123;</span><br><span class="line">    return <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        t := <span class="selector-tag">time</span><span class="selector-class">.Now</span>()</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;中间件开始执行了&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置变量到Context的key中，可以通过Get()取</span></span><br><span class="line">        c<span class="selector-class">.Set</span>(<span class="string">&quot;request&quot;</span>, <span class="string">&quot;中间件&quot;</span>)</span><br><span class="line">        <span class="comment">// 执行函数</span></span><br><span class="line">        c<span class="selector-class">.Next</span>()</span><br><span class="line">        <span class="comment">// 中间件执行完后续的一些事情</span></span><br><span class="line">        status := c<span class="selector-class">.Writer</span><span class="selector-class">.Status</span>()</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;中间件执行完毕&quot;</span>, status)</span><br><span class="line">        t2 := <span class="selector-tag">time</span><span class="selector-class">.Since</span>(t)</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;time:&quot;</span>, t2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin<span class="selector-class">.Default</span>()</span><br><span class="line">    <span class="comment">//局部中间键使用</span></span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/ce&quot;</span>, <span class="built_in">MiddleWare</span>(), <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        <span class="comment">// 取值</span></span><br><span class="line">        req, _ := c<span class="selector-class">.Get</span>(<span class="string">&quot;request&quot;</span>)</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;request:&quot;</span>, req)</span><br><span class="line">        <span class="comment">// 页面接收</span></span><br><span class="line">        c<span class="selector-class">.JSON</span>(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;request&quot;</span>: req&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r<span class="selector-class">.Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间件推荐"><a href="#中间件推荐" class="headerlink" title="中间件推荐"></a>中间件推荐</h2><ol><li>RestGate - REST API端点的安全身份验证</li><li>staticbin - 用于从二进制数据提供静态文件的中间件/处理程序</li><li>gin-cors - CORS杜松子酒的官方中间件</li><li>gin-csrf - CSRF保护</li><li>gin-health - 通过gocraft/health报告的中间件</li><li>gin-merry - 带有上下文的漂亮 打印 错误的中间件</li><li>gin-revision - 用于Gin框架的修订中间件</li><li>gin-jwt - 用于Gin框架的JWT中间件</li><li>gin-sessions - 基于mongodb和mysql的会话中间件</li><li>gin-location - 用于公开服务器的主机名和方案的中间件</li><li>gin-nice-recovery - 紧急恢复中间件，可让您构建更好的用户体验</li><li>gin-limit - 限制同时请求；可以帮助增加交通流量</li><li>gin-limit-by-key - 一种内存中的中间件，用于通过自定义键和速率限制访问速率。</li><li>ez-gin-template - gin简单模板包装</li><li>gin-hydra - gin中间件Hydra</li><li>gin-glog - 旨在替代Gin的默认日志</li><li>gin-gomonitor - 用于通过Go-Monitor公开指标</li><li>gin-oauth2 - 用于OAuth2</li><li>static gin框架的替代静态资产处理程序。</li><li>xss-mw - XssMw是一种中间件，旨在从用户提交的输入中“自动删除XSS”</li><li>gin-helmet - 简单的安全中间件集合。</li><li>gin-jwt-session - 提供JWT / Session / Flash的中间件，易于使用，同时还提供必要的调整选项。也提供样品。</li><li>gin-template - 用于gin框架的html / template易于使用。</li><li>gin-redis-ip-limiter - 基于IP地址的请求限制器。它可以与redis和滑动窗口机制一起使用。</li><li>gin-method-override - method受Ruby的同名机架启发而被POST形式参数覆盖的方法</li><li>gin-access-limit - limit-通过指定允许的源CIDR表示法的访问控制中间件。</li><li>gin-session - 用于Gin的Session中间件</li><li>gin-stats - 轻量级和有用的请求指标中间件</li><li>gin-statsd - 向statsd守护进程报告的Gin中间件</li><li>gin-health-check - check-用于Gin的健康检查中间件</li><li>gin-session-middleware - 一个有效，安全且易于使用的Go Session库。</li><li>ginception - 漂亮的例外页面</li><li>gin-inspector - 用于调查http请求的Gin中间件。</li><li>gin-dump - Gin中间件/处理程序，用于转储请求和响应的标头/正文。对调试应用程序非常有帮助。</li><li>go-gin-prometheus - Gin Prometheus metrics exporter</li><li>ginprom - Gin的Prometheus指标导出器</li><li>gin-go-metrics - Gin middleware to gather and store metrics using rcrowley/go-metrics</li><li>ginrpc - Gin 中间件/处理器自动绑定工具。通过像beego这样的注释路线来支持对象注册</li></ol><h1 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h1><h2 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h2><p>测试服务端发送cookie给客户端，客户端请求时携带cookie</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">   <span class="regexp">//</span> <span class="number">1</span>.创建路由</span><br><span class="line">   <span class="regexp">//</span> 默认使用了<span class="number">2</span>个中间件Logger(), Recovery()</span><br><span class="line">   r := gin.Default()</span><br><span class="line">   <span class="regexp">//</span> 服务端要给客户端cookie</span><br><span class="line">   r.GET(<span class="string">&quot;cookie&quot;</span>, <span class="keyword">func</span>(c *gin.Context) &#123;</span><br><span class="line">      <span class="regexp">//</span> 获取客户端是否携带cookie</span><br><span class="line">      cookie, err := c.Cookie(<span class="string">&quot;key_cookie&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">         cookie = <span class="string">&quot;NotSet&quot;</span></span><br><span class="line">         <span class="regexp">//</span> 给客户端设置cookie</span><br><span class="line">         <span class="regexp">//</span>  maxAge int, 单位为秒</span><br><span class="line">         <span class="regexp">//</span> path,cookie所在目录</span><br><span class="line">         <span class="regexp">//</span> domain string,域名</span><br><span class="line">         <span class="regexp">//</span>   secure 是否智能通过https访问</span><br><span class="line">         <span class="regexp">//</span> httpOnly bool  是否允许别人通过js获取自己的cookie</span><br><span class="line">         c.SetCookie(<span class="string">&quot;key_cookie&quot;</span>, <span class="string">&quot;value_cookie&quot;</span>, <span class="number">60</span>, <span class="string">&quot;/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;localhost&quot;</span>, false, true)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;cookie的值是： %s\n&quot;</span>, cookie)</span><br><span class="line">   &#125;)</span><br><span class="line">   r.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h2><p>gorilla/sessions为自定义session后端提供cookie和文件系统session以及基础结构。<br>主要功能是：</p><ul><li>简单的API：将其用作设置签名（以及可选的加密）cookie的简便方法。</li><li>内置的后端可将session存储在cookie或文件系统中。</li><li>Flash消息：一直持续读取的session值。</li><li>切换session持久性（又称“记住我”）和设置其他属性的便捷方法。</li><li>旋转身份验证和加密密钥的机制。</li><li>每个请求有多个session，即使使用不同的后端也是如此。</li><li>自定义session后端的接口和基础结构：可以使用通用API检索并批量保存来自不同商店的session。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gorilla/sessions&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个cookie存储对象// something-very-secret应该是一个你自己的密匙，只要不被别人知道就行var store = sessions.NewCookieStore([]byte(&quot;something-very-secret&quot;))</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    http<span class="selector-class">.HandleFunc</span>(<span class="string">&quot;/save&quot;</span>, SaveSession)</span><br><span class="line">    http<span class="selector-class">.HandleFunc</span>(<span class="string">&quot;/get&quot;</span>, GetSession)</span><br><span class="line">    err := http<span class="selector-class">.ListenAndServe</span>(<span class="string">&quot;:8080&quot;</span>, nil)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;HTTP server failed,err:&quot;</span>, err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">SaveSession</span>(w http<span class="selector-class">.ResponseWriter</span>, r *http.Request) &#123;</span><br><span class="line">    <span class="comment">// Get a session. We&#x27;re ignoring the error resulted from decoding an</span></span><br><span class="line">    <span class="comment">// existing session: Get() always returns a session, even if empty.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//　获取一个session对象，session-name是session的名字</span></span><br><span class="line">    session, err := store<span class="selector-class">.Get</span>(r, <span class="string">&quot;session-name&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        http<span class="selector-class">.Error</span>(w, err<span class="selector-class">.Error</span>(), http.StatusInternalServerError)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在session中存储值</span></span><br><span class="line">    session<span class="selector-class">.Values</span><span class="selector-attr">[<span class="string">&quot;foo&quot;</span>]</span> = <span class="string">&quot;bar&quot;</span></span><br><span class="line">    session<span class="selector-class">.Values</span><span class="selector-attr">[42]</span> = <span class="number">43</span></span><br><span class="line">    <span class="comment">// 保存更改</span></span><br><span class="line">    session<span class="selector-class">.Save</span>(r, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">GetSession</span>(w http<span class="selector-class">.ResponseWriter</span>, r *http.Request) &#123;</span><br><span class="line">    session, err := store<span class="selector-class">.Get</span>(r, <span class="string">&quot;session-name&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        http<span class="selector-class">.Error</span>(w, err<span class="selector-class">.Error</span>(), http.StatusInternalServerError)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    foo := session<span class="selector-class">.Values</span><span class="selector-attr">[<span class="string">&quot;foo&quot;</span>]</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除session的值：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">// 将session的最大存储时间设置为小于零的数即为删除</span></span><br><span class="line">session.Options.MaxAge = -<span class="number">1</span></span><br><span class="line">session.<span class="constructor">Save(<span class="params">r</span>, <span class="params">w</span>)</span></span><br></pre></td></tr></table></figure><h1 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h1><h2 id="结构体验证"><a href="#结构体验证" class="headerlink" title="结构体验证"></a>结构体验证</h2><p>用gin框架的数据验证，可以不用解析数据，减少if else，会简洁许多。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person </span></span><br><span class="line"><span class="keyword">type</span> Person struct &#123;</span><br><span class="line">    <span class="comment">//不能为空并且大于10</span></span><br><span class="line">    Age      int       `<span class="keyword">form</span>:<span class="string">&quot;age&quot;</span> binding:<span class="string">&quot;required,gt=10&quot;</span>`</span><br><span class="line">    Name     string    `<span class="keyword">form</span>:<span class="string">&quot;name&quot;</span> binding:<span class="string">&quot;required&quot;</span>`</span><br><span class="line">    Birthday time.Time `<span class="keyword">form</span>:<span class="string">&quot;birthday&quot;</span> time_format:<span class="string">&quot;2006-01-02&quot;</span> time_utc:<span class="string">&quot;1&quot;</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.<span class="built_in">GET</span>(<span class="string">&quot;/5lmh&quot;</span>, func(c *gin.Context) &#123;</span><br><span class="line">        <span class="keyword">var</span> person Person</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">err</span> := c.ShouldBind(&amp;person); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">            c.<span class="built_in">String</span>(500, fmt.Sprint(<span class="keyword">err</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="built_in">String</span>(200, fmt.Sprintf(<span class="string">&quot;%#v&quot;</span>, person))</span><br><span class="line">    &#125;)</span><br><span class="line">    r.<span class="keyword">Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin/binding&quot;</span></span><br><span class="line">    <span class="string">&quot;gopkg.in/go-playground/validator.v8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    对绑定解析到结构体上的参数，自定义验证功能</span></span><br><span class="line"><span class="comment">    比如我们要对 name 字段做校验，要不能为空，并且不等于 admin ，类似这种需求，就无法 binding 现成的方法</span></span><br><span class="line"><span class="comment">    需要我们自己验证方法才能实现 官网示例（https://godoc.org/gopkg.in/go-playground/validator.v8#hdr-Custom_Functions）</span></span><br><span class="line"><span class="comment">    这里需要下载引入下 gopkg.in/go-playground/validator.v8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Age <span class="type">int</span> <span class="string">`form:&quot;age&quot; binding:&quot;required,gt=10&quot;`</span></span><br><span class="line">    <span class="comment">// 2、在参数 binding 上使用自定义的校验方法函数注册时候的名称</span></span><br><span class="line">    Name    <span class="type">string</span> <span class="string">`form:&quot;name&quot; binding:&quot;NotNullAndAdmin&quot;`</span></span><br><span class="line">    Address <span class="type">string</span> <span class="string">`form:&quot;address&quot; binding:&quot;required&quot;`</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自定义的校验方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nameNotNullAndAdmin</span><span class="params">(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> value, ok := field.Interface().(<span class="type">string</span>); ok &#123;</span><br><span class="line">        <span class="comment">// 字段不能为空，并且不等于  admin</span></span><br><span class="line">        <span class="keyword">return</span> value != <span class="string">&quot;&quot;</span> &amp;&amp; !(<span class="string">&quot;5lmh&quot;</span> == value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将我们自定义的校验方法注册到 validator中</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">        <span class="comment">// 这里的 key 和 fn 可以不一样最终在 struct 使用的是 key</span></span><br><span class="line">        v.RegisterValidation(<span class="string">&quot;NotNullAndAdmin&quot;</span>, nameNotNullAndAdmin)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        curl -X GET &quot;http://127.0.0.1:8080/testing?name=&amp;age=12&amp;address=beijing&quot;</span></span><br><span class="line"><span class="comment">        curl -X GET &quot;http://127.0.0.1:8080/testing?name=lmh&amp;age=12&amp;address=beijing&quot;</span></span><br><span class="line"><span class="comment">        curl -X GET &quot;http://127.0.0.1:8080/testing?name=adz&amp;age=12&amp;address=beijing&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    r.GET(<span class="string">&quot;/5lmh&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> person Person</span><br><span class="line">        <span class="keyword">if</span> e := c.ShouldBind(&amp;person); e == <span class="literal">nil</span> &#123;</span><br><span class="line">            c.String(http.StatusOK, <span class="string">&quot;%v&quot;</span>, person)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.String(http.StatusOK, <span class="string">&quot;person bind err:%v&quot;</span>, e.Error())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin/binding&quot;</span></span><br><span class="line">    <span class="string">&quot;gopkg.in/go-playground/validator.v8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Booking contains binded and validated data.</span></span><br><span class="line"><span class="keyword">type</span> Booking <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个预约的时间大于今天的时间</span></span><br><span class="line">    CheckIn time.Time <span class="string">`form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;`</span></span><br><span class="line">    <span class="comment">//gtfield=CheckIn退出的时间大于预约的时间</span></span><br><span class="line">    CheckOut time.Time <span class="string">`form:&quot;check_out&quot; binding:&quot;required,gtfield=CheckIn&quot; time_format:&quot;2006-01-02&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bookableDate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value,</span></span></span><br><span class="line"><span class="params"><span class="function">    field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param <span class="type">string</span>,)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">//field.Interface().(time.Time)获取参数值并且转换为时间格式</span></span><br><span class="line">    <span class="keyword">if</span> date, ok := field.Interface().(time.Time); ok &#123;</span><br><span class="line">        today := time.Now()</span><br><span class="line">        <span class="keyword">if</span> today.Unix() &gt; date.Unix() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    route := gin.Default()</span><br><span class="line">    <span class="comment">//注册验证</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">        <span class="comment">//绑定第一个参数是验证的函数第二个参数是自定义的验证函数</span></span><br><span class="line">        v.RegisterValidation(<span class="string">&quot;bookabledate&quot;</span>, bookableDate)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    route.GET(<span class="string">&quot;/5lmh&quot;</span>, getBookable)</span><br><span class="line">    route.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBookable</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b Booking</span><br><span class="line">    <span class="keyword">if</span> err := c.ShouldBindWith(&amp;b, binding.Query); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Booking dates are valid!&quot;</span>&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span>)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    gin<span class="selector-class">.DisableConsoleColor</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Logging to a file.</span></span><br><span class="line">    f, _ := os<span class="selector-class">.Create</span>(<span class="string">&quot;gin.log&quot;</span>)</span><br><span class="line">    gin<span class="selector-class">.DefaultWriter</span> = io<span class="selector-class">.MultiWriter</span>(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要同时将日志写入文件和控制台，请使用以下代码。</span></span><br><span class="line">    <span class="comment">// gin.DefaultWriter = io.MultiWriter(f, os.Stdout)</span></span><br><span class="line">    r := gin<span class="selector-class">.Default</span>()</span><br><span class="line">    r<span class="selector-class">.GET</span>(<span class="string">&quot;/ping&quot;</span>, <span class="built_in">func</span>(c *gin.Context) &#123;</span><br><span class="line">        c<span class="selector-class">.String</span>(<span class="number">200</span>, <span class="string">&quot;pong&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    r<span class="selector-class">.Run</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Air实时加载"><a href="#Air实时加载" class="headerlink" title="Air实时加载"></a>Air实时加载</h2><p>Air能够实时监听项目的代码文件，在代码发生变更之后自动重新编译并执行，大大提高gin框架项目的开发效率。</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>Casbin是用于Golang项目的功能强大且高效的开源访问控制库。<br>Casbin的作用：</p><ul><li>以经典{subject, object, action}形式或您定义的自定义形式实施策略，同时支持允许和拒绝授权。</li><li>处理访问控制模型及其策略的存储。</li><li>管理角色用户映射和角色角色映射（RBAC中的角色层次结构）。</li><li>支持内置的超级用户，例如root或administrator。超级用户可以在没有显式权限的情况下执行任何操作。</li><li>多个内置运算符支持规则匹配。例如，keyMatch可以将资源键映射/foo/bar到模式/foo* 。</li></ul><p>Casbin不执行的操作：</p><ul><li>身份验证（又名验证username以及password用户登录时）</li><li>管理用户或角色列表。我相信项目本身管理这些实体会更方便。用户通常具有其密码，而Casbin并非设计为密码容器。但是，Casbin存储RBAC方案的用户角色映射。</li></ul><p>在Casbin中，基于PERM元模型（策略，效果，请求，匹配器）将访问控制模型抽象为CONF文件。因此，切换或升级项目的授权机制就像修改配置一样简单。您可以通过组合可用的模型来定制自己的访问控制模型。例如，您可以在一个模型中同时获得RBAC角色和ABAC属性，并共享一组策略规则。Casbin中最基本，最简单的模型是ACL。ACL的CONF模型为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">＃请求定义</span><br><span class="line"><span class="selector-attr">[request_definition]</span></span><br><span class="line">r = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[policy_definition]</span></span><br><span class="line"><span class="selector-tag">p</span> = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[role_definition]</span></span><br><span class="line">g = _, _</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[policy_effect]</span></span><br><span class="line">e = <span class="built_in">some</span>(where (<span class="selector-tag">p</span><span class="selector-class">.eft</span> == allow))</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[matchers]</span></span><br><span class="line">m = <span class="built_in">g</span>(r<span class="selector-class">.sub</span>, <span class="selector-tag">p</span>.sub) &amp;&amp; r<span class="selector-class">.obj</span> == <span class="selector-tag">p</span><span class="selector-class">.obj</span> &amp;&amp; r<span class="selector-class">.act</span> == <span class="selector-tag">p</span>.act</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/casbin/casbin</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/casbin/casbin&quot;</span></span><br><span class="line">    xormadapter <span class="string">&quot;github.com/casbin/xorm-adapter&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 要使用自己定义的数据库rbac_db,最后的true很重要.默认为false,使用缺省的数据库名casbin,不存在则创建</span></span><br><span class="line">    a, err := xormadapter.NewAdapter(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:root@tcp(127.0.0.1:3306)/goblog?charset=utf8&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;连接数据库错误: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    e, err := casbin.NewEnforcer(<span class="string">&quot;./rbac_models.conf&quot;</span>, a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;初始化casbin错误: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从DB加载策略</span></span><br><span class="line">    e.LoadPolicy()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取router路由对象</span></span><br><span class="line">    r := gin.New()</span><br><span class="line"></span><br><span class="line">    r.POST(<span class="string">&quot;/api/v1/add&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;增加Policy&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ok, _ := e.AddPolicy(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;/api/v1/hello&quot;</span>, <span class="string">&quot;GET&quot;</span>); !ok &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Policy已经存在&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;增加成功&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//删除policy</span></span><br><span class="line">    r.DELETE(<span class="string">&quot;/api/v1/delete&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;删除Policy&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ok, _ := e.RemovePolicy(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;/api/v1/hello&quot;</span>, <span class="string">&quot;GET&quot;</span>); !ok &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Policy不存在&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;删除成功&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//获取policy</span></span><br><span class="line">    r.GET(<span class="string">&quot;/api/v1/get&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;查看policy&quot;</span>)</span><br><span class="line">        list := e.GetPolicy()</span><br><span class="line">        <span class="keyword">for</span> _, vlist := <span class="keyword">range</span> list &#123;</span><br><span class="line">            <span class="keyword">for</span> _, v := <span class="keyword">range</span> vlist &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;value: %s, &quot;</span>, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//使用自定义拦截器中间件</span></span><br><span class="line">    r.Use(Authorize(e))</span><br><span class="line">    <span class="comment">//创建请求</span></span><br><span class="line">    r.GET(<span class="string">&quot;/api/v1/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello 接收到GET请求..&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:9000&quot;</span>) <span class="comment">//参数为空 默认监听8080端口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Authorize</span><span class="params">(e *casbin.Enforcer)</span></span> gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求的URI</span></span><br><span class="line">        obj := c.Request.URL.RequestURI()</span><br><span class="line">        <span class="comment">//获取请求方法</span></span><br><span class="line">        act := c.Request.Method</span><br><span class="line">        <span class="comment">//获取用户的角色</span></span><br><span class="line">        sub := <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断策略中是否存在</span></span><br><span class="line">        <span class="keyword">if</span> ok, _ := e.Enforce(sub, obj, act); ok &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;恭喜您,权限验证通过&quot;</span>)</span><br><span class="line">            c.Next()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;很遗憾,权限验证没有通过&quot;</span>)</span><br><span class="line">            c.Abort()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rbac_models.conf里面的内容如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[request_definition]</span></span><br><span class="line">r = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[policy_definition]</span></span><br><span class="line"><span class="selector-tag">p</span> = sub, obj, act</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[role_definition]</span></span><br><span class="line">g = _, _</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[policy_effect]</span></span><br><span class="line">e = <span class="built_in">some</span>(where (<span class="selector-tag">p</span><span class="selector-class">.eft</span> == allow))</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[matchers]</span></span><br><span class="line">m = <span class="built_in">g</span>(r<span class="selector-class">.sub</span>, <span class="selector-tag">p</span>.sub) &amp;&amp; r<span class="selector-class">.obj</span> == <span class="selector-tag">p</span><span class="selector-class">.obj</span> &amp;&amp; r<span class="selector-class">.act</span> == <span class="selector-tag">p</span>.act</span><br></pre></td></tr></table></figure><p>配置链接数据库不需要手动创建数据库，系统自动创建casbin_rule表</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>基本流程：</p><ol><li>build出一个可执行文件<br><code>go build main.go</code>，则生成了一个新文件main，并赋予可执行权限即可</li><li>写一个sh文件，用来执行这个文件<br>vim run.sh<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># 设置为 release 生产模式 </span></span><br><span class="line"><span class="built_in">export</span> GIN_MODE=release </span><br><span class="line"><span class="comment"># 切换到路径下，这样才能够使用和开发时候一样的相对路径 </span></span><br><span class="line"><span class="built_in">cd</span> main文件所在的绝对路径 </span><br><span class="line"><span class="comment"># 启动 build 后的可执行文件 </span></span><br><span class="line">./main</span><br></pre></td></tr></table></figure></li><li>配置service<br>输入命令创建：<br>vim /lib/systemd/system/mpgo.service<br>其中mpgo为服务名称，以后启动都是这个名称。里面写这样的内容：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span> </span><br><span class="line"><span class="attr">Description</span>=mpgo</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span> </span><br><span class="line"><span class="attr">Type</span>=simple </span><br><span class="line"><span class="attr">Restart</span>=always </span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">3</span>s </span><br><span class="line"><span class="attr">ExecStart</span>=run.sh文件的完整路径 </span><br><span class="line"><span class="section">[Install]</span> </span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>说明如下：</li></ol><ul><li>Description是对这个服务的描述</li><li>Restart=always服务异常退出时会重启</li><li>RestartSec=3s设置重启间隔为3秒</li><li>ExecStart=run.sh文件的完整路径这个服务会执行这个文件</li><li>WantedBy=multi-user.target所有用户都可以执行</li></ul><ol start="4"><li>启动<br><code>service mpgo start/stop/restart/status</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;创建项目目录，进入目录后执行&lt;code&gt;go mod init 项目名&lt;/code&gt;&lt;br&gt;然后用golang打开，设置下载代理&lt;a href=&quot;https://goproxy.cn,创建入口文件main.go,并放置main方法/&quot;&gt;https://goproxy.cn，创建入口文件main.go，并放置main方法&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;直接可以引入依赖，比如：&lt;code&gt;import &amp;quot;github.com/gin-gonic/gin&amp;quot;&lt;/code&gt;&lt;br&gt;此时依赖标红，然后下载依赖，同时会在go.mod里面显示增加的依赖，代码中也没有报错&lt;br&gt;然后代码为：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;github.com/gin-gonic/gin&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r := gin.Default()       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r.GET(&lt;span class=&quot;string&quot;&gt;&amp;quot;/ping&amp;quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; &amp;#123;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c.JSON(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, gin.H&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&amp;quot;message&amp;quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;pong&amp;quot;&lt;/span&gt;,              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r.Run() &lt;span class=&quot;comment&quot;&gt;// listen and serve on 0.0.0.0:8080 (for windows &amp;quot;localhost:8080&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="go" scheme="https://shenhongwei33.github.io/categories/go/"/>
    
    
    <category term="gin" scheme="https://shenhongwei33.github.io/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>go基础</title>
    <link href="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/"/>
    <id>https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/</id>
    <published>2023-01-25T02:14:41.000Z</published>
    <updated>2023-01-25T02:50:29.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="go的安装"><a href="#go的安装" class="headerlink" title="go的安装"></a>go的安装</h2><ul><li><p>安装 mercurial、git、gcc包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum install mercurial git gcc</span></span><br></pre></td></tr></table></figure></li><li><p>下载Go的压缩包</p></li><li><p>用tar 命令来解压压缩包。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf go1.<span class="number">13</span><span class="selector-class">.linux-amd64</span><span class="selector-class">.tar</span>.gz</span><br></pre></td></tr></table></figure></li><li><p>建立Go的工作空间（workspace，也就是GOPATH环境变量指向的目录），GO代码必须在工作空间内。工作空间是一个目录，其中包含三个子目录：<br>src —- 里面每一个子目录，就是一个包。包内是Go的源码文件<br>pkg —- 编译后生成的，包的目标文件<br>bin —- 生成的可执行文件</p></li></ul><p>这里，我们在/home目录下, 建立一个名为go(可以不是go, 任意名字都可以)的文件夹， 然后再建立三个子文件夹(子文件夹名必须为src、pkg、bin)。</p><ul><li>添加PATH环境变量and设置GOPATH环境变量<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="keyword">go</span>]# <span class="keyword">vi</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure>加入下面这三行:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">GOROOT</span>=/usr/local/go        ##Golang安装目录</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$GOROOT</span>/bin:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">GOPATH</span>=/home/go  ##Golang项目目录</span><br></pre></td></tr></table></figure></li></ul><p>保存后，执行以下命令，使环境变量立即生效:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost go]# source /etc/profile ##刷新环境变量</span><br></pre></td></tr></table></figure><p>至此，Go语言的环境已经安装完毕。</p><ul><li>验证一下是否安装成功，如果出现下面的信息说明安装成功了</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="keyword">go</span>]# <span class="keyword">go</span> <span class="keyword">version</span>        ##查看<span class="keyword">go</span>版本</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">version</span> go1.<span class="number">13</span> linux/amd64</span><br></pre></td></tr></table></figure><ul><li>查看Go语言的环境信息</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> go]<span class="meta"># go env</span></span><br></pre></td></tr></table></figure><p>防止go下载依赖较慢，可设置代理：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go env -w <span class="attribute">GOPROXY</span>=https://goproxy.cn,direct</span><br><span class="line">go env -w  <span class="attribute">GO111MODULE</span>=on</span><br><span class="line">go env -w <span class="attribute">GOARCH</span>=amd64</span><br></pre></td></tr></table></figure><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>需要在环境变量中设置GOPATH<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-1.png"><br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-2.png"><br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-3.png"></p><h2 id="配置GOPATH"><a href="#配置GOPATH" class="headerlink" title="配置GOPATH"></a>配置GOPATH</h2><p>GOPATH是一个环境变量，用来表明你写的go项目的存放路径。<br>GOPATH路径最好只设置一个，所有的项目代码都放到GOPATH的src目录下。</p><h3 id="go的项目目录"><a href="#go的项目目录" class="headerlink" title="go的项目目录"></a>go的项目目录</h3><p>在进行Go语言开发的时候，我们的代码总是会保存在$GOPATH/src目录下。在工程经过go build、go install或go get等指令后，会将下载的第三方包源代码文件放在$GOPATH/src目录下， 产生的二进制可执行文件放在 $GOPATH/bin目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加$GOPATH/src目录的源代码即可。bin 和 pkg 目录的内容无需版本控制。</p><h3 id="目前流行的项目结构"><a href="#目前流行的项目结构" class="headerlink" title="目前流行的项目结构"></a>目前流行的项目结构</h3><p>Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用顶级域名来作为包名的前缀，这样就不担心项目名冲突的问题了。因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的github用户名来区分不同的包。<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p><h1 id="go基础"><a href="#go基础" class="headerlink" title="go基础"></a>go基础</h1><h2 id="Go语言的主要特征"><a href="#Go语言的主要特征" class="headerlink" title="Go语言的主要特征"></a>Go语言的主要特征</h2><p>1.自动立即回收。<br>2.更丰富的内置类型。<br>3.函数多返回值。<br>4.错误处理。<br>5.匿名函数和闭包。<br>6.类型和接口。<br>7.并发编程。<br>8.反射。<br>9.语言交互性。</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>Less can be more 大道至简,小而蕴真 让事情变得复杂很容易，让事情变得简单才难 深刻的工程文化</p><h3 id="Go语言命名"><a href="#Go语言命名" class="headerlink" title="Go语言命名"></a>Go语言命名</h3><p>Go的函数、变量、常量、自定义类型、包(package)的命名方式遵循以下规则：</p><ol><li>首字符可以是任意的Unicode字符或者下划线</li><li>剩余字符可以是Unicode字符、下划线、数字</li><li>字符长度不限</li></ol><p>Go只有25个关键字：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">break</span>           <span class="keyword">default</span>         func            <span class="keyword">interface</span>       <span class="symbol">select</span></span><br><span class="line"><span class="symbol">case</span>             <span class="symbol">defer</span>            <span class="symbol">go</span>               <span class="symbol">map</span>              <span class="symbol">struct</span></span><br><span class="line"><span class="symbol">chan</span>            <span class="symbol">else</span>              <span class="symbol">goto</span>            <span class="symbol">package</span>       <span class="symbol">switch</span></span><br><span class="line"><span class="symbol">const</span>           <span class="symbol">fallthrough</span>   <span class="symbol">if</span>                 <span class="symbol">range</span>           <span class="symbol">type</span></span><br><span class="line"><span class="symbol">continue</span>     <span class="symbol">for</span>                <span class="symbol">import</span>         <span class="symbol">return</span>           <span class="symbol">var</span></span><br></pre></td></tr></table></figure><p>Go还有37个保留字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">Types:    <span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span>  </span><br><span class="line">              <span class="type">uint</span>  <span class="type">uint8</span>  <span class="type">uint16</span>  <span class="type">uint32</span>  <span class="type">uint64</span>  <span class="type">uintptr</span></span><br><span class="line">              <span class="type">float32</span>  <span class="type">float64</span>  <span class="type">complex128</span>  <span class="type">complex64</span></span><br><span class="line">              <span class="type">bool</span>  <span class="type">byte</span>  <span class="type">rune</span>  <span class="type">string</span>  <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">                 <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">                 <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><p>可见性：</p><ol><li>声明在函数内部，是函数的本地值，类似private</li><li>声明在函数外部，是对当前包可见(包内所有.go文件都可见)的全局值，类似protect</li><li>声明在函数外部且首字母大写是所有包可见的全局值,类似public</li></ol><h3 id="Go语言声明"><a href="#Go语言声明" class="headerlink" title="Go语言声明"></a>Go语言声明</h3><p>有四种主要声明方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>（声明变量）, <span class="keyword">const</span>（声明常量）, <span class="keyword">type</span>（声明类型） ,<span class="function"><span class="keyword">func</span>（声明函数）。</span></span><br></pre></td></tr></table></figure><p>Go的程序是保存在多个.go文件中，文件的第一行就是package XXX声明，用来说明该文件属于哪个包(package)，package声明下来就是import声明，再下来是类型，变量，常量，函数的声明。</p><h3 id="Go项目构建及编译"><a href="#Go项目构建及编译" class="headerlink" title="Go项目构建及编译"></a>Go项目构建及编译</h3><p>一个Go工程中主要包含以下三个目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src：源代码文件</span><br><span class="line">pkg：包文件</span><br><span class="line"><span class="built_in">bin</span>：相关<span class="built_in">bin</span>文件</span><br></pre></td></tr></table></figure><ol><li>建立工程文件夹 goproject</li><li>在工程文件夹中建立src,pkg,bin文件夹</li><li>在GOPATH中添加projiect路径 例 e:/goproject</li><li>如工程中有自己的包examplepackage，那在src文件夹下建立以包名命名的文件夹 例 examplepackage</li><li>在src文件夹下编写主程序代码代码 goproject.go</li><li>在examplepackage文件夹中编写 examplepackage.go 和 包测试文件 examplepackage_test.go</li><li>编译调试包<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build examplepackage</span><br><span class="line"><span class="keyword">go</span> test examplepackage</span><br><span class="line"><span class="keyword">go</span> install examplepackage</span><br></pre></td></tr></table></figure></li></ol><p>这时在pkg文件夹中可以发现会有一个相应的操作系统文件夹如windows_386z, 在这个文件夹中会有examplepackage文件夹，在该文件中有examplepackage.a文件</p><ol start="8"><li>编译主程序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build goproject.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>成功后会生成goproject.exe文件，至此一个Go工程编辑成功。</li></ol><h3 id="go-编译问题"><a href="#go-编译问题" class="headerlink" title="go 编译问题"></a>go 编译问题</h3><p>golang的编译使用命令 go build , go install;除非仅写一个main函数，否则还是准备好目录结构； GOPATH=工程根目录；其下应创建src，pkg，bin目录，bin目录中用于生成可执行文件，pkg目录中用于生成.a文件； golang中的import name，实际是到GOPATH中去寻找name.a, 使用时是该name.a的源码中生命的package 名字；这个在前面已经介绍过了。<br>注意点：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.系统编译时 go install abc_name时，系统会到GOPATH的src目录中寻找abc_name目录，然后编译其下的go文件；</span><br><span class="line">    <span class="number">2</span>.同一个目录中所有的go文件的<span class="keyword">package</span>声明必须相同，所以main方法要单独放一个文件，否则在eclipse和liteide中都会报错；</span><br><span class="line">    编译报错如下：（假设test目录中有个main.go 和mymath.go,其中main.go声明<span class="keyword">package</span>为main，mymath.go声明packag 为test);</span><br><span class="line">        $ go install test</span><br><span class="line">        can<span class="symbol">&#x27;t</span> load <span class="keyword">package</span>: <span class="keyword">package</span> <span class="title">test: found packages main (main.go) and test (mymath.go) in /home/wanjm/go/src/test</span></span><br><span class="line">        报错说 不能加载<span class="keyword">package</span> <span class="title">test（这是命令行的参数），因为发现了两个<span class="keyword">package</span>，分别时main.go 和 mymath.go;</span></span><br><span class="line">    <span class="number">3</span>.对于main方法，只能在bin目录下运行 go build path_tomain.go; 可以用-o参数指出输出文件名；</span><br><span class="line">    <span class="number">4</span>.可以添加参数 go build -gcflags <span class="string">&quot;-N -l&quot;</span> ****,可以更好的便于gdb；详细参见 http://golang.org/doc/gdb</span><br><span class="line">    <span class="number">5</span>.gdb全局变量主一点。 如有全局变量 a；则应写为 p <span class="symbol">&#x27;main.a</span>&#x27;；注意但引号不可少；</span><br></pre></td></tr></table></figure><h2 id="Golang内置类型和函数"><a href="#Golang内置类型和函数" class="headerlink" title="Golang内置类型和函数"></a>Golang内置类型和函数</h2><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="type">int</span>(<span class="number">32</span> or <span class="number">64</span>), <span class="type">int8</span>, <span class="type">int16</span>, <span class="type">int32</span>, <span class="type">int64</span></span><br><span class="line"><span class="type">uint</span>(<span class="number">32</span> or <span class="number">64</span>), <span class="type">uint8</span>(<span class="type">byte</span>), <span class="type">uint16</span>, <span class="type">uint32</span>, <span class="type">uint64</span></span><br><span class="line"><span class="type">float32</span>, <span class="type">float64</span></span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">complex64</span>, <span class="type">complex128</span></span><br><span class="line">array    -- 固定长度的数组</span><br></pre></td></tr></table></figure><h4 id="引用类型：-指针类型"><a href="#引用类型：-指针类型" class="headerlink" title="引用类型：(指针类型)"></a>引用类型：(指针类型)</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">slice</span>   <span class="comment">-- 序列数组(最常用)</span></span><br><span class="line">map     <span class="comment">-- 映射</span></span><br><span class="line">chan    <span class="comment">-- 管道</span></span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>          -- 用来追加元素到数组、slice中,返回修改后的数组、slice</span><br><span class="line"><span class="built_in">close</span>           -- 主要用来关闭channel</span><br><span class="line"><span class="built_in">delete</span>            -- 从<span class="keyword">map</span>中删除key对应的value</span><br><span class="line"><span class="built_in">panic</span>            -- 停止常规的goroutine  （<span class="built_in">panic</span>和<span class="built_in">recover</span>：用来做错误处理）</span><br><span class="line"><span class="built_in">recover</span>         -- 允许程序定义goroutine的<span class="built_in">panic</span>动作</span><br><span class="line"><span class="built_in">real</span>            -- 返回<span class="built_in">complex</span>的实部   （<span class="built_in">complex</span>、<span class="built_in">real</span> <span class="built_in">imag</span>：用于创建和操作复数）</span><br><span class="line"><span class="built_in">imag</span>            -- 返回<span class="built_in">complex</span>的虚部</span><br><span class="line"><span class="built_in">make</span>            -- 用来分配内存，返回Type本身(只能应用于slice, <span class="keyword">map</span>, channel)</span><br><span class="line"><span class="built_in">new</span>                -- 用来分配内存，主要用来分配值类型，比如<span class="type">int</span>、<span class="keyword">struct</span>。返回指向Type的指针</span><br><span class="line"><span class="built_in">cap</span>                -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 <span class="keyword">map</span>）</span><br><span class="line"><span class="built_in">copy</span>            -- 用于复制和连接slice，返回复制的数目</span><br><span class="line"><span class="built_in">len</span>                -- 来求长度，比如<span class="type">string</span>、array、slice、<span class="keyword">map</span>、channel ，返回长度</span><br><span class="line"><span class="built_in">print</span>、<span class="built_in">println</span>     -- 底层打印函数，在部署环境中建议使用 fmt 包</span><br></pre></td></tr></table></figure><h3 id="内置接口error"><a href="#内置接口error" class="headerlink" title="内置接口error"></a>内置接口error</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error interface &#123; //只要实现了<span class="type">Error</span>()函数，返回值为<span class="type">String</span>的都实现了err接口</span><br><span class="line">            <span class="type">Error</span>()    <span class="type">String</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Init函数和main函数"><a href="#Init函数和main函数" class="headerlink" title="Init函数和main函数"></a>Init函数和main函数</h2><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>go语言中init函数用于包(package)的初始化，该函数是go语言的一个重要特性。<br>有下面的特征：</p><ol><li>init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</li><li>每个包可以拥有多个init函数</li><li>包的每个源文件也可以拥有多个init函数</li><li>同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</li><li>不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</li><li>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</li></ol><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>Go语言程序的默认入口函数(主函数)：func main()函数体用｛｝一对括号包裹。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main()&#123;</span><br><span class="line">        <span class="regexp">//</span>函数体</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="init函数和main函数的异同"><a href="#init函数和main函数的异同" class="headerlink" title="init函数和main函数的异同"></a>init函数和main函数的异同</h3><p>相同点：<br>        两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。<br>不同点：<br>        init可以应用于任意包中，且可以重复定义多个。<br>        main函数只能用于main包中，且只能定义一个。</p><p>两个函数的执行顺序：</p><ul><li><p>对同一个go文件的init()调用顺序是从上到下的。</p></li><li><p>对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数。</p></li><li><p>对于不同的package，如果不相互依赖的话，按照main包中”先import的后调用”的顺序调用其包中的init()，如果package存在依赖，则先调用最早被依赖的package中的init()，最后调用main函数。</p></li><li><p>如果init函数中使用了println()或者print()你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2></li><li><p>go env用于打印Go语言的环境信息。</p></li><li><p>go run命令可以编译并运行命令源码文件。</p></li><li><p>go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。</p></li><li><p>go build命令用于编译我们指定的源码文件或代码包以及它们的依赖包。</p></li><li><p>go install用于编译并安装指定的代码包及它们的依赖包。</p></li><li><p>go clean命令会删除掉执行其它命令时产生的一些文件和目录。</p></li><li><p>go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p></li><li><p>go test命令用于对Go语言编写的程序进行测试。</p></li><li><p>go list命令的作用是列出指定的代码包的信息。</p></li><li><p>go fix会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。</p></li><li><p>go vet是一个用于检查Go语言源码中静态错误的简单工具。</p></li><li><p>go tool pprof命令来交互式的访问概要文件的内容。</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>/</td><td>相除</td></tr><tr><td>%</td><td>取余</td></tr></tbody></table><p><strong>注意： ++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符。</strong></p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li>==</li><li>!=</li><li><blockquote></blockquote></li><li>&lt;</li><li><blockquote><p>=</p></blockquote></li><li>&lt;=</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li>&amp;&amp;</li><li>||</li><li>!</li></ul><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li>&amp;</li><li>|</li><li>^</li><li><pre><code>&gt;&gt; ：左移n位就是乘以2的n次方。</code></pre></li><li>&lt; &lt;</li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li>=</li><li>+=</li><li>-=</li><li><pre><code> * =</code></pre></li><li>/=</li><li>%=</li><li>  &lt;&lt;=</li><li><blockquote><blockquote><p>=</p></blockquote></blockquote></li><li>  &amp;=</li><li>  |=</li><li>  ^=</li></ul><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>“_”是特殊标识符，用来忽略结果。</p><h3 id="下划线在import中"><a href="#下划线在import中" class="headerlink" title="下划线在import中"></a>下划线在import中</h3><p>在Golang里，import的作用是导入其他package。</p><p>import 下划线（如：import hello/imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;./hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// hello.Print() </span></span><br><span class="line">    <span class="comment">//编译报错：./main.go:6:5: undefined: hello&#125;</span></span><br></pre></td></tr></table></figure><h3 id="下划线在代码中"><a href="#下划线在代码中" class="headerlink" title="下划线在代码中"></a>下划线在代码中</h3><p>占位符，意思是那个位置本应赋给某个值，但是咱们不需要这个值。所以就把该值赋给下划线，意思是丢掉不要。这样编译器可以更好的优化，任何类型的单个值都可以丢给下划线。这种情况是占位用的，方法返回两个结果，而你只想要一个结果。那另一个就用 “ _ “ 占位，而如果用变量的话，不使用，编译器是会报错的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    f, _ := os.Open(<span class="string">&quot;/Users/***/Desktop/text.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, _ := f.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>    </span><br><span class="line">        &#125;</span><br><span class="line">        os.Stdout.Write(buf[:n])</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。</p><h4 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h4><p>Go语言的变量声明格式为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字var开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="built_in">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="built_in">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="built_in">bool</span></span><br></pre></td></tr></table></figure><h4 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h4><p>每声明一个变量就需要写var关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">       a <span class="type">string</span></span><br><span class="line">       b <span class="type">int</span></span><br><span class="line">       c <span class="type">bool</span></span><br><span class="line">       d <span class="type">float32</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 类型 <span class="operator">=</span> 表达式</span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, sex = <span class="string">&quot;pprof.cn&quot;</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name <span class="operator">=</span> <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">var sex <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h5><p>在函数内部，可以使用更简略的 := 方式声明并初始化变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)<span class="comment">// 全局变量mvar m = 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">10</span></span><br><span class="line">    m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">    fmt.Println(m, n)&#125;</span><br></pre></td></tr></table></figure><h5 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h5><p>在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, _ := foo()</span><br><span class="line">    _, y := foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;x=&quot;</span>, x)</span><br><span class="line">    fmt.Println(<span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在Lua等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li>函数外的每个语句都必须以关键字开始（var、const、func等）</li><li>:=不能使用在函数外。</li><li> _ 多用于占位，表示忽略值。</li></ol><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const</span> pi = <span class="number">3</span>.<span class="number">1415</span></span><br><span class="line"><span class="attribute">const</span> e = <span class="number">2</span>.<span class="number">7182</span></span><br></pre></td></tr></table></figure><p>多个常量也可以一起声明：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">        pi <span class="operator">=</span> <span class="number">3.1415</span></span><br><span class="line">        e <span class="operator">=</span> <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">        n1 <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">        n2</span><br><span class="line">        n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量n1、n2、n3的值都是100。</p><h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p>iota是go语言的常量计数器，只能在常量的表达式中使用。 iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">            n1 = iota <span class="regexp">//</span><span class="number">0</span></span><br><span class="line">            n2        <span class="regexp">//</span><span class="number">1</span></span><br><span class="line">            n3        <span class="regexp">//</span><span class="number">2</span></span><br><span class="line">            n4        <span class="regexp">//</span><span class="number">3</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h4 id="几个常见的iota示例"><a href="#几个常见的iota示例" class="headerlink" title="几个常见的iota示例"></a>几个常见的iota示例</h4><p>使用_跳过某些值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">            n1 = iota <span class="regexp">//</span><span class="number">0</span></span><br><span class="line">            n2        <span class="regexp">//</span><span class="number">1</span></span><br><span class="line">            _</span><br><span class="line">            n4        <span class="regexp">//</span><span class="number">3</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>iota声明中间插队：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">            n1 = iota <span class="regexp">//</span><span class="number">0</span></span><br><span class="line">            n2 = <span class="number">100</span>  <span class="regexp">//</span><span class="number">100</span></span><br><span class="line">            n3 = iota <span class="regexp">//</span><span class="number">2</span></span><br><span class="line">            n4        <span class="regexp">//</span><span class="number">3</span></span><br><span class="line">        )</span><br><span class="line">    const n5 = iota <span class="regexp">//</span><span class="number">0</span></span><br></pre></td></tr></table></figure><p>定义数量级 （这里的&lt;&lt;表示左移操作，1&lt;&lt;10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2&lt;&lt;2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">            _  = <span class="literal">iota</span></span><br><span class="line">            KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">            MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">            GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">            TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">            PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>多个iota定义在一行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">            a, b = iota + <span class="number">1</span>, iota + <span class="number">2</span> <span class="regexp">//</span><span class="number">1</span>,<span class="number">2</span></span><br><span class="line">            c, d                      <span class="regexp">//</span><span class="number">2</span>,<span class="number">3</span></span><br><span class="line">            e, f                      <span class="regexp">//</span><span class="number">3</span>,<span class="number">4</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="基本类型介绍"><a href="#基本类型介绍" class="headerlink" title="基本类型介绍"></a>基本类型介绍</h3><p>Golang 更明确的数字类型命名，支持 Unicode，支持常用数据结构。</p><table><thead><tr><th>类型</th><th>长度（字节）</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>false</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point, int32</td></tr><tr><td>int, uint</td><td>4或8</td><td>0</td><td>32 或 64 位</td></tr><tr><td>int8, uint8</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255，byte是uint8 的别名</td></tr><tr><td>int16, uint16</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32, uint32</td><td>4</td><td>0</td><td>-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td></tr><tr><td>int64, uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0.0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0.0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4或8</td><td></td><td>以存储指针的 uint32 或 uint64 整数</td></tr><tr><td>array</td><td></td><td></td><td>值类型</td></tr><tr><td>struct</td><td></td><td></td><td>值类型</td></tr><tr><td>string</td><td></td><td>“”</td><td>UTF-8 字符串</td></tr><tr><td>slice</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>map</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>channel</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>interface</td><td></td><td>nil</td><td>接口</td></tr><tr><td>function</td><td></td><td>nil</td><td>函数</td></tr></tbody></table><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64对应的无符号整型：uint8、uint16、uint32、uint64其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。</p><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>complex64和complex128复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。</p><p><strong>注意：</strong></p><ul><li><pre><code>布尔类型变量的默认值为false。</code></pre></li><li><pre><code>Go 语言中不允许将整型强制转换为布尔型.</code></pre></li><li><pre><code>布尔型无法参与数值运算，也无法与其他类型进行转换。</code></pre></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(“)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure><h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转义</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠</td></tr></tbody></table><h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>Go语言中要定义一个多行字符串时，就必须使用反引号字符：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := `第一行</span><br><span class="line">    第二行</span><br><span class="line">    第三行</span><br><span class="line">    `</span><br><span class="line">    fmt.Println(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h4 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h4><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.Contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀/后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作，连接指定数组的元素或集合的成员，在每个元素或成员之间使用指定的分隔符。</td></tr></tbody></table><h4 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h4><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a := <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b := <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li>uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。</li><li>rune类型，代表一个 UTF-8字符。</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。 Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line">    func <span class="built_in">traversalString</span>() &#123;</span><br><span class="line">        s := <span class="string">&quot;pprof.cn博客&quot;</span></span><br><span class="line">        for i := <span class="number">0</span>; <span class="selector-tag">i</span> &lt; <span class="built_in">len</span>(s); <span class="selector-tag">i</span>++ &#123; <span class="comment">//byte</span></span><br><span class="line">            fmt<span class="selector-class">.Printf</span>(&quot;%v(%c) &quot;, s<span class="selector-attr">[i]</span>, s<span class="selector-attr">[i]</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>()</span><br><span class="line">        for _, r := range s &#123; <span class="comment">//rune</span></span><br><span class="line">            fmt<span class="selector-class">.Printf</span>(&quot;%v(%c) &quot;, r, r)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> 输出：</span><br><span class="line"> </span><br><span class="line"> <span class="number">112</span>(p) <span class="number">112</span>(p) <span class="number">114</span>(r) <span class="number">111</span>(o) <span class="number">102</span>(f) <span class="number">46</span>(.) <span class="number">99</span>(c) <span class="number">110</span>(n) <span class="number">229</span>(å) <span class="number">141</span>() <span class="number">154</span>() <span class="number">229</span>(å) <span class="number">174</span>(®) <span class="number">162</span>(¢)</span><br><span class="line"> </span><br><span class="line"> <span class="number">112</span>(p) <span class="number">112</span>(p) <span class="number">114</span>(r) <span class="number">111</span>(o) <span class="number">102</span>(f) <span class="number">46</span>(.) <span class="number">99</span>(c) <span class="number">110</span>(n) <span class="number">21338</span>(博) <span class="number">23458</span>(客)</span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="built_in">changeString</span>() &#123;</span><br><span class="line">        s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">        <span class="comment">// 强制类型转换</span></span><br><span class="line">        byteS1 := <span class="selector-attr">[]</span><span class="built_in">byte</span>(s1)</span><br><span class="line">        byteS1<span class="selector-attr">[0]</span> = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="built_in">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">        s2 := <span class="string">&quot;博客&quot;</span></span><br><span class="line">        runeS2 := <span class="selector-attr">[]</span><span class="built_in">rune</span>(s2)</span><br><span class="line">        runeS2<span class="selector-attr">[0]</span> = <span class="string">&#x27;狗&#x27;</span></span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="built_in">string</span>(runeS2))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。强制类型转换的基本语法如下：<br><code>T(表达式)</code><br>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p><p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func sqrt<span class="constructor">Demo()</span> &#123;</span><br><span class="line">        var a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">        var c <span class="built_in">int</span></span><br><span class="line">        <span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">        c = <span class="built_in">int</span>(math.<span class="constructor">Sqrt(<span class="params">float64</span>(<span class="params">a</span><span class="operator">*</span><span class="params">a</span> + <span class="params">b</span><span class="operator">*</span><span class="params">b</span>)</span>))</span><br><span class="line">        fmt.<span class="constructor">Println(<span class="params">c</span>)</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h2><p>Golang Array和以往认知的数组有很大不同：</p><ol><li><p>数组：是同一种数据类型的固定长度的序列。</p></li><li><p>数组定义：var a [len]int，比如：var a [5]int，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。</p></li><li><p>长度是数组类型的一部分，因此，var a[5] int和var a [10]int是不同的类型。</p></li><li><p>数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for <span class="selector-tag">i</span> := <span class="number">0</span>; <span class="selector-tag">i</span> &lt; len(<span class="selector-tag">a</span>); <span class="selector-tag">i</span>++ &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for index, v := range a &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic</p></li><li><p>数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。</p></li><li><p>支持 “==”、”!=” 操作符，因为内存总是被初始化过的。</p></li><li><p>指针数组 [n]*T，数组指针 *[n]T。</p></li></ol><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">全局：</span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">var</span> str = [<span class="number">5</span>]<span class="type">string</span>&#123;<span class="number">3</span>: <span class="string">&quot;hello world&quot;</span>, <span class="number">4</span>: <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line">局部：</span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;           <span class="comment">// 未初始化元素值为 0。</span></span><br><span class="line">b := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;   <span class="comment">// 通过初始化值确定数组长度。</span></span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">100</span>, <span class="number">4</span>: <span class="number">200</span>&#125; <span class="comment">// 使用索引号初始化元素。</span></span><br><span class="line">d := [...]<span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">uint8</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;user1&quot;</span>, <span class="number">10</span>&#125;, <span class="comment">// 可省略元素类型。</span></span><br><span class="line">        &#123;<span class="string">&quot;user2&quot;</span>, <span class="number">20</span>&#125;, <span class="comment">// 别忘了最后一行的逗号。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">var</span> str = [<span class="number">5</span>]<span class="type">string</span>&#123;<span class="number">3</span>: <span class="string">&quot;hello world&quot;</span>, <span class="number">4</span>: <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;           <span class="comment">// 未初始化元素值为 0。</span></span><br><span class="line">    b := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;   <span class="comment">// 通过初始化值确定数组长度。</span></span><br><span class="line">    c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">100</span>, <span class="number">4</span>: <span class="number">200</span>&#125; <span class="comment">// 使用引号初始化元素。</span></span><br><span class="line">    d := [...]<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">        age  <span class="type">uint8</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;user1&quot;</span>, <span class="number">10</span>&#125;, <span class="comment">// 可省略元素类型。</span></span><br><span class="line">        &#123;<span class="string">&quot;user2&quot;</span>, <span class="number">20</span>&#125;, <span class="comment">// 别忘了最后一行的逗号。</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(arr0, arr1, arr2, str)</span><br><span class="line">    fmt.Println(a, b, c, d)&#125;</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">全局</span></span><br><span class="line"><span class="language-xml">var arr0 [5][3]int</span></span><br><span class="line"><span class="language-xml">var arr1 [2][3]int = [...][3]int</span><span class="template-variable">&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">局部：</span></span><br><span class="line"><span class="language-xml">a := [2][3]int</span><span class="template-variable">&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">b := [...][2]int</span><span class="template-variable">&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125;</span><span class="language-xml"> // 第 2 纬度不能用 &quot;...&quot;。</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> arr0 <span class="selector-attr">[5]</span><span class="selector-attr">[3]</span>int</span><br><span class="line"><span class="selector-tag">var</span> arr1 <span class="selector-attr">[2]</span><span class="selector-attr">[3]</span>int = <span class="selector-attr">[...]</span><span class="selector-attr">[3]</span>int&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">a</span> := <span class="selector-attr">[2]</span><span class="selector-attr">[3]</span>int&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">    <span class="selector-tag">b</span> := <span class="selector-attr">[...]</span><span class="selector-attr">[2]</span>int&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125; <span class="comment">// 第 2 纬度不能用 &quot;...&quot;。</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(arr0, arr1)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="selector-tag">a</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值拷贝行为会造成性能问题，通常会建议使用 slice，或数组指针。</p><h5 id="多维数组遍历"><a href="#多维数组遍历" class="headerlink" title="多维数组遍历"></a>多维数组遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> f [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> = [...][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k1, v1 := <span class="keyword">range</span> f &#123;</span><br><span class="line">        <span class="keyword">for</span> k2, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;(%d,%d)=%d &quot;</span>, k1, k2, v2)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组拷贝和传参"><a href="#数组拷贝和传参" class="headerlink" title="数组拷贝和传参"></a>数组拷贝和传参</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">printArr</span>(arr *<span class="selector-attr">[5]</span>int) &#123;</span><br><span class="line">    arr<span class="selector-attr">[0]</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span>, v := range arr &#123;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="selector-tag">i</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> arr1 <span class="selector-attr">[5]</span>int</span><br><span class="line">    <span class="built_in">printArr</span>(&amp;arr1)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(arr1)</span><br><span class="line">    arr2 := <span class="selector-attr">[...]</span>int&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;</span><br><span class="line">    <span class="built_in">printArr</span>(&amp;arr2)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(arr2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a>切片Slice</h2><p>需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。</p><ol><li>切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</li><li>切片的长度可以改变，因此，切片是一个可变的数组。</li><li>切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 </li><li>cap可以求出slice最大扩张容量，不能超出数组限制。0 &lt;= len(slice) &lt;= len(array)，其中array是slice引用的数组。</li><li>切片的定义：var 变量名 []类型，比如 var str []string  var arr []int。</li><li>如果 slice == nil，那么 len、cap 结果都等于 0。<h3 id="创建切片的各种方式"><a href="#创建切片的各种方式" class="headerlink" title="创建切片的各种方式"></a>创建切片的各种方式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">   <span class="comment">//1.声明切片</span></span><br><span class="line">   <span class="selector-tag">var</span> s1 <span class="selector-attr">[]</span>int</span><br><span class="line">   <span class="keyword">if</span> s1 == nil &#123;</span><br><span class="line">      fmt<span class="selector-class">.Println</span>(<span class="string">&quot;是空&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt<span class="selector-class">.Println</span>(<span class="string">&quot;不是空&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.:=</span></span><br><span class="line">   s2 := <span class="selector-attr">[]</span>int&#123;&#125;</span><br><span class="line">   <span class="comment">// 3.make()</span></span><br><span class="line">   <span class="selector-tag">var</span> s3 <span class="selector-attr">[]</span>int = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">0</span>)</span><br><span class="line">   fmt<span class="selector-class">.Println</span>(s1, s2, s3)</span><br><span class="line">   <span class="comment">// 4.初始化赋值</span></span><br><span class="line">   <span class="selector-tag">var</span> s4 <span class="selector-attr">[]</span>int = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">   fmt<span class="selector-class">.Println</span>(s4)</span><br><span class="line">   s5 := <span class="selector-attr">[]</span>int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   fmt<span class="selector-class">.Println</span>(s5)</span><br><span class="line">   <span class="comment">// 5.从数组切片</span></span><br><span class="line">   arr := <span class="selector-attr">[5]</span>int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">   <span class="selector-tag">var</span> s6 <span class="selector-attr">[]</span>int</span><br><span class="line">   <span class="comment">// 前包后不包</span></span><br><span class="line">   s6 = arr<span class="selector-attr">[1:4]</span></span><br><span class="line">   fmt<span class="selector-class">.Println</span>(s6)&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">全局：</span><br><span class="line"><span class="selector-tag">var</span> arr = <span class="selector-attr">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="selector-tag">var</span> slice0 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[start:end]</span> </span><br><span class="line"><span class="selector-tag">var</span> slice1 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[:end]</span>        </span><br><span class="line"><span class="selector-tag">var</span> slice2 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[start:]</span>        </span><br><span class="line"><span class="selector-tag">var</span> slice3 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[:]</span> </span><br><span class="line"><span class="selector-tag">var</span> slice4 = arr<span class="selector-attr">[:len(arr)-1]</span>      <span class="comment">//去掉切片的最后一个元素</span></span><br><span class="line">局部：</span><br><span class="line">arr2 := <span class="selector-attr">[...]</span>int&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">slice5 := arr<span class="selector-attr">[start:end]</span></span><br><span class="line">slice6 := arr<span class="selector-attr">[:end]</span>        </span><br><span class="line">slice7 := arr<span class="selector-attr">[start:]</span>     </span><br><span class="line">slice8 := arr<span class="selector-attr">[:]</span>  </span><br><span class="line">slice9 := arr<span class="selector-attr">[:len(arr)-1]</span> <span class="comment">//去掉切片的最后一个元素</span></span><br></pre></td></tr></table></figure><p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87.png"><br>代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> arr = <span class="selector-attr">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;<span class="selector-tag">var</span> slice0 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[2:8]</span><span class="selector-tag">var</span> slice1 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[0:6]</span>        <span class="comment">//可以简写为 var slice []int = arr[:end]var slice2 []int = arr[5:10]       //可以简写为 var slice[]int = arr[start:]var slice3 []int = arr[0:len(arr)] //var slice []int = arr[:]var slice4 = arr[:len(arr)-1]      //去掉切片的最后一个元素func main() &#123;</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：arr %v\n&quot;</span>, arr)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice0 %v\n&quot;</span>, slice0)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice1 %v\n&quot;</span>, slice1)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice2 %v\n&quot;</span>, slice2)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice3 %v\n&quot;</span>, slice3)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice4 %v\n&quot;</span>, slice4)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>)</span><br><span class="line">    arr2 := <span class="selector-attr">[...]</span>int&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    slice5 := arr<span class="selector-attr">[2:8]</span></span><br><span class="line">    slice6 := arr<span class="selector-attr">[0:6]</span>         <span class="comment">//可以简写为 slice := arr[:end]</span></span><br><span class="line">    slice7 := arr<span class="selector-attr">[5:10]</span>        <span class="comment">//可以简写为 slice := arr[start:]</span></span><br><span class="line">    slice8 := arr<span class="selector-attr">[0:len(arr)]</span>  <span class="comment">//slice := arr[:]</span></span><br><span class="line">    slice9 := arr<span class="selector-attr">[:len(arr)-1]</span> <span class="comment">//去掉切片的最后一个元素</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： arr2 %v\n&quot;</span>, arr2)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice5 %v\n&quot;</span>, slice5)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice6 %v\n&quot;</span>, slice6)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice7 %v\n&quot;</span>, slice7)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice8 %v\n&quot;</span>, slice8)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice9 %v\n&quot;</span>, slice9)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">全局变量：arr [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">全局变量：slice0 [<span class="number">2 3 4 5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">全局变量：slice1 [<span class="number">0 1 2 3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">全局变量：slice2 [<span class="number">5 6 7 8</span> <span class="number">9</span>]</span><br><span class="line">全局变量：slice3 [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">全局变量：slice4 [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span>]</span><br><span class="line">-----------------------------------</span><br><span class="line">局部变量： arr2 [<span class="number">9 8 7 6</span> <span class="number">5 4 3 2</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">局部变量： slice5 [<span class="number">2 3 4 5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">局部变量： slice6 [<span class="number">0 1 2 3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">局部变量： slice7 [<span class="number">5 6 7 8</span> <span class="number">9</span>]</span><br><span class="line">局部变量： slice8 [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">局部变量： slice9 [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3 id="通过make来创建切片"><a href="#通过make来创建切片" class="headerlink" title="通过make来创建切片"></a>通过make来创建切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line">slice  := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line">slice  := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/make%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87.png"><br>代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> slice0 <span class="selector-attr">[]</span>int = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>)</span><br><span class="line"><span class="selector-tag">var</span> slice1 = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>)</span><br><span class="line"><span class="selector-tag">var</span> slice2 = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make全局slice0 ：%v\n&quot;</span>, slice0)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make全局slice1 ：%v\n&quot;</span>, slice1)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make全局slice2 ：%v\n&quot;</span>, slice2)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;--------------------------------------&quot;</span>)</span><br><span class="line">    slice3 := <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>)</span><br><span class="line">    slice4 := <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>)</span><br><span class="line">    slice5 := <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make局部slice3 ：%v\n&quot;</span>, slice3)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make局部slice4 ：%v\n&quot;</span>, slice4)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make局部slice5 ：%v\n&quot;</span>, slice5)&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> make全局slice0 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> make全局slice1 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> make全局slice2 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> --------------------------------------</span><br><span class="line">make局部slice3 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">make局部slice4 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">make局部slice5 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>切片的内存布局：<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></p><p>读写操作实际目标是底层数组，只需注意索引号的差别。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    data := <span class="selector-attr">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    s := data<span class="selector-attr">[2:4]</span></span><br><span class="line">    s<span class="selector-attr">[0]</span> += <span class="number">100</span></span><br><span class="line">    s<span class="selector-attr">[1]</span> += <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(s)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(data)&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[102 203]</span></span><br><span class="line"><span class="string">[0 1 102 203 4 5]</span></span><br></pre></td></tr></table></figure><p>可直接创建 slice 对象，自动分配底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>: <span class="number">100</span>&#125; <span class="comment">// 通过初始化表达式构造，可使用索引号。</span></span><br><span class="line">    fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line"></span><br><span class="line">    s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">6</span>, <span class="number">8</span>) <span class="comment">// 使用 make 创建，指定 len 和 cap 值。</span></span><br><span class="line">    fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line"></span><br><span class="line">    s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">6</span>) <span class="comment">// 省略 cap，相当于 cap = len。</span></span><br><span class="line">    fmt.Println(s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0<span class="number"> 1 </span>2<span class="number"> 3 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>100]<span class="number"> 9 </span>9</span><br><span class="line">[0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0]<span class="number"> 6 </span>8</span><br><span class="line">[0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0]<span class="number"> 6 </span>6</span><br></pre></td></tr></table></figure><p>使用 make 动态创建slice，避免了数组必须用常量做长度的麻烦。还可用指针直接访问底层数组，退化成普通数组操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    p := &amp;s[<span class="number">2</span>] <span class="comment">// *int, 获取底层数组元素指针。</span></span><br><span class="line">    *p += <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(s)&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0 1 102 3]</span></span><br></pre></td></tr></table></figure><p>至于 [][]T，是指元素类型为 []T 。<br>可直接修改 struct array/slice 成员。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    d := <span class="selector-attr">[5]</span>struct &#123;</span><br><span class="line">        x int</span><br><span class="line">    &#125;&#123;&#125;</span><br><span class="line">    s := d<span class="selector-attr">[:]</span></span><br><span class="line">    d<span class="selector-attr">[1]</span><span class="selector-class">.x</span> = <span class="number">10</span></span><br><span class="line">    s<span class="selector-attr">[2]</span><span class="selector-class">.x</span> = <span class="number">20</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(d)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%p, %p\n&quot;</span>, &amp;d, &amp;d<span class="selector-attr">[0]</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">[</span><span class="template-variable">&#123;0&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;10&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;20&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;0&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;0&#125;</span><span class="language-xml">]</span></span><br><span class="line"><span class="language-xml">0xc4200160f0, 0xc4200160f0</span></span><br></pre></td></tr></table></figure><h3 id="用append内置函数操作切片（切片追加）"><a href="#用append内置函数操作切片（切片追加）" class="headerlink" title="用append内置函数操作切片（切片追加）"></a>用append内置函数操作切片（切片追加）</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice a : %v\n&quot;</span>, a)</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="selector-attr">[]</span>int&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice b : %v\n&quot;</span>, b)</span><br><span class="line">    c := <span class="built_in">append</span>(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>...)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice c : %v\n&quot;</span>, c)</span><br><span class="line">    d := <span class="built_in">append</span>(c, <span class="number">7</span>)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice d : %v\n&quot;</span>, d)</span><br><span class="line">    e := <span class="built_in">append</span>(d, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice e : %v\n&quot;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice a : [1<span class="number"> 2 </span>3]</span><br><span class="line">slice b : [4<span class="number"> 5 </span>6]</span><br><span class="line">slice c : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5 6]</span><br><span class="line">slice d : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7]</span><br><span class="line">slice e : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9 10]</span><br></pre></td></tr></table></figure><p>append ：向 slice 尾部添加数据，返回新的 slice 对象。</p><h3 id="超出原-slice-cap-限制，就会重新分配底层数组，即便原数组并未填满。"><a href="#超出原-slice-cap-限制，就会重新分配底层数组，即便原数组并未填满。" class="headerlink" title="超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。"></a>超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    data := <span class="selector-attr">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>: <span class="number">0</span>&#125;</span><br><span class="line">    s := data<span class="selector-attr">[:2:3]</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">100</span>, <span class="number">200</span>) <span class="comment">// 一次 append 两个值，超出 s.cap 限制。</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(s, data)         <span class="comment">// 重新分配底层数组，与原数组无关。</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(&amp;s<span class="selector-attr">[0]</span>, &amp;data<span class="selector-attr">[0]</span>) <span class="comment">// 比对底层数组起始指针。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0<span class="number"> 1 </span>100 200] [0<span class="number"> 1 </span>2<span class="number"> 3 </span>4<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0]</span><br><span class="line">0xc4200160f0 0xc420070060</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，append 后的 s 重新分配了底层数组，并复制数据。如果只追加一个值，则不会超过 s.cap 限制，也就不会重新分配。 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。</p><h3 id="slice中cap重新分配规律："><a href="#slice中cap重新分配规律：" class="headerlink" title="slice中cap重新分配规律："></a>slice中cap重新分配规律：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    c := <span class="built_in">cap</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, i)</span><br><span class="line">        <span class="keyword">if</span> n := <span class="built_in">cap</span>(s); n &gt; c &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;cap: %d -&gt; %d\n&quot;</span>, c, n)</span><br><span class="line">            c = n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cap</span>: <span class="number">1</span> -&gt; <span class="number">2</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">2</span> -&gt; <span class="number">4</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">4</span> -&gt; <span class="number">8</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">8</span> -&gt; <span class="number">16</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">16</span> -&gt; <span class="number">32</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">32</span> -&gt; <span class="number">64</span></span><br></pre></td></tr></table></figure><h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="symbol">func</span> main() &#123;</span><br><span class="line">    <span class="built_in">s1</span> := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice s1 : %v\n&quot;</span>, <span class="built_in">s1</span>)</span><br><span class="line">    <span class="built_in">s2</span> := make([]int, <span class="number">10</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice s2 : %v\n&quot;</span>, <span class="built_in">s2</span>)</span><br><span class="line">    copy(<span class="built_in">s2</span>, <span class="built_in">s1</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;copied slice s1 : %v\n&quot;</span>, <span class="built_in">s1</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;copied slice s2 : %v\n&quot;</span>, <span class="built_in">s2</span>)</span><br><span class="line">    <span class="built_in">s3</span> := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice s3 : %v\n&quot;</span>, <span class="built_in">s3</span>)</span><br><span class="line">    <span class="built_in">s3</span> = append(<span class="built_in">s3</span>, <span class="built_in">s2</span>...)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;appended slice s3 : %v\n&quot;</span>, <span class="built_in">s3</span>)</span><br><span class="line">    <span class="built_in">s3</span> = append(<span class="built_in">s3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;last slice s3 : %v\n&quot;</span>, <span class="built_in">s3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice s1 : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5]</span><br><span class="line">slice s2 : [0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0]</span><br><span class="line">copied slice s1 : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5]</span><br><span class="line">copied slice s2 : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0]</span><br><span class="line">slice s3 : [1<span class="number"> 2 </span>3]</span><br><span class="line">appended slice s3 : [1<span class="number"> 2 </span>3<span class="number"> 1 </span>2<span class="number"> 3 </span>4<span class="number"> 5 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0]</span><br><span class="line">last slice s3 : [1<span class="number"> 2 </span>3<span class="number"> 1 </span>2<span class="number"> 3 </span>4<span class="number"> 5 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 4 </span>5 6]</span><br></pre></td></tr></table></figure><p>copy ：函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。<br>应及时将所需数据 copy 到较小的 slice，以便释放超大号底层数组内存。</p><h3 id="slice遍历"><a href="#slice遍历" class="headerlink" title="slice遍历"></a>slice遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    slice := data[:]</span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;inde : %v , value : %v\n&quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inde : 0 , <span class="type">value</span> : 0</span><br><span class="line">inde : 1 , <span class="type">value</span> : 1</span><br><span class="line">inde : 2 , <span class="type">value</span> : 2</span><br><span class="line">inde : 3 , <span class="type">value</span> : 3</span><br><span class="line">inde : 4 , <span class="type">value</span> : 4</span><br><span class="line">inde : 5 , <span class="type">value</span> : 5</span><br><span class="line">inde : 6 , <span class="type">value</span> : 6</span><br><span class="line">inde : 7 , <span class="type">value</span> : 7</span><br><span class="line">inde : 8 , <span class="type">value</span> : 8</span><br><span class="line">inde : 9 , <span class="type">value</span> : 9</span><br></pre></td></tr></table></figure><h3 id="切片resize（调整大小）"><a href="#切片resize（调整大小）" class="headerlink" title="切片resize（调整大小）"></a>切片resize（调整大小）</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>int&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice a : %v , len(a) : %v\n&quot;</span>, <span class="selector-tag">a</span>, <span class="built_in">len</span>(a))</span><br><span class="line">    <span class="selector-tag">b</span> := <span class="selector-tag">a</span><span class="selector-attr">[1:2]</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice b : %v , len(b) : %v\n&quot;</span>, <span class="selector-tag">b</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    c := <span class="selector-tag">b</span><span class="selector-attr">[0:3]</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice c : %v , len(c) : %v\n&quot;</span>, c, <span class="built_in">len</span>(c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice <span class="selector-tag">a</span> : <span class="selector-attr">[1 3 4 5]</span> , <span class="built_in">len</span>(a) : <span class="number">4</span></span><br><span class="line">slice <span class="selector-tag">b</span> : <span class="selector-attr">[3]</span> , <span class="built_in">len</span>(b) : <span class="number">1</span></span><br><span class="line">slice c : <span class="selector-attr">[3 4 5]</span> , <span class="built_in">len</span>(c) : <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="数组和切片的内存布局"><a href="#数组和切片的内存布局" class="headerlink" title="数组和切片的内存布局"></a>数组和切片的内存布局</h3><p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></p><h3 id="字符串和切片（string-and-slice）"><a href="#字符串和切片（string-and-slice）" class="headerlink" title="字符串和切片（string and slice）"></a>字符串和切片（string and slice）</h3><p>string底层就是一个byte的数组，因此，也可以进行切片操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    s1 := str[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">    s2 := str[<span class="number">6</span>:]</span><br><span class="line">    fmt.Println(s2)&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello</span></span><br><span class="line"><span class="attribute">world</span></span><br></pre></td></tr></table></figure><p>string本身是不可变的，因此要改变string中字符。需要如下操作： </p><h4 id="英文字符串"><a href="#英文字符串" class="headerlink" title="英文字符串"></a>英文字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">    s := []<span class="type">byte</span>(str) <span class="comment">//中文字符需要用[]rune(str)</span></span><br><span class="line">    s[<span class="number">6</span>] = <span class="string">&#x27;G&#x27;</span></span><br><span class="line">    s = s[:<span class="number">8</span>]</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">    str = <span class="type">string</span>(s)</span><br><span class="line">    fmt.Println(str)&#125;</span><br></pre></td></tr></table></figure><p>输出结果：Hello Go!</p><h4 id="中文字符串"><a href="#中文字符串" class="headerlink" title="中文字符串"></a>中文字符串</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    str := <span class="string">&quot;你好，世界！hello world！&quot;</span></span><br><span class="line">    s := <span class="selector-attr">[]</span><span class="built_in">rune</span>(str) </span><br><span class="line">    s<span class="selector-attr">[3]</span> = <span class="string">&#x27;够&#x27;</span></span><br><span class="line">    s<span class="selector-attr">[4]</span> = <span class="string">&#x27;浪&#x27;</span></span><br><span class="line">    s<span class="selector-attr">[12]</span> = <span class="string">&#x27;g&#x27;</span></span><br><span class="line">    s = s<span class="selector-attr">[:14]</span></span><br><span class="line">    str = <span class="built_in">string</span>(s)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(str)&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，够浪！hello <span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>golang slice data[:6:8] 两个冒号的理解常规<br>slice , data[6:8]，从第6位到第8位（返回6，7），长度len为2， 最大可扩充长度cap为4（6-9）<br>另一种写法： data[:6:8] 每个数字前都有个冒号， slice内容为data从0到第6位，长度len为6，最大扩充项cap设置为8<br>a[x:y:z] 切片内容 [x:y] 切片长度: y-x 切片容量:z-x</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。<br>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p><h3 id="Go语言中的指针"><a href="#Go语言中的指针" class="headerlink" title="Go语言中的指针"></a>Go语言中的指针</h3><p>Go语言中的函数传参都是值拷贝，当我们想要修改某个变量的时候，我们可以创建一个指向该变量地址的指针变量。传递数据使用指针，而无须拷贝数据。类型指针不能进行偏移和运算。Go语言中的指针操作非常简单，只需要记住两个符号：&amp;（取地址）和* （根据地址取值）。</p><h4 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h4><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：* int、* int64、* string等。<br>取变量指针的语法如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := <span class="meta">&amp;v    <span class="comment">// v的类型为T</span></span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>v:代表被取地址的变量，类型为T</li><li> ptr:用于接收地址的变量，ptr的类型就为* T，称做T的指针类型。* 代表指针。</li></ul><p>举个例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">a</span> := <span class="number">10</span></span><br><span class="line">    <span class="selector-tag">b</span> := &amp;<span class="selector-tag">a</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;a:%d ptr:%p\n&quot;</span>, <span class="selector-tag">a</span>, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;b:%p type:%T\n&quot;</span>, <span class="selector-tag">b</span>, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们来看一下b := &amp;a的图示：<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E5%9C%B0%E5%9D%80%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B.png"></p><h4 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h4><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用* 操作，也就是指针取值，代码如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="comment">//指针取值</span></span><br><span class="line">    <span class="selector-tag">a</span> := <span class="number">10</span></span><br><span class="line">    <span class="selector-tag">b</span> := &amp;<span class="selector-tag">a</span> <span class="comment">// 取变量a的地址，将指针保存到b中</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type of b:%T\n&quot;</span>, b)</span><br><span class="line">    c := *<span class="selector-tag">b</span> <span class="comment">// 指针取值（根据指针去内存取值）</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type of c:%T\n&quot;</span>, c)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;value of c:%v\n&quot;</span>, c)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">of </span>b:*int</span><br><span class="line"><span class="keyword">type</span> <span class="type">of </span>c:int</span><br><span class="line">value <span class="keyword">of</span> c:<span class="number">10</span></span><br></pre></td></tr></table></figure><p>总结： 取地址操作符&amp;和取值操作符* 是一对互补操作符，&amp;取出地址，* 根据地址取出地址指向的值。变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ol><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（* ）操作，可以获得指针变量指向的原变量的值。</li></ol><p>指针传值示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x = <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *x = <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    modify1(a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">    modify2(&amp;a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 100&#125;</span></span><br></pre></td></tr></table></figure><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><ul><li>当一个指针被定义后没有分配到任何变量时，它的值为 nil</li><li>空指针的判断<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">p</span> *string</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;p的值是%v\n&quot;</span>, p)</span><br><span class="line">    <span class="keyword">if</span> <span class="selector-tag">p</span> != nil &#123;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;非空&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;空值&quot;</span>)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> *int</span><br><span class="line">    *<span class="selector-tag">a</span> = <span class="number">100</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(*a)</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> map<span class="selector-attr">[string]</span>int</span><br><span class="line">    <span class="selector-tag">b</span><span class="selector-attr">[<span class="string">&quot;测试&quot;</span>]</span> = <span class="number">100</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(b)&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="keyword">new</span>(<span class="keyword">Type</span>) *<span class="keyword">Type</span></span><br></pre></td></tr></table></figure><p>其中，</p><ol><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li><ul><li>Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li></ul></li></ol><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">a</span> := <span class="built_in">new</span>(int)</span><br><span class="line">    <span class="selector-tag">b</span> := <span class="built_in">new</span>(bool)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%T\n&quot;</span>, b) <span class="comment">// *bool</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(*a)       <span class="comment">// 0</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(*b)       <span class="comment">// false&#125;</span></span><br></pre></td></tr></table></figure><p>本节开始的示例代码中var a * int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> *int</span><br><span class="line">    <span class="selector-tag">a</span> = <span class="built_in">new</span>(int)</span><br><span class="line">    *<span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(*a)&#125;</span><br></pre></td></tr></table></figure><h5 id="make"><a href="#make" class="headerlink" title="make"></a>make</h5><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func make(<span class="built_in">t</span> <span class="built_in">Type</span>, size ...IntegerType) <span class="built_in">Type</span></span><br></pre></td></tr></table></figure><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。<br>本节开始的示例中var b map[string]int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    b[<span class="string">&quot;测试&quot;</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(b)&#125;</span><br></pre></td></tr></table></figure><h5 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a>new与make的区别</h5><ol><li>二者都是用来做内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h3 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h3><p>Go语言中 map的定义语法如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><p>其中，KeyType:表示键的类型，ValueType:表示键对应的值的类型。<br>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><h3 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h3><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(scoreMap)</span><br><span class="line">    fmt.Println(scoreMap[<span class="string">&quot;小明&quot;</span>])</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, scoreMap)</span><br><span class="line"> &#125;</span><br><span class="line"> 输出：</span><br><span class="line"> </span><br><span class="line"><span class="keyword">map</span>[小明:<span class="number">100</span> 张三:<span class="number">90</span>]</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="keyword">type</span> of a:<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><p>map也支持在声明的时候填充元素，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    userInfo := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(userInfo) <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h3 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h3><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    <span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">    v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h3><p>Go语言中使用for range遍历map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">&quot;王五&quot;</span>] = <span class="number">60</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>但我们只想遍历key的时候，可以按下面的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">&quot;王五&quot;</span>] = <span class="number">60</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">        fmt.Println(k)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： 遍历map时的元素顺序与添加键值对的顺序无关。</strong></p><h3 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h3><p>使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="built_in">map</span>, <span class="built_in">key</span>)</span><br></pre></td></tr></table></figure><p>其中，map:表示要删除键值对的map， key:表示要删除的键值对的键<br>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">&quot;王五&quot;</span>] = <span class="number">60</span></span><br><span class="line">    <span class="built_in">delete</span>(scoreMap, <span class="string">&quot;小明&quot;</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    <span class="built_in">rand</span>.Seed(time.Now().UnixNano()) <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">var</span> scoreMap = make(map[<span class="built_in">string</span>]<span class="type">int</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    for i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="built_in">key</span> := fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i) <span class="comment">//生成stu开头的字符串</span></span><br><span class="line">        <span class="built_in">value</span> := <span class="built_in">rand</span>.Intn(<span class="number">100</span>)          <span class="comment">//生成0~99的随机整数</span></span><br><span class="line">        scoreMap[<span class="built_in">key</span>] = <span class="built_in">value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出map中的所有key存入切片keys</span></span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">keys</span> = make([]<span class="built_in">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line">    for <span class="built_in">key</span> := range scoreMap &#123;</span><br><span class="line">        <span class="built_in">keys</span> = append(<span class="built_in">keys</span>, <span class="built_in">key</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对切片进行排序</span></span><br><span class="line">    sort.Strings(<span class="built_in">keys</span>)</span><br><span class="line">    <span class="comment">//按照排序后的key遍历map</span></span><br><span class="line">    for _, <span class="built_in">key</span> := range <span class="built_in">keys</span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">key</span>, scoreMap[<span class="built_in">key</span>])</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> mapSlice = <span class="built_in">make</span>(<span class="selector-attr">[]</span>map<span class="selector-attr">[string]</span>string, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> index, value := range mapSlice &#123;</span><br><span class="line">        fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">    <span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line">    mapSlice<span class="selector-attr">[0]</span> = <span class="built_in">make</span>(map<span class="selector-attr">[string]</span>string, <span class="number">10</span>)</span><br><span class="line">    mapSlice<span class="selector-attr">[0]</span><span class="selector-attr">[<span class="string">&quot;name&quot;</span>]</span> = <span class="string">&quot;王五&quot;</span></span><br><span class="line">    mapSlice<span class="selector-attr">[0]</span><span class="selector-attr">[<span class="string">&quot;password&quot;</span>]</span> = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    mapSlice<span class="selector-attr">[0]</span><span class="selector-attr">[<span class="string">&quot;address&quot;</span>]</span> = <span class="string">&quot;红旗大街&quot;</span></span><br><span class="line">    <span class="keyword">for</span> index, value := range mapSlice &#123;</span><br><span class="line">        fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> sliceMap = <span class="built_in">make</span>(map<span class="selector-attr">[string]</span><span class="selector-attr">[]</span>string, <span class="number">3</span>)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(sliceMap)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">    key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">    value, ok := sliceMap<span class="selector-attr">[key]</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        value = <span class="built_in">make</span>(<span class="selector-attr">[]</span>string, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    value = <span class="built_in">append</span>(value, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line">    sliceMap<span class="selector-attr">[key]</span> = value</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(sliceMap)&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><h3 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h3><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来定义自定义类型。自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将MyInt定义为<span class="built_in">int</span>类型</span><br><span class="line"><span class="built_in">type</span> MyInt <span class="built_in">int</span></span><br></pre></td></tr></table></figure><p>通过Type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名是Go1.9版本添加的新功能。类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">TypeAlias </span>= <span class="keyword">Type</span></span><br></pre></td></tr></table></figure><p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">byte</span> = <span class="type">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></table></figure><h4 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h4><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义type NewInt int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名type MyInt = int</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> NewInt</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> MyInt</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">//type of b:int&#125;</span></span><br></pre></td></tr></table></figure><p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</p><h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。Go语言中通过struct来实现面向对象。</p><h4 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h4><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 struct &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li><li>字段类型：表示结构体字段的具体类型。</li></ol><p>举个例子，我们定义一个Person（人）结构体，代码如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">    age  int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name, city <span class="keyword">string</span></span><br><span class="line">    age        int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型。</p><h4 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h4><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h4 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">    age  <span class="type">int8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p1 person</span><br><span class="line">    p1.name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">    p1.age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;pprof.cn 北京 18&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。</p><h4 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h4><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="type">string</span>; Age <span class="type">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)&#125;</span><br></pre></td></tr></table></figure><h4 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h4><p>我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p2 = <span class="keyword">new</span>(person)</span><br><span class="line">fmt.<span class="constructor">Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="params">p2</span>)</span>     <span class="comment">//*main.person</span></span><br><span class="line">fmt.<span class="constructor">Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, <span class="params">p2</span>)</span> <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出p2是一个结构体指针。需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2<span class="selector-class">.name</span> = <span class="string">&quot;测试&quot;</span></span><br><span class="line">p2<span class="selector-class">.age</span> = <span class="number">18</span></span><br><span class="line">p2<span class="selector-class">.city</span> = <span class="string">&quot;北京&quot;</span></span><br><span class="line">fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;测试&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><h4 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h4><p>使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="regexp">//</span>*main.person</span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="regexp">//</span>p3=&amp;main.person&#123;name:<span class="string">&quot;&quot;</span>, city:<span class="string">&quot;&quot;</span>, age:<span class="number">0</span>&#125;</span><br><span class="line">p3.name = <span class="string">&quot;博客&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="regexp">//</span>p3=&amp;main.person&#123;name:<span class="string">&quot;博客&quot;</span>, city:<span class="string">&quot;成都&quot;</span>, age:<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p>p3.name = “博客”其实在底层是(* p3).name = “博客”，这是Go语言帮我们实现的语法糖。</p><h4 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">    age  <span class="type">int8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p4 person</span><br><span class="line">    fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h5><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">p5</span> := person&#123;</span><br><span class="line">    <span class="attribute">name</span>: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    <span class="attribute">city</span>: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="attribute">age</span>:  <span class="number">18</span>,&#125;</span><br><span class="line"><span class="attribute">fmt</span>.Printf(<span class="string">&quot;p5=%#v\n&quot;</span>, p5) //p5=main.person&#123;name:<span class="string">&quot;pprof.cn&quot;</span>, city:<span class="string">&quot;北京&quot;</span>, age:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p6 := <span class="variable">&amp;person</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    name:</span> <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line"><span class="symbol">    city:</span> <span class="string">&quot;北京&quot;</span>,</span><br><span class="line"><span class="symbol">    age:</span>  <span class="number">18</span>,<span class="punctuation">&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p6=%#v\n&quot;</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p7=%#v\n&quot;</span>, p7) <span class="regexp">//</span>p7=&amp;main.person&#123;name:<span class="string">&quot;&quot;</span>, city:<span class="string">&quot;北京&quot;</span>, age:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h5><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">    <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="number">18</span>,&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p8=%#v\n&quot;</span>, p8) <span class="regexp">//</span>p8=&amp;main.person&#123;name:<span class="string">&quot;pprof.cn&quot;</span>, city:<span class="string">&quot;北京&quot;</span>, age:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的所有字段。</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>该方式不能和键值初始化方式混用。</li></ol><h4 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h4><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type test struct &#123;</span><br><span class="line">    <span class="attribute">a int8</span></span><br><span class="line"><span class="attribute">    b int8</span></span><br><span class="line"><span class="attribute">    c int8</span></span><br><span class="line"><span class="attribute">    d int8&#125;</span></span><br><span class="line"><span class="attribute">n</span> := test&#123;</span><br><span class="line">    1, 2, 3, 4,&#125;</span><br><span class="line">fmt<span class="variable">.Printf</span>(&quot;n<span class="variable">.a</span> %p\n&quot;, &amp;n<span class="variable">.a</span>)</span><br><span class="line">fmt<span class="variable">.Printf</span>(&quot;n<span class="variable">.b</span> %p\n&quot;, &amp;n<span class="variable">.b</span>)</span><br><span class="line">fmt<span class="variable">.Printf</span>(&quot;n<span class="variable">.c</span> %p\n&quot;, &amp;n<span class="variable">.c</span>)</span><br><span class="line">fmt<span class="variable">.Printf</span>(&quot;n<span class="variable">.d</span> %p\n&quot;, &amp;n<span class="variable">.d</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">n</span>.a <span class="number">0</span>xc0000a0060</span><br><span class="line"><span class="attribute">n</span>.b <span class="number">0</span>xc0000a0061</span><br><span class="line"><span class="attribute">n</span>.c <span class="number">0</span>xc0000a0062</span><br><span class="line"><span class="attribute">n</span>.d <span class="number">0</span>xc0000a0063</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="keyword">new</span><span class="constructor">Person(<span class="params">name</span>, <span class="params">city</span> <span class="params">string</span>, <span class="params">age</span> <span class="params">int8</span>)</span> *person &#123;</span><br><span class="line">    return &amp;person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        city: city,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := <span class="built_in">newPerson</span>(<span class="string">&quot;pprof.cn&quot;</span>, <span class="string">&quot;测试&quot;</span>, <span class="number">90</span>)</span><br><span class="line">fmt.<span class="built_in">Printf</span>(<span class="string">&quot;%#v\n&quot;</span>, p9)</span><br></pre></td></tr></table></figure><h4 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h4><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p><p>方法的定义格式如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span> &#123;</span><br><span class="line">        函数体</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ol><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()&#125;</span><br></pre></td></tr></table></figure></li></ol><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h4 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h4><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line">func (p *Person) SetAge(<span class="keyword">new</span><span class="type">Age</span> int8) &#123;</span><br><span class="line">    p.age = <span class="keyword">new</span><span class="type">Age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    p1 := <span class="built_in">NewPerson</span>(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1<span class="selector-class">.SetAge</span>(<span class="number">30</span>)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p1.age) <span class="comment">// 30&#125;</span></span><br></pre></td></tr></table></figure><h4 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h4><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄// 使用值接收者</span></span><br><span class="line">func (<span class="selector-tag">p</span> Person) <span class="built_in">SetAge2</span>(newAge int8) &#123;</span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.age</span> = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    p1 := <span class="built_in">NewPerson</span>(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1<span class="selector-class">.Dream</span>()</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1<span class="selector-class">.SetAge2</span>(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p1.age) <span class="comment">// 25&#125;</span></span><br></pre></td></tr></table></figure><h4 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h4><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h4 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h4><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line">func (m MyInt) <span class="constructor">SayHello()</span> &#123;</span><br><span class="line">    fmt.<span class="constructor">Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span>&#125;</span><br><span class="line">    </span><br><span class="line">func main<span class="literal">()</span> &#123;</span><br><span class="line">    var m1 MyInt</span><br><span class="line">    m1.<span class="constructor">SayHello()</span> <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">    m1 = <span class="number">100</span></span><br><span class="line">    fmt.<span class="constructor">Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, <span class="params">m1</span>, <span class="params">m1</span>)</span> <span class="comment">//100  main.MyInt&#125;</span></span><br></pre></td></tr></table></figure><p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h4 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">string</span></span><br><span class="line">    <span class="type">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;</span><br><span class="line">        <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">        <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;pprof.cn&quot;, int:18&#125;</span></span><br><span class="line">    fmt.Println(p1.<span class="type">string</span>, p1.<span class="type">int</span>) <span class="comment">//pprof.cn 18&#125;</span></span><br></pre></td></tr></table></figure><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">Address</span> 地址结构体</span><br><span class="line"><span class="keyword">type</span> <span class="type">Address</span> struct &#123;</span><br><span class="line">    <span class="type">Province</span> string</span><br><span class="line">    <span class="type">City</span>     string&#125;</span><br><span class="line"></span><br><span class="line">//<span class="type">User</span> 用户结构体</span><br><span class="line"><span class="keyword">type</span> <span class="type">User</span> struct &#123;</span><br><span class="line">    <span class="type">Name</span>    string</span><br><span class="line">    <span class="type">Gender</span>  string</span><br><span class="line">    <span class="type">Address</span> <span class="type">Address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">func</span> main() &#123;</span><br><span class="line">    user1 := <span class="type">User</span>&#123;</span><br><span class="line">        <span class="type">Name</span>:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">        <span class="type">Gender</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        <span class="type">Address</span>: <span class="type">Address</span>&#123;</span><br><span class="line">            <span class="type">Province</span>: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">            <span class="type">City</span>:     <span class="string">&quot;哈尔滨&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.<span class="type">Printf</span>(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)//user1=main.<span class="type">User</span>&#123;<span class="type">Name</span>:<span class="string">&quot;pprof&quot;</span>, <span class="type">Gender</span>:<span class="string">&quot;女&quot;</span>, <span class="type">Address</span>:main.<span class="type">Address</span>&#123;<span class="type">Province</span>:<span class="string">&quot;黑龙江&quot;</span>, <span class="type">City</span>:<span class="string">&quot;哈尔滨&quot;</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a>嵌套匿名结构体</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Address 地址结构体</span><br><span class="line"><span class="keyword">type</span> Address struct &#123;</span><br><span class="line">    Province <span class="keyword">string</span></span><br><span class="line">    City     <span class="keyword">string</span>&#125;</span><br><span class="line"></span><br><span class="line">//<span class="keyword">User</span> <span class="title">用户结构体</span></span><br><span class="line"><span class="title">type</span> <span class="keyword">User</span> <span class="title">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Gender  <span class="keyword">string</span></span><br><span class="line">    Address //匿名结构体&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var user2 <span class="keyword">User</span></span><br><span class="line">    <span class="title">user2</span>.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user2.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    user2.Address.Province = <span class="string">&quot;黑龙江&quot;</span>    //通过匿名结构体.字段名访问</span><br><span class="line">    user2.City = <span class="string">&quot;哈尔滨&quot;</span>                //直接访问匿名结构体的字段名</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user2=%#v\n&quot;</span>, user2) //<span class="attr">user2=</span>main.User&#123;Name:<span class="string">&quot;pprof&quot;</span>, Gender:<span class="string">&quot;女&quot;</span>, Address:main.Address&#123;Province:<span class="string">&quot;黑龙江&quot;</span>, City:<span class="string">&quot;哈尔滨&quot;</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p><h4 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h4><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province   <span class="type">string</span></span><br><span class="line">    City       <span class="type">string</span></span><br><span class="line">    CreateTime <span class="type">string</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account    <span class="type">string</span></span><br><span class="line">    CreateTime <span class="type">string</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span></span><br><span class="line">    Gender <span class="type">string</span></span><br><span class="line">    Address</span><br><span class="line">    Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user3 User</span><br><span class="line">    user3.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user3.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    <span class="comment">// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</span></span><br><span class="line">    user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">    user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">//指定Email结构体中的CreateTime&#125;</span></span><br></pre></td></tr></table></figure><h4 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h4><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet    <span class="type">int8</span></span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: <span class="number">4</span>,</span><br><span class="line">        Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">            name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">    d1.move() <span class="comment">//乐乐会动！&#125;</span></span><br></pre></td></tr></table></figure><h4 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h4><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h4 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">Student</span> 学生</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Student</span> struct &#123;</span></span><br><span class="line"><span class="class">    <span class="type">ID</span>     <span class="title">int</span></span></span><br><span class="line"><span class="class">    <span class="type">Gender</span> <span class="title">string</span></span></span><br><span class="line"><span class="class">    <span class="type">Name</span>   <span class="title">string</span>&#125;</span></span><br><span class="line"></span><br><span class="line">//<span class="type">Class</span> 班级</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Class</span> struct &#123;</span></span><br><span class="line"><span class="class">    <span class="type">Title</span>    <span class="title">string</span></span></span><br><span class="line"><span class="class">    <span class="type">Students</span> []*<span class="type">Student</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">func</span> main() &#123;</span><br><span class="line">    c := &amp;<span class="type">Class</span>&#123;</span><br><span class="line">        <span class="type">Title</span>:    <span class="string">&quot;101&quot;</span>,</span><br><span class="line">        <span class="type">Students</span>: make([]*<span class="type">Student</span>, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    for i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        stu := &amp;<span class="type">Student</span>&#123;</span><br><span class="line">            <span class="type">Name</span>:   fmt.<span class="type">Sprintf</span>(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">            <span class="type">Gender</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">            <span class="type">ID</span>:     i,</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="type">Students</span> = append(c.<span class="type">Students</span>, stu)</span><br><span class="line">    &#125;</span><br><span class="line">    //<span class="type">JSON</span>序列化：结构体<span class="comment">--&gt;JSON格式的字符串</span></span><br><span class="line">    <span class="class"><span class="keyword">data</span>, err := json.<span class="type">Marshal</span>(<span class="title">c</span>)</span></span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.<span class="type">Println</span>(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.<span class="type">Printf</span>(<span class="string">&quot;json:%s\n&quot;</span>, <span class="class"><span class="keyword">data</span>)</span></span><br><span class="line">    //<span class="type">JSON</span>反序列化：<span class="type">JSON</span>格式的字符串<span class="comment">--&gt;结构体</span></span><br><span class="line">    str := `&#123;<span class="string">&quot;Title&quot;</span>:<span class="string">&quot;101&quot;</span>,<span class="string">&quot;Students&quot;</span>:[&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">0</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu00&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">1</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu01&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">2</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu02&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">3</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu03&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">4</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu04&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">5</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu05&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">6</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu06&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">7</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu07&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">8</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu08&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">9</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu09&quot;</span>&#125;]&#125;`</span><br><span class="line">    c1 := &amp;<span class="type">Class</span>&#123;&#125;</span><br><span class="line">    err = json.<span class="type">Unmarshal</span>([]byte(str), c1)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.<span class="type">Println</span>(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.<span class="type">Printf</span>(<span class="string">&quot;%#v\n&quot;</span>, c1)&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h4><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:<span class="string">&quot;value1&quot;</span> key2:<span class="string">&quot;value2&quot;</span>`</span><br></pre></td></tr></table></figure><p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。<br>例如我们为Student结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">    Gender <span class="type">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">    name   <span class="type">string</span> <span class="comment">//私有不能被json包访问&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;</span><br><span class="line">        ID:     <span class="number">1</span>,</span><br><span class="line">        Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    data, err := json.Marshal(s1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;女&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="条件语句if"><a href="#条件语句if" class="headerlink" title="条件语句if"></a>条件语句if</h2><p> if 语句 由一个布尔表达式后紧跟一个或多个语句组成。</p><p>Go 编程语言中 if 语句的语法如下：</p><ul><li>可省略条件表达式括号。</li><li>持初始化语句，可定义代码块局部变量。 </li><li>代码块左 括号必须在条件表达式尾部。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">    <span class="regexp">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n := <span class="string">&quot;abc&quot;</span>; x &gt; <span class="number">0</span> &#123;     <span class="regexp">//</span> 初始化语句未必就是定义变量， 如 println(<span class="string">&quot;init&quot;</span>) 也是可以的。</span><br><span class="line">    println(n[<span class="number">2</span>])&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;    <span class="regexp">//</span> 注意 <span class="keyword">else</span> <span class="keyword">if</span> 和 <span class="keyword">else</span> 左大括号位置。</span><br><span class="line">    println(n[<span class="number">1</span>])&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(n[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意：不支持三元操作符(三目运算符) “a &gt; b ? a : b”。</li></ul><p>Go 编程语言中 if…else 语句的语法如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="regexp">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="regexp">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件语句switch"><a href="#条件语句switch" class="headerlink" title="条件语句switch"></a>条件语句switch</h2><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。 Golang switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。</p><p>Go 编程语言中 switch 语句的语法如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        <span class="params">...</span></span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        <span class="params">...</span></span><br><span class="line">    default:</span><br><span class="line">        <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。 您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> grade string <span class="operator">=</span> <span class="string">&quot;B&quot;</span></span><br><span class="line">   <span class="keyword">var</span> marks int <span class="operator">=</span> <span class="number">90</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> marks &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">90</span>: grade <span class="operator">=</span> <span class="string">&quot;A&quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">80</span>: grade <span class="operator">=</span> <span class="string">&quot;B&quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span> : grade <span class="operator">=</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">      <span class="keyword">default</span>: grade <span class="operator">=</span> <span class="string">&quot;D&quot;</span>  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> grade <span class="operator">==</span> <span class="string">&quot;A&quot;</span> :</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;优秀!<span class="subst">\n</span>&quot;</span> )     </span><br><span class="line">      <span class="keyword">case</span> grade <span class="operator">==</span> <span class="string">&quot;B&quot;</span>, grade <span class="operator">==</span> <span class="string">&quot;C&quot;</span> :</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;良好<span class="subst">\n</span>&quot;</span> )      </span><br><span class="line">      <span class="keyword">case</span> grade <span class="operator">==</span> <span class="string">&quot;D&quot;</span> :</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;及格<span class="subst">\n</span>&quot;</span> )      </span><br><span class="line">      <span class="keyword">case</span> grade <span class="operator">==</span> <span class="string">&quot;F&quot;</span>:</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;不及格<span class="subst">\n</span>&quot;</span> )</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;差<span class="subst">\n</span>&quot;</span> )</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.<span class="type">Printf</span>(<span class="string">&quot;你的等级是 %s<span class="subst">\n</span>&quot;</span>, grade )</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优秀!</span><br><span class="line">你的等级是 <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure><h3 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h3><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。<br>Type Switch 语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s)      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s)</span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//写法一：</span></span><br><span class="line">    <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123; <span class="comment">// 带初始化语句</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot; x 的类型 :%T\r\n&quot;</span>, i)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 int 型&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 float64 型&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">float64</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 func(int) 型&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>, <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 bool 或 string 型&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;未知型&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法二</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> j &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法三</span></span><br><span class="line">    <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> k &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;fallthrough&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；</span></span><br><span class="line"><span class="comment">            而如果switch没有表达式，它会匹配true。</span></span><br><span class="line"><span class="comment">            Go里面switch默认相当于每个case最后带有break，</span></span><br><span class="line"><span class="comment">            匹配成功后不会自动向下执行其他case，而是跳出整个switch,</span></span><br><span class="line"><span class="comment">            但是可以使用fallthrough强制执行后面的case代码。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法三</span></span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> m &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法四</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> &#123; <span class="comment">//省略条件表达式，可当 if...else if...else</span></span><br><span class="line">    <span class="keyword">case</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;i &gt; 0 and i &lt; 10&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> n &gt; <span class="number">10</span> &amp;&amp; n &lt; <span class="number">20</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;i &gt; 10 and i &lt; 20&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x 的类型 <span class="symbol">:&lt;nil&gt;</span></span><br><span class="line">fallthrough</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span></span></span><br></pre></td></tr></table></figure><h2 id="条件语句select"><a href="#条件语句select" class="headerlink" title="条件语句select"></a>条件语句select</h2><p>select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。select 是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。<br>Go 编程语言中 select 语句的语法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       <span class="keyword">statement</span>(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       <span class="keyword">statement</span>(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       <span class="keyword">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下描述了 select 语句的语法：</p><ul><li>每个case都必须是一个通信</li><li>所有channel表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行；其他被忽略。</li><li>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。</li><li>否则：<br>  如果有default子句，则执行该语句。<br>  如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</li></ul><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="type">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">no</span> communication</span><br></pre></td></tr></table></figure><p>select可以监听channel的数据流动<br>select的用法与switch语法非常类似，由select开始的一个新的选择块，每个选择条件由case语句来描述<br>与switch语句可以选择任何使用相等比较的条件相比，select由比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select &#123; <span class="regexp">//</span>不停的在这里检测</span><br><span class="line">    case &lt;-chanl : <span class="regexp">//</span>检测有没有数据可以读</span><br><span class="line">    <span class="regexp">//</span>如果chanl成功读取到数据，则进行该case处理语句</span><br><span class="line">    case chan2 &lt;- <span class="number">1</span> : <span class="regexp">//</span>检测有没有可以写</span><br><span class="line">    <span class="regexp">//</span>如果成功向chan2写入数据，则进行该case处理语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span>假如没有default，那么在以上两个条件都不成立的情况下，就会在此阻塞<span class="regexp">//</span>一般default会不写在里面，select中的default子句总是可运行的，因为会很消耗CPU资源</span><br><span class="line">    default:</span><br><span class="line">    <span class="regexp">//</span>如果以上都没有符合条件，那么则进行default处理流程</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在一个select语句中，Go会按顺序从头到尾评估每一个发送和接收的语句。如果其中的任意一个语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。 如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况： ①如果给出了default语句，那么就会执行default的流程，同时程序的执行会从select语句后的语句中恢复。 ②如果没有default语句，那么select语句将被阻塞，直到至少有一个case可以进行下去。</p><h3 id="Golang-select的使用及典型用法"><a href="#Golang-select的使用及典型用法" class="headerlink" title="Golang select的使用及典型用法"></a>Golang select的使用及典型用法</h3><h4 id="超时判断"><a href="#超时判断" class="headerlink" title="超时判断"></a>超时判断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如在下面的场景中，使用全局resChan来接受response，如果时间超过3S,resChan中还没有数据返回，则第二条case将执行</span></span><br><span class="line"><span class="keyword">var</span> resChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">// do requestfunc test() &#123;</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-resChan:</span><br><span class="line">        doData(data)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):</span><br><span class="line">        fmt.Println(<span class="string">&quot;request time out&quot;</span>)</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doData</span><span class="params">(data <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程（协程）中如下：var shouldQuit=make(chan struct&#123;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//loop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...out of the loop</span></span><br><span class="line">    select &#123;</span><br><span class="line">        case &lt;-c.shouldQuit:</span><br><span class="line">            cleanUp()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        default:</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向shouldQuit发送数据通知程序停止运行</span></span><br><span class="line">close(shouldQuit)</span><br></pre></td></tr></table></figure><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断</span></span><br><span class="line">ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)<span class="comment">//...</span></span><br><span class="line">data：=<span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- data:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//做相应操作，比如丢弃data。视需求而定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h2><p>Golang for支持三种循环方式，包括类似 while 的语法。for循环是一个循环控制结构，可以执行指定次数的循环。<br>Go语言的For循环有3中形式，只有其中的一种使用分号。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> init; <span class="keyword">condition</span>; post &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">condition</span> &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br><span class="line">init： 一般为赋值表达式，给控制变量赋初值；</span><br><span class="line"><span class="keyword">condition</span>： 关系表达式或逻辑表达式，循环控制条件；</span><br><span class="line">post： 一般为赋值表达式，给控制变量增量或减量。</span><br><span class="line"><span class="keyword">for</span>语句执行过程如下：</span><br><span class="line">①先对表达式 init 赋初值；</span><br><span class="line">②判别赋值表达式 init 是否满足给定 <span class="keyword">condition</span> 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 <span class="keyword">condition</span>；否则判断 <span class="keyword">condition</span> 的值为假，不满足条件，就终止<span class="keyword">for</span>循环，执行循环体外语句。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, n := <span class="number">0</span>, <span class="built_in">len</span>(s); i &lt; n; i++ &#123; <span class="comment">// 常见的 for 循环，支持初始化语句。</span></span><br><span class="line">    <span class="built_in">println</span>(s[i])&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="built_in">len</span>(s)<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;                <span class="comment">// 替代 while (n &gt; 0) &#123;&#125;</span></span><br><span class="line">    <span class="built_in">println</span>(s[n])        <span class="comment">// 替代 for (; n &gt; 0;) &#123;&#125;</span></span><br><span class="line">    n-- </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;                    <span class="comment">// 替代 while (true) &#123;&#125;</span></span><br><span class="line">    <span class="built_in">println</span>(s)            <span class="comment">// 替代 for (;;) &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要期望编译器能理解你的想法，在初始化语句中计算出全部结果是个好主意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">length</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;call length.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;abcd&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="number">0</span>, length(s); i &lt; n; i++ &#123;     <span class="comment">// 避免多次调用 length 函数。</span></span><br><span class="line">        <span class="built_in">println</span>(i, s[i])</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">call</span> length.</span><br><span class="line"><span class="attribute">0</span> <span class="number">97</span></span><br><span class="line"><span class="attribute">1</span> <span class="number">98</span></span><br><span class="line"><span class="attribute">2</span> <span class="number">99</span></span><br><span class="line"><span class="attribute">3</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>以下为 Go 语言嵌套循环的格式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for <span class="selector-attr">[condition |  ( init; condition; increment ) | Range]</span>&#123;</span><br><span class="line">   for <span class="selector-attr">[condition |  ( init; condition; increment ) | Range]</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">statement</span>(s)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">statement</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>如过循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span>  &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;这是无限循环。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环语句range"><a href="#循环语句range" class="headerlink" title="循环语句range"></a>循环语句range</h2><p>Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">key</span>, value := <span class="built_in">range</span> oldMap &#123;</span><br><span class="line">    newMap[<span class="built_in">key</span>] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>1st value</th><th>2nd value</th><th></th></tr></thead><tbody><tr><td>string</td><td>index</td><td>s[index]</td><td>unicode, rune</td></tr><tr><td>array/slice</td><td>index</td><td>s[index]</td><td></td></tr><tr><td>map</td><td>key</td><td>m[key]</td><td></td></tr><tr><td>channel</td><td>element</td><td></td><td></td></tr></tbody></table><p>可忽略不想要的返回值，或 “ _ “ 这个特殊变量。   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="comment">// 忽略 2nd value，支持 string/array/slice/map。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="built_in">println</span>(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 忽略 index。</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="built_in">println</span>(c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 忽略全部返回值，仅迭代。</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// 返回 (key, value)。</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        <span class="built_in">println</span>(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">97</span></span><br><span class="line"><span class="attribute">98</span></span><br><span class="line"><span class="attribute">99</span></span><br><span class="line"><span class="attribute">97</span></span><br><span class="line"><span class="attribute">98</span></span><br><span class="line"><span class="attribute">99</span></span><br><span class="line"><span class="attribute">a</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">b</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>注意：range 会复制对象。</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">a</span> := <span class="selector-attr">[3]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span>, v := range <span class="selector-tag">a</span> &#123; <span class="comment">// index、value 都是从复制品中取出。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">i</span> == <span class="number">0</span> &#123; <span class="comment">// 在修改前，我们先修改原数组。</span></span><br><span class="line">            <span class="selector-tag">a</span><span class="selector-attr">[1]</span>, <span class="selector-tag">a</span><span class="selector-attr">[2]</span> = <span class="number">999</span>, <span class="number">999</span></span><br><span class="line">            fmt<span class="selector-class">.Println</span>(a) <span class="comment">// 确认修改有效，输出 [0, 999, 999]。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-attr">[i]</span> = v + <span class="number">100</span> <span class="comment">// 使用复制品中取出的 value 修改原数组。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(a) <span class="comment">// 输出 [100, 101, 102]。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0 999 999]</span></span><br><span class="line"><span class="string">[100 101 102]</span></span><br></pre></td></tr></table></figure><p>建议改用引用类型，其底层数据不会被复制。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    s := <span class="selector-attr">[]</span>int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span>, v := range s &#123; <span class="comment">// 复制 struct slice &#123; pointer, len, cap &#125;。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">i</span> == <span class="number">0</span> &#123;</span><br><span class="line">            s = s<span class="selector-attr">[:3]</span>  <span class="comment">// 对 slice 的修改，不会影响 range。</span></span><br><span class="line">            s<span class="selector-attr">[2]</span> = <span class="number">100</span> <span class="comment">// 对底层数据的修改。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println</span>(<span class="selector-tag">i</span>, v)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">100</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br></pre></td></tr></table></figure><p>另外两种引用类型 map、channel 是指针包装，而不像 slice 是 struct。</p><p>for 和 for range有什么区别?主要是使用场景不同<br>for可以</p><ul><li>遍历array和slice</li><li>遍历key为整型递增的map</li><li>遍历string</li></ul><p>for range可以</p><ul><li>完成所有for可以做的事情，却能做到for不能做的，包括遍历key为string类型的map并同时获取key和value</li><li>遍历channel</li></ul><h2 id="循环控制Goto、Break、Continue"><a href="#循环控制Goto、Break、Continue" class="headerlink" title="循环控制Goto、Break、Continue"></a>循环控制Goto、Break、Continue</h2><p>循环控制语句循环控制语句可以控制循环体内语句的执行过程。GO 语言支持以下几种循环控制语句：Goto、Break、Continue</p><ul><li>三个语句都可以配合标签(label)使用</li><li>标签名区分大小写，定以后若不使用会造成编译错误</li><li>continue、break配合标签(label)可用于多层循环跳出</li><li>goto是调整执行位置，与continue、break配合标签(label)的结果并不相同</li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><h3 id="golang函数特点"><a href="#golang函数特点" class="headerlink" title="golang函数特点"></a>golang函数特点</h3><ul><li>无需声明原型</li><li>支持不定变参</li><li>支持多返回值</li><li>支持命名返回参数</li><li>支持匿名函数和闭包</li><li>函数也是一种类型，一个函数可以赋值给变量</li><li>不支持 嵌套 (nested) 一个包不能有两个名字一样的函数</li><li>不支持 重载 (overload) </li><li>不支持 默认参数 (default parameter)</li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明包含一个函数名，参数列表， 返回值列表和函数体。如果函数没有返回值，则返回列表可以省略。函数从第一条语句开始执行，直到执行return语句或者执行函数的最后一条语句。</p><p>函数可以没有参数或接受多个参数。注意类型在变量名之后 。当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。函数可以返回任意数量的返回值。使用关键字 func 定义函数，左大括号依旧不能另起一行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>, s <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="comment">// 类型相同的相邻参数，参数类型可合并。 多返回值必须用括号。</span></span><br><span class="line">    n := x + y          </span><br><span class="line">    <span class="keyword">return</span> n, fmt.Sprintf(s, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是第一类对象，可作为参数传递。建议将复杂签名定义为函数类型，以便于阅读。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(fn <span class="keyword">func</span>()</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn()&#125;<span class="comment">// 定义函数类型。type FormatFunc func(s string, x, y int) string </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(fn FormatFunc, s <span class="type">string</span>, x, y <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(s, x, y)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := test(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">100</span> &#125;) <span class="comment">// 直接将匿名函数当参数。</span></span><br><span class="line"></span><br><span class="line">    s2 := format(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>, x, y <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(s, x, y)</span><br><span class="line">    &#125;, <span class="string">&quot;%d, %d&quot;</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(s1, s2)&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">100 </span><span class="number">10</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><p>有返回值的函数，必须有明确的终止语句，否则会引发编译错误。你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="type">float64</span>)</span></span> float <span class="comment">//implemented in assembly language</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数定义时指出，函数定义时有参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量。但当调用函数，传递过来的变量就是函数的实参，函数可以通过两种方式来传递参数：值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    temp = *x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">    *x = *y   <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">    *y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用 swap() 函数</span></span><br><span class="line"><span class="comment">        &amp;a 指向 a 指针，a 变量的地址</span></span><br><span class="line"><span class="comment">        &amp;b 指向 b 指针，b 变量的地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line">    fmt.Println(a, b)&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>在默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p><p><strong>注意1：无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。<br>注意2：map、slice、chan、指针、interface默认以引用的方式传递。</strong></p><p>不定参数传值 就是函数的参数不是固定的，后面的类型是固定的。（可变参数）Golang 可变参数本质上就是 slice。只能有一个，且必须是最后一个。在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="type">int</span>)</span></span> &#123;    <span class="comment">//0个或多个参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, args…<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;    <span class="comment">//1个或多个参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>, args…<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;    <span class="comment">//2个或多个参数</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：其中args是一个slice，我们可以通过arg[index]依次访问所有参数,通过len(arg)来判断传递参数的个数.</p><p>任意类型的不定参数： 就是函数的参数和每个参数的类型都不是固定的。用interface{}传递任意类型数据是Go语言的惯例用法，而且interface{}是类型安全的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">myfunc</span>(<span class="params">args ...<span class="keyword">interface</span>&#123;&#125;</span>) &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="type">string</span>, n ...<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</span><br><span class="line">        x += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(s, x)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(test(<span class="string">&quot;sum: %d&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sum</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure><p>使用 slice 对象做变参时，必须展开。（slice…）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="type">string</span>, n ...<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</span><br><span class="line">        x += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(s, x)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    res := test(<span class="string">&quot;sum: %d&quot;</span>, s...)    <span class="comment">// slice... 展开slice</span></span><br><span class="line">    <span class="built_in">println</span>(res)&#125;</span><br></pre></td></tr></table></figure><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>“ _ “标识符，用来忽略函数的某个返回值<br>Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。<br>返回值的名称应当具有一定的意义，可以作为文档使用。<br>没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。<br>直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p><p>Golang返回值不能用容器对象接收多返回值。只能用多个变量，或 “_ “ 忽略。</p><p>多返回值可直接作为其他函数调用实参。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</span><br><span class="line">        x += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(test()))</span><br><span class="line">    <span class="built_in">println</span>(sum(test()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>命名返回参数可看做与形参类似的局部变量，最后由 return 隐式返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>命名返回参数可被同名局部变量遮蔽，此时需要显式返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    &#123; <span class="comment">// 不能在一个级别，引发 &quot;z redeclared in this block&quot; 错误。</span></span><br><span class="line">        <span class="keyword">var</span> z = x + y</span><br><span class="line">        <span class="comment">// return   // Error: z is shadowed during return</span></span><br><span class="line">        <span class="keyword">return</span> z <span class="comment">// 必须显式返回。</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>命名返回参数允许 defer 延迟调用通过闭包读取和修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        z += <span class="number">100</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">103</span><br></pre></td></tr></table></figure><p>显式 return 返回前，会先修改命名返回参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(z) <span class="comment">// 输出: 203</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> z + <span class="number">200</span> <span class="comment">// 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (return)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 输出: 203&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">203</span><br><span class="line">203</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数是指不需要定义函数名的一种函数实现方式。1958年LISP首先采用匿名函数。<br>在Go里面，函数可以像普通变量一样被传递或使用，Go语言支持随时在代码里定义匿名函数。匿名函数由一个不带函数名的函数声明和函数体组成。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    getSqrt := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(a)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(getSqrt(<span class="number">4</span>))&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>上面先定义了一个名为getSqrt 的变量，初始化该变量时和之前的变量初始化有些不同，使用了func，func是定义函数的，可是这个函数和上面说的函数最大不同就是没有函数名，也就是匿名函数。这里将一个函数当做一个变量一样的操作。</p><p>Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// --- function variable ---</span></span><br><span class="line">    fn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;Hello, World!&quot;</span>) &#125;</span><br><span class="line">    fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- function collection ---</span></span><br><span class="line">    fns := [](<span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + <span class="number">2</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(fns[<span class="number">0</span>](<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- function as field ---</span></span><br><span class="line">    d := <span class="keyword">struct</span> &#123;</span><br><span class="line">        fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        fn: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(d.fn())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- channel of function ---</span></span><br><span class="line">    fc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    fc &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;</span><br><span class="line">    <span class="built_in">println</span>((&lt;-fc)())</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> World!</span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="built_in">Hello,</span> World!</span><br><span class="line"><span class="built_in">Hello,</span> World!</span><br></pre></td></tr></table></figure><h2 id="闭包、递归"><a href="#闭包、递归" class="headerlink" title="闭包、递归"></a>闭包、递归</h2><h3 id="闭包详解"><a href="#闭包详解" class="headerlink" title="闭包详解"></a>闭包详解</h3><p>闭包的应该都听过，但到底什么是闭包呢？<br>闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。<br>“官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    b := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := a()</span><br><span class="line">    c()</span><br><span class="line">    c()</span><br><span class="line">    c()</span><br><span class="line"></span><br><span class="line">    a() <span class="comment">//不会输出i&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>闭包复制的是原对象指针，这就很容易解释延迟引用现象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;x (%p) = %d\n&quot;</span>, &amp;x, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x (%p) = %d\n&quot;</span>, &amp;x, x)</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := test()</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span> (<span class="number">0</span>xc42007c008) = <span class="number">100</span></span><br><span class="line"><span class="attribute">x</span> (<span class="number">0</span>xc42007c008) = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>在汇编层 ，test 实际返回的是 FuncVal 对象，其中包含了匿名函数地址、闭包对象指针。当调匿名函数时，只需以某个寄存器传递该对象即可。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">FuncVal </span><span class="template-variable">&#123; func_address, closure_var_pointer ... &#125;</span></span><br></pre></td></tr></table></figure><p>外部引用函数参数局部变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用函数参数局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(base <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        base += i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tmp1 := add(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(tmp1(<span class="number">1</span>), tmp1(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 此时tmp1和tmp2不是一个实体了</span></span><br><span class="line">    tmp2 := add(<span class="number">100</span>)</span><br><span class="line">    fmt.Println(tmp2(<span class="number">1</span>), tmp2(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时可以返回多个闭包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回2个函数类型的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义2个函数，并返回</span></span><br><span class="line">    <span class="comment">// 相加</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        base += i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相减</span></span><br><span class="line">    sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        base -= i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f1, f2 := test01(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// base一直是没有消</span></span><br><span class="line">    fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 此时base是9</span></span><br><span class="line">    fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-语言递归函数"><a href="#Go-语言递归函数" class="headerlink" title="Go 语言递归函数"></a>Go 语言递归函数</h3><p>斐波那契数列(Fibonacci)：</p><p>这个数列从第3项开始，每一项都等于前两项之和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonaci</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonaci(i<span class="number">-1</span>) + fibonaci(i<span class="number">-2</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, fibonaci(i))</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟调用（defer）"><a href="#延迟调用（defer）" class="headerlink" title="延迟调用（defer）"></a>延迟调用（defer）</h2><h3 id="Golang延迟调用"><a href="#Golang延迟调用" class="headerlink" title="Golang延迟调用"></a>Golang延迟调用</h3><h4 id="defer特性"><a href="#defer特性" class="headerlink" title="defer特性"></a>defer特性</h4><ol><li>关键字 defer 用于注册延迟调用。</li><li>这些调用直到 return 前才被执。因此，可以用来做资源清理。</li><li>多个defer语句，按先进后出的方式执行。</li><li>defer语句中的变量，在defer声明时就决定了。</li></ol><h4 id="defer用途"><a href="#defer用途" class="headerlink" title="defer用途"></a>defer用途</h4><ol><li>关闭文件句柄</li><li>锁资源释放</li><li>数据库连接释放</li></ol><p>go 语言的defer功能强大，对于资源管理非常方便，但是如果没用好，也会有陷阱。defer 是先进后出这个很自然,后面的语句会依赖前面的资源，因此如果先前面的资源先释放了，后面的语句就没法执行了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="defer-碰上闭包"><a href="#defer-碰上闭包" class="headerlink" title="defer 碰上闭包"></a>defer 碰上闭包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(i) &#125;()</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>其实go说的很清楚,我们一起来看看go spec如何说的</p><blockquote><p>Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usualand saved anew but the actual function is not invoked.</p></blockquote><p>也就是说函数正常执行,由于闭包用到的变量 i 在执行的时候已经变成4,所以输出全都是4.</p><h4 id="defer-f-Close"><a href="#defer-f-Close" class="headerlink" title="defer f.Close"></a>defer f.Close</h4><p>这个大家用的都很频繁,但是go语言编程举了一个可能一不小心会犯错的例子.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span></span> Close() &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">&quot; closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        <span class="keyword">defer</span> t.Close()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c  <span class="keyword">closed</span></span><br><span class="line">c  <span class="keyword">closed</span></span><br><span class="line">c  <span class="keyword">closed</span></span><br></pre></td></tr></table></figure><p>这个输出并不会像我们预计的输出c b a,而是输出c c c可是按照前面的go spec中的说明,应该输出c b a才对啊.那我们换一种方式来调用一下.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span></span> Close() &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">&quot; closed&quot;</span>)&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Close</span><span class="params">(t Test)</span></span> &#123;</span><br><span class="line">    t.Close()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        <span class="keyword">defer</span> Close(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c  <span class="keyword">closed</span></span><br><span class="line">b  <span class="keyword">closed</span></span><br><span class="line">a  <span class="keyword">closed</span></span><br></pre></td></tr></table></figure><p>当然,如果你不想多写一个函数,也很简单,可以像下面这样,同样会输出c b a看似多此一举的声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span></span> Close() &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">&quot; closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        t2 := t</span><br><span class="line">        <span class="keyword">defer</span> t2.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c  <span class="keyword">closed</span></span><br><span class="line">b  <span class="keyword">closed</span></span><br><span class="line">a  <span class="keyword">closed</span></span><br></pre></td></tr></table></figure><p>可以得出下面的结论：defer后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。但是并没有说struct这里的this指针如何处理，通过这个例子可以看出go语言并没有把这个明确写出来的this指针当作参数来看待。多个 defer 注册，按 FILO 次序执行 ( 先进后出 )。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="number">100</span> / x) <span class="comment">// div0 异常未被捕获，逐步往外传递，最终终止进程。</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">b</span><br><span class="line"><span class="keyword">a</span></span><br><span class="line">panic: runtime error: <span class="keyword">integer</span> <span class="built_in">divide</span> <span class="keyword">by</span> <span class="literal">zero</span></span><br></pre></td></tr></table></figure><p>延迟调用参数在注册时求值或复制，可用指针或闭包 “延迟” 读取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;defer:&quot;</span>, i, y) <span class="comment">// y 闭包引用</span></span><br><span class="line">    &#125;(x) <span class="comment">// x 被复制</span></span><br><span class="line"></span><br><span class="line">    x += <span class="number">10</span></span><br><span class="line">    y += <span class="number">100</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;x =&quot;</span>, x, <span class="string">&quot;y =&quot;</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span> = <span class="number">20</span> y = <span class="number">120</span></span><br><span class="line"><span class="attribute">defer</span>: <span class="number">10</span> <span class="number">120</span></span><br></pre></td></tr></table></figure><p>滥用 defer 可能会导致性能问题，尤其是在一个 “大循环” 里。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> lock sync<span class="selector-class">.Mutex</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">test</span>() &#123;</span><br><span class="line">    lock<span class="selector-class">.Lock</span>()</span><br><span class="line">    lock<span class="selector-class">.Unlock</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">testdefer</span>() &#123;</span><br><span class="line">    lock<span class="selector-class">.Lock</span>()</span><br><span class="line">    defer lock<span class="selector-class">.Unlock</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="built_in">func</span>() &#123;</span><br><span class="line">        t1 := time.<span class="built_in">Now</span>()</span><br><span class="line"></span><br><span class="line">        for i := <span class="number">0</span>; <span class="selector-tag">i</span> &lt; <span class="number">10000</span>; <span class="selector-tag">i</span>++ &#123;</span><br><span class="line">            <span class="built_in">test</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        elapsed := time.<span class="built_in">Since</span>(t1)</span><br><span class="line">        fmt.<span class="built_in">Println</span>(<span class="string">&quot;test elapsed: &quot;</span>, elapsed)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">func</span>() &#123;</span><br><span class="line">        t1 := time.<span class="built_in">Now</span>()</span><br><span class="line"></span><br><span class="line">        for i := <span class="number">0</span>; <span class="selector-tag">i</span> &lt; <span class="number">10000</span>; <span class="selector-tag">i</span>++ &#123;</span><br><span class="line">            <span class="built_in">testdefer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        elapsed := time.<span class="built_in">Since</span>(t1)</span><br><span class="line">        fmt.<span class="built_in">Println</span>(<span class="string">&quot;testdefer elapsed: &quot;</span>, elapsed)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>elapsed:  223.162µs</span><br><span class="line">testdefer elapsed:  781.304µs</span><br></pre></td></tr></table></figure><h4 id="defer陷阱"><a href="#defer陷阱" class="headerlink" title="defer陷阱"></a>defer陷阱</h4><h5 id="defer-与-closure"><a href="#defer-与-closure" class="headerlink" title="defer 与 closure"></a>defer 与 closure</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a, b <span class="type">int</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;first defer err %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(err <span class="type">error</span>)</span></span> &#123; fmt.Printf(<span class="string">&quot;second defer err %v\n&quot;</span>, err) &#125;(err)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;third defer err %v\n&quot;</span>, err) &#125;()</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        err = errors.New(<span class="string">&quot;divided by zero!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = a / b</span><br><span class="line">    <span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo(<span class="number">2</span>, <span class="number">0</span>)&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">third <span class="keyword">defer</span> err divided by zero!</span><br><span class="line">second <span class="keyword">defer</span> err &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">first <span class="keyword">defer</span> err &lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure><p>解释：如果 defer 后面跟的不是一个 closure 最后执行的时候我们得到的并不是最新的值。</p><h5 id="defer-与-return"><a href="#defer-与-return" class="headerlink" title="defer 与 return"></a>defer 与 return</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>解释：在有具名返回值的函数中（这里具名返回值为 i），执行 return 2 的时候实际上已经将 i 的值重新赋值为 2。所以defer closure 输出结果为 2 而不是 1。</p><h5 id="defer-nil-函数"><a href="#defer-nil-函数" class="headerlink" title="defer nil 函数"></a>defer nil 函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> run <span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">defer</span> run()</span><br><span class="line">    fmt.Println(<span class="string">&quot;runs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runs</span><br><span class="line">runtime <span class="type">error</span>: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure><p>解释：名为 test 的函数一直运行至结束，然后 defer 函数会被执行且会因为值为 nil 而产生 panic 异常。然而值得注意的是，run() 的声明是没有问题，因为在test函数运行完成后它才会被调用。</p><h5 id="在错误的位置使用-defer"><a href="#在错误的位置使用-defer" class="headerlink" title="在错误的位置使用 defer"></a>在错误的位置使用 defer</h5><p>当 http.Get 失败时会抛出异常。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    res, err := http.Get(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure><p>因为在这里我们并没有检查我们的请求是否成功执行，当它失败的时候，我们访问了 Body 中的空变量 res ，因此会抛出异常</p><p><strong>解决方案：</strong></p><p>总是在一次成功的资源分配下面使用 defer ，对于这种情况来说意味着：当且仅当 http.Get 成功执行时才使用 defer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    res, err := http.Get(<span class="string">&quot;http://xxxxxxxxxx&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的代码中，当有错误的时候，err 会被返回，否则当整个函数返回的时候，会关闭 res.Body 。<br>解释：在这里，你同样需要检查 res 的值是否为 nil ，这是 http.Get 中的一个警告。通常情况下，出错的时候，返回的内容应为空并且错误会被返回，可当你获得的是一个重定向 error 时， res 的值并不会为 nil ，但其又会将错误返回。上面的代码保证了无论如何 Body 都会被关闭，如果你没有打算使用其中的数据，那么你还需要丢弃已经接收的数据。</p><h5 id="不检查错误"><a href="#不检查错误" class="headerlink" title="不检查错误"></a>不检查错误</h5><p>在这里，f.Close() 可能会返回一个错误，可这个错误会被我们忽略掉。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">&quot;book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再改进一下通过命名的返回变量来返回 defer 内的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">&quot;book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ferr := f.Close(); ferr != <span class="literal">nil</span> &#123;</span><br><span class="line">                err = ferr</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放相同的资源如果你尝试使用相同的变量释放不同的资源，那么这个操作可能无法正常执行。</p><p>当延迟函数执行时，只有最后一个变量会被用到，因此，f 变量 会成为最后那个资源 (another-book.txt)。而且两个 defer 都会将这个资源作为最后的资源来关闭解决方案：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">&quot;book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(f io.Closer)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;defer close book.txt err %v\n&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    f, err = os.Open(<span class="string">&quot;another-book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(f io.Closer)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;defer close another-book.txt err %v\n&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。异常的使用场景简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</p><p><strong>panic：</strong></p><ol><li>内置函数</li><li>假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行</li><li>返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行</li><li>直到goroutine整个退出，并报告错误</li></ol><p><strong>recover：</strong></p><ol><li>内置函数</li><li>用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</li><li>一般的调用建议<pre><code> a). 在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行 b). 可以获取通过panic传递的error</code></pre></li></ol><p>注意:</p><ol><li>利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。否则当panic时，recover无法捕获到panic，无法防止panic扩散。</li><li>recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。</li><li>多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(err.(<span class="type">string</span>)) <span class="comment">// 将 interface&#123;&#125; 转型为具体类型。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic error!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span> <span class="type">error</span>!</span><br></pre></td></tr></table></figure><p>由于 panic、recover 参数类型为 interface{}，因此可抛出任何类型对象。</p><p>向已关闭的通道发送数据会引发panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">send</span> <span class="keyword">on</span> <span class="title">closed</span> <span class="title">channel</span></span><br></pre></td></tr></table></figure><p>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="built_in">panic</span></span><br></pre></td></tr></table></figure><p>捕获函数 recover 只有在延迟调用内直接调用才会终止错误，否则总是返回 nil。任何未捕获的错误都会沿调用堆栈向外传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>()) <span class="comment">//有效</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">recover</span>()              <span class="comment">//无效！</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="built_in">recover</span>()) <span class="comment">//无效！</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;defer inner&quot;</span>)</span><br><span class="line">            <span class="built_in">recover</span>() <span class="comment">//无效！</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defer inner</span><br><span class="line">&lt;nil&gt;</span><br><span class="line"><span class="keyword">test </span>panic</span><br></pre></td></tr></table></figure><p>使用延迟匿名函数或下面这样都是有效的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">except</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> except()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>panic</span><br></pre></td></tr></table></figure><p>如果需要保护代码段，可将代码块重构成匿名函数，如此可确保后续代码被执 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">                z = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">        z = x / y</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;x / y = %d\n&quot;</span>, z)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x / y <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>除用 panic 引发中断性错误外，还可返回 error 类型错误对象来表示函数调用状态。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type <span class="built_in">error</span><span class="built_in"> interface </span>&#123;</span><br><span class="line">    <span class="built_in">Error</span>() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库 errors.New 和 fmt.Errorf 函数用于创建实现 error 接口的错误对象。通过判断错误对象实例来确定具体错误类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrDivByZero = errors.New(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrDivByZero</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x / y, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">switch</span> z, err := div(<span class="number">10</span>, <span class="number">0</span>); err &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="built_in">println</span>(z)</span><br><span class="line">    <span class="keyword">case</span> ErrDivByZero:</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">division </span><span class="keyword">by </span><span class="built_in">zero</span></span><br></pre></td></tr></table></figure><p>Go实现类似 try catch 的异常处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Try</span><span class="params">(fun <span class="keyword">func</span>()</span></span>, handler <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            handler(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Try(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>panic</span><br></pre></td></tr></table></figure><p>惯例是:导致关键流程出现不可修复性错误的使用 panic，其他使用 error。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。</p><ul><li>只能为当前包内命名类型定义方法。</li><li>参数 receiver 可任意命名。如方法中未曾使用 ，可省略参数名。</li><li>参数 receiver 类型可以是 T 或 * T。基类型 T 不能是接口或指针。</li><li>不支持方法重载，receiver 只是参数签名的组成部分。</li><li>可用实例 value 或 pointer 调用全部方法，编译器自动转换。</li></ul><p>一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。</p><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func</span> (recevier <span class="keyword">type</span>) methodName(参数列表)(返回值列表)&#123;&#125;</span><br><span class="line"></span><br><span class="line">参数和返回值可以省略</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">type Test struct&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、无返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method0</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单参数、无返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method1</span>(i int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数、无返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method2</span>(x, y int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、单返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method3</span>() (i int) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数、多返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method4</span>(x, y int) (z int, err error) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、无返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method5</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单参数、无返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method6</span>(i int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数、无返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method7</span>(x, y int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、单返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method8</span>() (i int) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数、多返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method9</span>(x, y int) (z int, err error) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>下面定义一个结构体类型和该类型的一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> Notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v : %v \n&quot;</span>, u.Name, u.Email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 值类型调用方法</span></span><br><span class="line">    u1 := User&#123;<span class="string">&quot;golang&quot;</span>, <span class="string">&quot;golang@golang.com&quot;</span>&#125;</span><br><span class="line">    u1.Notify()</span><br><span class="line">    <span class="comment">// 指针类型调用方法</span></span><br><span class="line">    u2 := User&#123;<span class="string">&quot;go&quot;</span>, <span class="string">&quot;go@go.com&quot;</span>&#125;</span><br><span class="line">    u3 := &amp;u2</span><br><span class="line">    u3.Notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">golang : golang@golang.com </span><br><span class="line"><span class="keyword">go</span> : <span class="keyword">go</span>@<span class="keyword">go</span>.com</span><br></pre></td></tr></table></figure><p>解释： 首先我们定义了一个叫做 User 的结构体类型，然后定义了一个该类型的方法叫做 Notify，该方法的接受者是一个 User 类型的值。要调用 Notify 方法我们需要一个 User 类型的值或者指针。</p><p>在这个例子中当我们使用指针时，Go 调整和解引用指针使得调用可以被执行。注意，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。</p><p>我们修改 Notify 方法，让它的接受者使用指针类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> Notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v : %v \n&quot;</span>, u.Name, u.Email)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 值类型调用方法</span></span><br><span class="line">    u1 := User&#123;<span class="string">&quot;golang&quot;</span>, <span class="string">&quot;golang@golang.com&quot;</span>&#125;</span><br><span class="line">    u1.Notify()</span><br><span class="line">    <span class="comment">// 指针类型调用方法</span></span><br><span class="line">    u2 := User&#123;<span class="string">&quot;go&quot;</span>, <span class="string">&quot;go@go.com&quot;</span>&#125;</span><br><span class="line">    u3 := &amp;u2</span><br><span class="line">    u3.Notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">golang : golang@golang.com </span><br><span class="line"><span class="keyword">go</span> : <span class="keyword">go</span>@<span class="keyword">go</span>.com</span><br></pre></td></tr></table></figure><p>注意：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作。</p><p>方法不过是一种特殊的函数，只需将其还原，就知道 receiver T 和 * T 的差别。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">type Data struct &#123;</span><br><span class="line">    x int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self Data) <span class="built_in">ValueTest</span>() &#123; <span class="comment">// func ValueTest(self Data);</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;Value: %p\n&quot;</span>, &amp;self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Data) <span class="built_in">PointerTest</span>() &#123; <span class="comment">// func PointerTest(self *Data);</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;Pointer: %p\n&quot;</span>, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    d := Data&#123;&#125;</span><br><span class="line">    <span class="selector-tag">p</span> := &amp;d</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;Data: %p\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    d<span class="selector-class">.ValueTest</span>()   <span class="comment">// ValueTest(d)</span></span><br><span class="line">    d<span class="selector-class">.PointerTest</span>() <span class="comment">// PointerTest(&amp;d)</span></span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.ValueTest</span>()   <span class="comment">// ValueTest(*p)</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.PointerTest</span>() <span class="comment">// PointerTest(p)&#125;</span></span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Data</span>: <span class="number">0</span>xc42007c008</span><br><span class="line"><span class="attribute">Value</span>: <span class="number">0</span>xc42007c018</span><br><span class="line"><span class="attribute">Pointer</span>: <span class="number">0</span>xc42007c008</span><br><span class="line"><span class="attribute">Value</span>: <span class="number">0</span>xc42007c020</span><br><span class="line"><span class="attribute">Pointer</span>: <span class="number">0</span>xc42007c008</span><br></pre></td></tr></table></figure><h3 id="普通函数与方法的区别"><a href="#普通函数与方法的区别" class="headerlink" title="普通函数与方法的区别"></a>普通函数与方法的区别</h3><ol><li>对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。</li><li>对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数与方法的区别（在接收者分别为值类型和指针类型的时候）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.普通函数//接收值类型参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">valueIntTest</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收指针类型参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pointerIntTest</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structTestValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">2</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;valueIntTest:&quot;</span>, valueIntTest(a))</span><br><span class="line">    <span class="comment">//函数的参数为值类型，则不能直接将指针作为参数传递</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;valueIntTest:&quot;, valueIntTest(&amp;a))</span></span><br><span class="line">    <span class="comment">//compile error: cannot use &amp;a (type *int) as type int in function argument</span></span><br><span class="line"></span><br><span class="line">    b := <span class="number">5</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;pointerIntTest:&quot;</span>, pointerIntTest(&amp;b))</span><br><span class="line">    <span class="comment">//同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(b))</span></span><br><span class="line">    <span class="comment">//compile error:cannot use b (type int) as type *int in function argument&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.方法</span></span><br><span class="line"><span class="keyword">type</span> PersonD <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者为值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PersonD)</span></span> valueShowName() &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者为指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PersonD)</span></span> pointShowName() &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structTestFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//值类型调用方法</span></span><br><span class="line">    personValue := PersonD&#123;<span class="number">101</span>, <span class="string">&quot;hello world&quot;</span>&#125;</span><br><span class="line">    personValue.valueShowName()</span><br><span class="line">    personValue.pointShowName()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针类型调用方法</span></span><br><span class="line">    personPointer := &amp;PersonD&#123;<span class="number">102</span>, <span class="string">&quot;hello golang&quot;</span>&#125;</span><br><span class="line">    personPointer.valueShowName()</span><br><span class="line">    personPointer.pointShowName()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与普通函数不同，接收者为指针类型和值类型的方法，指针类型和值类型的变量均可相互调用&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    structTestValue()</span><br><span class="line">    structTestFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">valueIntTest</span>: <span class="number">12</span></span><br><span class="line"><span class="attribute">pointerIntTest</span>: <span class="number">15</span></span><br><span class="line"><span class="attribute">hello</span> world</span><br><span class="line"><span class="attribute">hello</span> world</span><br><span class="line"><span class="attribute">hello</span> golang</span><br><span class="line"><span class="attribute">hello</span> golang</span><br></pre></td></tr></table></figure><h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>Golang匿名字段 ：可以像字段成员那样访问匿名字段方法，编译器负责查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span></span> ToString() <span class="type">string</span> &#123; <span class="comment">// receiver = &amp;(Manager.User)</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Manager: %p\n&quot;</span>, &amp;m)</span><br><span class="line">    fmt.Println(m.ToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Manager</span>: <span class="number">0</span>xc42000a060</span><br><span class="line"><span class="attribute">User</span>: <span class="number">0</span>xc42000a060, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure><p>通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User</span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span></span> ToString() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Manager)</span></span> ToString() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Manager: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;, <span class="string">&quot;Administrator&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.ToString())</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.User.ToString())&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">Manager: 0xc420074180, &amp;</span><span class="template-variable">&#123;&#123;<span class="name">1</span> Tom&#125; Administrator&#125;</span></span><br><span class="line"><span class="template-variable">User: <span class="number">0</span>xc420074180, &amp;&#123;<span class="number">1</span> Tom&#125;</span></span><br></pre></td></tr></table></figure><h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>Golang方法集 ：每个类型都有与之关联的方法集，这会影响到接口实现规则。</p><ul><li>类型 T 方法集包含全部 receiver T 方法。</li><li>类型 * T 方法集包含全部 receiver T + * T 方法。</li><li>如类型 S 包含匿名字段 T，则 S 和 * S 方法集包含 T 方法。 </li><li>如类型 S 包含匿名字段 * T，则 S 和 * S 方法集包含 T + * T 方法。</li><li>不管嵌入 T 或 * T，* S 方法集总是包含 T + * T 方法。</li></ul><p>用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。</p><p>Go 语言中内部类型方法集提升的规则：类型 T 方法集包含全部 receiver T 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> test() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型 T 方法集包含全部 receiver T 方法。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := T&#123;<span class="number">1</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;t1 is : %v\n&quot;</span>, t1)</span><br><span class="line">    t1.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 <span class="keyword">is</span> : &#123;1&#125;</span><br><span class="line">类型 T 方法集包含全部 receiver T 方法。</span><br></pre></td></tr></table></figure><p>类型 * T 方法集包含全部 receiver T + * T 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> testT() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型 *T 方法集包含全部 receiver T 方法。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> testP() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型 *T 方法集包含全部 receiver *T 方法。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := T&#123;<span class="number">1</span>&#125;</span><br><span class="line">    t2 := &amp;t1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;t2 is : %v\n&quot;</span>, t2)</span><br><span class="line">    t2.testT()</span><br><span class="line">    t2.testP()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">t2</span> is <span class="symbol">:</span> &amp;&#123;<span class="number">1</span>&#125;</span><br><span class="line">类型 *<span class="built_in">T</span> 方法集包含全部 receiver <span class="built_in">T</span> 方法。</span><br><span class="line">类型 *<span class="built_in">T</span> 方法集包含全部 receiver *<span class="built_in">T</span> 方法。</span><br></pre></td></tr></table></figure><p>给定一个结构体类型 S 和一个命名为 T 的类型，方法提升像下面规定的这样被包含在结构体方法集中：<br>如类型 S 包含匿名字段 T，则 S 和 * S 方法集包含 T 方法。<br>这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为值类型的方法将被提升，可以被外部类型的值和指针调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> testT() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := S&#123;T&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">    s2 := &amp;s1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s1 is : %v\n&quot;</span>, s1)</span><br><span class="line">    s1.testT()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s2 is : %v\n&quot;</span>, s2)</span><br><span class="line">    s2.testT()&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">s1 is : </span><span class="template-variable">&#123;&#123;<span class="name">1</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</span></span><br><span class="line"><span class="language-xml">s2 is : &amp;</span><span class="template-variable">&#123;&#123;<span class="name">1</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</span></span><br></pre></td></tr></table></figure><p>如类型 S 包含匿名字段 * T，则 S 和 * S 方法集包含 T + * T 方法。</p><p>这条规则说的是当我们嵌入一个类型的指针，嵌入类型的接受者为值类型或指针类型的方法将被提升，可以被外部类型的值或者指针调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> testT() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> testP() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := S&#123;T&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">    s2 := &amp;s1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s1 is : %v\n&quot;</span>, s1)</span><br><span class="line">    s1.testT()</span><br><span class="line">    s1.testP()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s2 is : %v\n&quot;</span>, s2)</span><br><span class="line">    s2.testT()</span><br><span class="line">    s2.testP()&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">s1</span> is <span class="symbol">:</span> &#123;&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">如类型 S 包含匿名字段 *<span class="built_in">T</span>，则 S 和 *S 方法集包含 <span class="built_in">T</span> 方法</span><br><span class="line">如类型 S 包含匿名字段 *<span class="built_in">T</span>，则 S 和 *S 方法集包含 *<span class="built_in">T</span> 方法</span><br><span class="line"><span class="symbol">s2</span> is <span class="symbol">:</span> &amp;&#123;&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">如类型 S 包含匿名字段 *<span class="built_in">T</span>，则 S 和 *S 方法集包含 <span class="built_in">T</span> 方法</span><br><span class="line">如类型 S 包含匿名字段 *<span class="built_in">T</span>，则 S 和 *S 方法集包含 *<span class="built_in">T</span> 方法</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>Golang 表达式 ：根据调用者不同，方法分为两种表现形式:</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">instance</span>.method(args...) ---&gt; &lt;<span class="keyword">type</span>&gt;.<span class="keyword">func</span>(<span class="keyword">instance</span>, args...)</span><br></pre></td></tr></table></figure><p>前者称为 method value，后者 method expression。<br>两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span></span> Test() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">    u.Test()</span><br><span class="line"></span><br><span class="line">    mValue := u.Test</span><br><span class="line">    mValue() <span class="comment">// 隐式传递 receiver</span></span><br><span class="line"></span><br><span class="line">    mExpression := (*User).Test</span><br><span class="line">    mExpression(&amp;u) <span class="comment">// 显式传递 receiver&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>xc42000a060, <span class="meta">&amp;&#123;1 Tom&#125;</span></span><br><span class="line"><span class="number">0</span>xc42000a060, <span class="meta">&amp;&#123;1 Tom&#125;</span></span><br><span class="line"><span class="number">0</span>xc42000a060, <span class="meta">&amp;&#123;1 Tom&#125;</span></span><br></pre></td></tr></table></figure><p>需要注意，method value 会复制 receiver。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self User)</span></span> Test() &#123;</span><br><span class="line">    fmt.Println(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">    mValue := u.Test <span class="comment">// 立即复制 receiver，因为不是指针类型，不受后续修改影响。</span></span><br><span class="line"></span><br><span class="line">    u.id, u.name = <span class="number">2</span>, <span class="string">&quot;Jack&quot;</span></span><br><span class="line">    u.Test()</span><br><span class="line"></span><br><span class="line">    mValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;2 Jack&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-variable">&#123;1 Tom&#125;</span></span><br></pre></td></tr></table></figure><p>在汇编层面，method value 和闭包的实现方式相同，实际返回 FuncVal 类型对象。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">FuncVal </span><span class="template-variable">&#123; method_address, receiver_copy &#125;</span></span><br></pre></td></tr></table></figure><p>可依据方法集转换 method expression，注意 receiver 类型的差异。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span></span> TestPointer() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;TestPointer: %p, %v\n&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self User)</span></span> TestValue() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;TestValue: %p, %v\n&quot;</span>, &amp;self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;User: %p, %v\n&quot;</span>, &amp;u, u)</span><br><span class="line"></span><br><span class="line">    mv := User.TestValue</span><br><span class="line">    mv(u)</span><br><span class="line"></span><br><span class="line">    mp := (*User).TestPointer</span><br><span class="line">    mp(&amp;u)</span><br><span class="line"></span><br><span class="line">    mp2 := (*User).TestValue <span class="comment">// *User 方法集包含 TestValue。签名变为 func TestValue(self *User)。实际依然是 receiver value copy。</span></span><br><span class="line">    mp2(&amp;u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User</span>: <span class="number">0</span>xc42000a060, &#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="attribute">TestValue</span>: <span class="number">0</span>xc42000a0a0, &#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="attribute">TestPointer</span>: <span class="number">0</span>xc42000a060, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="attribute">TestValue</span>: <span class="number">0</span>xc42000a100, &#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure><p>将方法 “还原” 成函数，就容易理解下面的代码了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Data)</span></span> TestValue() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Data)</span></span> TestPointer() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *Data = <span class="literal">nil</span></span><br><span class="line">    p.TestPointer()</span><br><span class="line"></span><br><span class="line">    (*Data)(<span class="literal">nil</span>).TestPointer() <span class="comment">// method value</span></span><br><span class="line">    (*Data).TestPointer(<span class="literal">nil</span>)   <span class="comment">// method expression</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p.TestValue()            // invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Data)(nil).TestValue()  // cannot convert nil to type Data</span></span><br><span class="line">    <span class="comment">// Data.TestValue(nil)      // cannot use nil as type Data in function argument&#125;</span></span><br></pre></td></tr></table></figure><h2 id="自定义error"><a href="#自定义error" class="headerlink" title="自定义error"></a>自定义error</h2><h3 id="系统抛"><a href="#系统抛" class="headerlink" title="系统抛"></a>系统抛</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统抛</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">   a[<span class="number">1</span>] = <span class="number">123</span></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">   <span class="comment">//a[10] = 11</span></span><br><span class="line">   index := <span class="number">10</span></span><br><span class="line">   a[index] = <span class="number">10</span></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCircleArea</span><span class="params">(radius <span class="type">float32</span>)</span></span> (area <span class="type">float32</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 自己抛</span></span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;半径不能为负&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span> &#123;</span><br><span class="line">   getCircleArea(<span class="number">-5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test03</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 延时执行匿名函数</span></span><br><span class="line">   <span class="comment">// 延时到何时？（1）程序正常结束   （2）发生异常时</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// recover() 复活 恢复</span></span><br><span class="line">      <span class="comment">// 会返回程序为什么挂了</span></span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   getCircleArea(<span class="number">-5</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;这里有没有执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test04</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   test03()</span><br><span class="line">   fmt.Println(<span class="string">&quot;test04&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test04()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回异常"><a href="#返回异常" class="headerlink" title="返回异常"></a>返回异常</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;errors&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCircleArea</span><span class="params">(radius <span class="type">float32</span>)</span></span> (area <span class="type">float32</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 构建个异常对象</span></span><br><span class="line">      err = errors.New(<span class="string">&quot;半径不能为负&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   area = <span class="number">3.14</span> * radius * radius</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   area, err := getCircleArea(<span class="number">-5</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(area)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义error-1"><a href="#自定义error-1" class="headerlink" title="自定义error"></a>自定义error</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    path       <span class="type">string</span></span><br><span class="line">    op         <span class="type">string</span></span><br><span class="line">    createTime <span class="type">string</span></span><br><span class="line">    message    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;path=%s \nop=%s \ncreateTime=%s \nmessage=%s&quot;</span>, p.path,</span><br><span class="line">        p.op, p.createTime, p.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(filename <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">    file, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;PathError&#123;</span><br><span class="line">            path:       filename,</span><br><span class="line">            op:         <span class="string">&quot;read&quot;</span>,</span><br><span class="line">            message:    err.Error(),</span><br><span class="line">            createTime: fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, time.Now()),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := Open(<span class="string">&quot;/Users/5lmh/Desktop/go/src/test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">switch</span> v := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *PathError:</span><br><span class="line">        fmt.Println(<span class="string">&quot;get path error,&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get path error, path=<span class="regexp">/Users/</span>pprof<span class="regexp">/Desktop/g</span>o<span class="regexp">/src/</span>test.txt </span><br><span class="line">op=<span class="keyword">read</span> </span><br><span class="line">createTime=<span class="number">2018</span>-<span class="number">04</span>-<span class="number">05</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">17.331915</span> +<span class="number">0800</span> CST m=+<span class="number">0.000441790</span> </span><br><span class="line">message=open <span class="regexp">/Users/</span>pprof<span class="regexp">/Desktop/g</span>o<span class="regexp">/src/</span>test.txt: no such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="匿名字段-1"><a href="#匿名字段-1" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex  <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    addr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    s1 := Student&#123;Person&#123;<span class="string">&quot;5lmh&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">20</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">    s2 := Student&#123;Person: Person&#123;<span class="string">&quot;5lmh&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">20</span>&#125;&#125;</span><br><span class="line">    fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">    s3 := Student&#123;Person: Person&#123;name: <span class="string">&quot;5lmh&quot;</span>&#125;&#125;</span><br><span class="line">    fmt.Println(s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;<span class="name">5lmh</span> man <span class="number">20</span>&#125; <span class="number">1</span> bj&#125;</span></span><br><span class="line"><span class="template-variable">&#123;&#123;<span class="number">5</span>lmh man <span class="number">20</span>&#125; <span class="number">0</span> &#125;</span></span><br><span class="line"><span class="template-variable">&#123;&#123;<span class="number">5</span>lmh  <span class="number">0</span>&#125; <span class="number">0</span> &#125;</span></span><br></pre></td></tr></table></figure><p>同名字段的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex  <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    addr <span class="type">string</span></span><br><span class="line">    <span class="comment">//同名字段</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student</span><br><span class="line">    <span class="comment">// 给自己字段赋值了</span></span><br><span class="line">    s.name = <span class="string">&quot;5lmh&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若给父类同名字段赋值，如下</span></span><br><span class="line">    s.Person.name = <span class="string">&quot;枯藤&quot;</span></span><br><span class="line">    fmt.Println(s)&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;  <span class="name">0</span>&#125; <span class="number">0</span>  <span class="number">5</span>lmh&#125;</span></span><br><span class="line"><span class="template-variable">&#123;&#123;枯藤  <span class="number">0</span>&#125; <span class="number">0</span>  <span class="number">5</span>lmh&#125;</span></span><br></pre></td></tr></table></figure><p>所有的内置类型和自定义类型都是可以作为匿名字段去使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex  <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">type</span> mystr <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">    mystr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;Person&#123;<span class="string">&quot;5lmh&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;<span class="name">5lmh</span> man <span class="number">18</span>&#125; <span class="number">1</span> bj&#125;</span></span><br></pre></td></tr></table></figure><p>指针类型匿名字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex  <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Person</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    addr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;&amp;Person&#123;<span class="string">&quot;5lmh&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">    fmt.Println(s1.name)</span><br><span class="line">    fmt.Println(s1.Person.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>xc<span class="number">00005c360</span> <span class="number">1</span> bj&#125;</span><br><span class="line">zs</span><br><span class="line">zs</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。<br>interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。<br>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。</p><h3 id="为什么要使用接口"><a href="#为什么要使用接口" class="headerlink" title="为什么要使用接口"></a>为什么要使用接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Say() <span class="type">string</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;喵喵喵&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Say() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;汪汪汪&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Cat&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;猫:&quot;</span>, c.Say())</span><br><span class="line">    d := Dog&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;狗:&quot;</span>, d.Say())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？<br>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>Go语言提倡面向接口编程。</p><p>接口是一个或多个方法签名的集合。<br>    任何类型的方法集中只要拥有该接口’对应的全部方法’签名。<br>    就表示它 “实现” 了该接口，无须在该类型上显式声明实现了哪个接口。<br>    这称为Structural Typing。<br>    所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。<br>    当然，该类型还可以有其他方法。</p><pre><code>接口只有方法声明，没有实现，没有数据字段。接口可以匿名嵌入其他接口，或嵌入到结构中。对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。只有当接口存储的类型和对象都为nil时，接口才等于nil。接口调用不会做receiver的自动转换。接口同样支持匿名字段方法。接口也可实现类似OOP中的多态。空接口可以作为任何类型数据的容器。一个类型可实现多个接口。接口命名习惯以 er 结尾。</code></pre><p>每个接口由数个方法组成，接口的定义格式如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">接口类型名 </span><span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><p>   1.接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。<br>    2.方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。<br>    3.参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</p><h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h3><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。我们来定义一个Sayer接口：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Sayer 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Sayer </span><span class="keyword">interface</span> &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义dog和cat两个结构体：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog struct &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat struct &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line">func (d dog) <span class="built_in">say</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(&quot;汪汪汪&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line">func (c cat) <span class="built_in">say</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(&quot;喵喵喵&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。</p><h3 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h3><p>那实现了接口有什么用呢？接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    var x Sayer <span class="regexp">//</span> 声明一个Sayer类型的变量x</span><br><span class="line">    a := cat&#123;&#125;  <span class="regexp">//</span> 实例化一个cat</span><br><span class="line">    b := dog&#123;&#125;  <span class="regexp">//</span> 实例化一个dog</span><br><span class="line">    x = a       <span class="regexp">//</span> 可以把cat实例直接赋值给x</span><br><span class="line">    x.say()     <span class="regexp">//</span> 喵喵喵</span><br><span class="line">    x = b       <span class="regexp">//</span> 可以把dog实例直接赋值给x</span><br><span class="line">    x.say()     <span class="regexp">//</span> 汪汪汪</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h3><p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。我们有一个Mover接口和一个dog结构体。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Mover</span> interface &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog struct &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现接口的是dog类型：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    var x Mover</span><br><span class="line">    var wangcai = dog&#123;&#125; <span class="regexp">//</span> 旺财是dog类型</span><br><span class="line">    x = wangcai         <span class="regexp">//</span> x可以接收dog类型</span><br><span class="line">    var fugui = &amp;dog&#123;&#125;  <span class="regexp">//</span> 富贵是*dog类型</span><br><span class="line">    x = fugui           <span class="regexp">//</span> x可以接收*dog类型</span><br><span class="line">    x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针* dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值* fugui。</p><h4 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h4><p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span></span> move() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;狗会动&quot;</span>)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x Mover</span><br><span class="line">    <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">    x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line">    <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">    x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现Mover接口的是* dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储* dog类型的值。</p><h4 id="下面的代码是一个比较好的面试题"><a href="#下面的代码是一个比较好的面试题" class="headerlink" title="下面的代码是一个比较好的面试题"></a>下面的代码是一个比较好的面试题</h4><p>请问下面的代码是否能通过编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak(<span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Stduent)</span></span> Speak(think <span class="type">string</span>) (talk <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> think == <span class="string">&quot;sb&quot;</span> &#123;</span><br><span class="line">        talk = <span class="string">&quot;你是个大帅比&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        talk = <span class="string">&quot;您好&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> peo People = Student&#123;&#125;</span><br><span class="line">    think := <span class="string">&quot;bitch&quot;</span></span><br><span class="line">    fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h3><h4 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a>一个类型实现多个接口</h4><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： Mover接口。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Sayer 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Sayer </span><span class="keyword">interface</span> &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Mover 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Mover </span><span class="keyword">interface</span> &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dog既可以实现Sayer接口，也可以实现Mover接口。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type dog struct &#123;</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Sayer接口</span></span><br><span class="line">func (d dog) <span class="built_in">say</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%s会叫汪汪汪\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Mover接口</span></span><br><span class="line">func (d dog) <span class="built_in">move</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%s会动\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> x Sayer</span><br><span class="line">    <span class="selector-tag">var</span> y Mover</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">    x = <span class="selector-tag">a</span></span><br><span class="line">    y = <span class="selector-tag">a</span></span><br><span class="line">    x<span class="selector-class">.say</span>()</span><br><span class="line">    y<span class="selector-class">.move</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个类型实现同一接口"><a href="#多个类型实现同一接口" class="headerlink" title="多个类型实现同一接口"></a>多个类型实现同一接口</h4><p>Go语言中不同的类型还可以实现同一接口 首先我们定义一个Mover接口，它要求必须由一个move方法。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Mover 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Mover </span><span class="keyword">interface</span> &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> car <span class="keyword">struct</span> &#123;</span><br><span class="line">    brand <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog类型实现Mover接口</span></span><br><span class="line">func (d dog) move<span class="literal">()</span> &#123;</span><br><span class="line">    fmt.<span class="constructor">Printf(<span class="string">&quot;%s会跑\n&quot;</span>, <span class="params">d</span>.<span class="params">name</span>)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// car类型实现Mover接口</span></span><br><span class="line">func (c car) move<span class="literal">()</span> &#123;</span><br><span class="line">    fmt.<span class="constructor">Printf(<span class="string">&quot;%s速度70迈\n&quot;</span>, <span class="params">c</span>.<span class="params">brand</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> x Mover</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> = car&#123;brand: <span class="string">&quot;保时捷&quot;</span>&#125;</span><br><span class="line">    x = <span class="selector-tag">a</span></span><br><span class="line">    x<span class="selector-class">.move</span>()</span><br><span class="line">    x = <span class="selector-tag">b</span></span><br><span class="line">    x<span class="selector-class">.move</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码执行结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旺财会跑</span><br><span class="line">保时捷速度70迈</span><br></pre></td></tr></table></figure><p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WashingMachine 洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">    wash()</span><br><span class="line">    dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干器</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> dry() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">    dryer <span class="comment">//嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span></span> wash() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h3><p>接口与接口间可以通过嵌套创造出新的接口。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Sayer</span> 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Sayer</span> interface &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="type">Mover</span> 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Mover</span> interface &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接口嵌套</span><br><span class="line"><span class="keyword">type</span> animal interface &#123;</span><br><span class="line">    <span class="type">Sayer</span></span><br><span class="line">    <span class="type">Mover</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> move() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;猫会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x animal</span><br><span class="line">    x = cat&#123;name: <span class="string">&quot;花花&quot;</span>&#125;</span><br><span class="line">    x.move()</span><br><span class="line">    x.say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><h4 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a>空接口的定义</h4><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。<br>空接口类型的变量可以存储任意类型的变量。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 定义一个空接口x</span></span><br><span class="line">    <span class="selector-tag">var</span> x interface&#123;&#125;</span><br><span class="line">    s := <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    x = s</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">    <span class="selector-tag">i</span> := <span class="number">100</span></span><br><span class="line">    x = <span class="selector-tag">i</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">    <span class="selector-tag">b</span> := true</span><br><span class="line">    x = <span class="selector-tag">b</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h4><h5 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h5><p>使用空接口实现可以接收任意类型的函数参数。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line">func <span class="built_in">show</span>(<span class="selector-tag">a</span> interface&#123;&#125;) &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type:%T value:%v\n&quot;</span>, <span class="selector-tag">a</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="空接口作为map的值"><a href="#空接口作为map的值" class="headerlink" title="空接口作为map的值"></a>空接口作为map的值</h5><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line">    <span class="selector-tag">var</span> studentInfo = <span class="built_in">make</span>(map<span class="selector-attr">[string]</span>interface&#123;&#125;)</span><br><span class="line">    studentInfo<span class="selector-attr">[<span class="string">&quot;name&quot;</span>]</span> = <span class="string">&quot;李白&quot;</span></span><br><span class="line">    studentInfo<span class="selector-attr">[<span class="string">&quot;age&quot;</span>]</span> = <span class="number">18</span></span><br><span class="line">    studentInfo<span class="selector-attr">[<span class="string">&quot;married&quot;</span>]</span> = false</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(studentInfo)</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？</p><h5 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h5><p>一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。我们来看一个具体的例子：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line"><span class="attribute">w</span> <span class="operator">=</span> os.Stdout</span><br><span class="line"><span class="attribute">w</span> <span class="operator">=</span> new(bytes.Buffer)</span><br><span class="line"><span class="attribute">w</span> <span class="operator">=</span> nil</span><br></pre></td></tr></table></figure><p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80.png"></p><p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure><p>其中：<br>    x：表示类型为interface{}的变量<br>    T：表示断言x可能是的类型。</p><p>该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    x = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    v, ok := x.(<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中如果要断言多次就需要写多个if判断，这个时候我们可以使用switch语句来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="GORM"><a href="#GORM" class="headerlink" title="GORM"></a>GORM</h2><h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><ul><li>全特性 ORM (几乎包含所有特性)</li><li>模型关联 (一对一， 一对多，一对多（反向）， 多对多， 多态关联)</li><li>钩子 (Before/After Create/Save/Update/Delete/Find)</li><li>预加载</li><li>事务</li><li>复合主键</li><li>SQL 构造器</li><li>自动迁移</li><li>日志</li><li>基于GORM回调编写可扩展插件</li><li>全特性测试覆盖</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/jinzhu/gorm</span><br></pre></td></tr></table></figure><h4 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product struct &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Code string</span><br><span class="line">  Price uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  <span class="keyword">db</span>, <span class="keyword">err</span> := gorm.<span class="keyword">Open</span>(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;test.db&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    panic(<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  defer <span class="keyword">db</span>.<span class="keyword">Close</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自动检查 Product 结构是否变化，变化则进行迁移</span></span><br><span class="line">  <span class="keyword">db</span>.AutoMigrate(&amp;Product&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增</span></span><br><span class="line">  <span class="keyword">db</span>.Create(&amp;Product&#123;Code: <span class="string">&quot;L1212&quot;</span>, Price: 1000&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查</span></span><br><span class="line">  <span class="keyword">var</span> product Product</span><br><span class="line">  <span class="keyword">db</span>.First(&amp;product, 1) <span class="comment">// 找到id为1的产品</span></span><br><span class="line">  <span class="keyword">db</span>.First(&amp;product, <span class="string">&quot;code = ?&quot;</span>, <span class="string">&quot;L1212&quot;</span>) <span class="comment">// 找出 code 为 l1212 的产品</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 改 - 更新产品的价格为 2000</span></span><br><span class="line">  <span class="keyword">db</span>.Model(&amp;product).<span class="keyword">Update</span>(<span class="string">&quot;Price&quot;</span>, 2000)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删 - 删除产品</span></span><br><span class="line">  <span class="keyword">db</span>.Delete(&amp;product)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p>模型一般都是普通的 Golang 的结构体，Go的基本数据类型，或者指针。sql.Scanner 和 driver.Valuer，同时也支持接口。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm<span class="variable">.Model</span></span><br><span class="line">  Name         <span class="keyword">string</span></span><br><span class="line">  Age          sql<span class="variable">.NullInt64</span></span><br><span class="line">  Birthday     *<span class="keyword">time</span><span class="variable">.Time</span></span><br><span class="line">  Email        <span class="keyword">string</span>  `gorm:<span class="string">&quot;type:varchar(100);unique_index&quot;</span>`</span><br><span class="line">  Role         <span class="keyword">string</span>  `gorm:<span class="string">&quot;size:255&quot;</span>` <span class="comment">//设置字段的大小为255个字节</span></span><br><span class="line">  MemberNumber *<span class="keyword">string</span> `gorm:<span class="string">&quot;unique;not null&quot;</span>` <span class="comment">// 设置 memberNumber 字段唯一且不为空</span></span><br><span class="line">  Num          <span class="keyword">int</span>     `gorm:<span class="string">&quot;AUTO_INCREMENT&quot;</span>` <span class="comment">// 设置 Num字段自增</span></span><br><span class="line">  Address      <span class="keyword">string</span>  `gorm:<span class="string">&quot;index:addr&quot;</span>` <span class="comment">// 给Address 创建一个名字是  `addr`的索引</span></span><br><span class="line">  IgnoreMe     <span class="keyword">int</span>     `gorm:<span class="string">&quot;-&quot;</span>` <span class="comment">//忽略这个字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h4><p>标签是声明模型时可选的标记。GORM 支持以下标记：</p><h5 id="支持的结构标签"><a href="#支持的结构标签" class="headerlink" title="支持的结构标签"></a><strong>支持的结构标签</strong></h5><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>Column</td><td>指定列的名称</td></tr><tr><td>Type</td><td>指定列的类型</td></tr><tr><td>Size</td><td>指定列的大小，默认是 255</td></tr><tr><td>PRIMARY_KEY</td><td>指定一个列作为主键</td></tr><tr><td>UNIQUE</td><td>指定一个唯一的列</td></tr><tr><td>DEFAULT</td><td>指定一个列的默认值</td></tr><tr><td>PRECISION</td><td>指定列的数据的精度</td></tr><tr><td>NOT NULL</td><td>指定列的数据不为空</td></tr><tr><td>AUTO_INCREMENT</td><td>指定一个列的数据是否自增</td></tr><tr><td>INDEX</td><td>创建带或不带名称的索引，同名创建复合索引</td></tr><tr><td>UNIQUE_INDEX</td><td>类似 索引，创建一个唯一的索引</td></tr><tr><td>EMBEDDED</td><td>将 struct 设置为 embedded</td></tr><tr><td>EMBEDDED_PREFIX</td><td>设置嵌入式结构的前缀名称</td></tr><tr><td>-</td><td>忽略这些字段</td></tr></tbody></table><h5 id="关联的结构标签"><a href="#关联的结构标签" class="headerlink" title="关联的结构标签"></a>关联的结构标签</h5><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>MANY2MANY</td><td>指定连接表名称</td></tr><tr><td>FOREIGNKEY</td><td>指定外键</td></tr><tr><td>ASSOCIATION_FOREIGNKEY</td><td>指定关联外键</td></tr><tr><td>POLYMORPHIC</td><td>指定多态类型</td></tr><tr><td>POLYMORPHIC_VALUE</td><td>指定多态的值</td></tr><tr><td>JOINTABLE_FOREIGNKEY</td><td>指定连接表的外键</td></tr><tr><td>ASSOCIATION_JOINTABLE_FOREIGNKEY</td><td>指定连接表的关联外键</td></tr><tr><td>SAVE_ASSOCIATIONS</td><td>是否自动保存关联</td></tr><tr><td>ASSOCIATION_AUTOUPDATE</td><td>是否自动更新关联</td></tr><tr><td>ASSOCIATION_AUTOCREATE</td><td>是否自动创建关联</td></tr><tr><td>ASSOCIATION_SAVE_REFERENCE</td><td>是否引用自动保存的关联</td></tr><tr><td>PRELOAD</td><td>是否自动预加载关联</td></tr></tbody></table><h3 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h3><h4 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h4><p>gorm.Model 是一个包含一些基本字段的结构体, 包含的字段有 ID，CreatedAt， UpdatedAt， DeletedAt。</p><p>你可以用它来嵌入到你的模型中，或者也可以用它来建立自己的模型。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// gorm.<span class="type">Model</span> 定义</span><br><span class="line"><span class="keyword">type</span> <span class="type">Model</span> struct &#123;</span><br><span class="line">  <span class="type">ID</span>        uint `gorm:&quot;primary_key&quot;`</span><br><span class="line">  <span class="type">CreatedAt</span> time.<span class="type">Time</span></span><br><span class="line">  <span class="type">UpdatedAt</span> time.<span class="type">Time</span></span><br><span class="line">  <span class="type">DeletedAt</span> *time.<span class="type">Time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将字段 `<span class="type">ID</span>`, `<span class="type">CreatedAt</span>`, `<span class="type">UpdatedAt</span>`, `<span class="type">DeletedAt</span>` 注入到 `<span class="type">User</span>` 模型中</span><br><span class="line"><span class="keyword">type</span> <span class="type">User</span> struct &#123;</span><br><span class="line">  gorm.<span class="type">Model</span></span><br><span class="line">  <span class="type">Name</span> string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明 gorm.<span class="type">Model</span> 模型</span><br><span class="line"><span class="keyword">type</span> <span class="type">User</span> struct &#123;</span><br><span class="line">  <span class="type">ID</span>   int</span><br><span class="line">  <span class="type">Name</span> string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ID-作为主键"><a href="#ID-作为主键" class="headerlink" title="ID 作为主键"></a>ID 作为主键</h4><p>GORM 默认使用 ID 作为主键名。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">User</span> struct &#123;</span><br><span class="line">  <span class="type">ID</span>   string // 字段名 `<span class="type">ID</span>` 将被作为默认的主键名</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置字段 `<span class="type">AnimalID</span>` 为默认主键</span><br><span class="line"><span class="keyword">type</span> <span class="type">Animal</span> struct &#123;</span><br><span class="line">  <span class="type">AnimalID</span> int64 `gorm:&quot;primary_key&quot;`</span><br><span class="line">  <span class="type">Name</span>     string</span><br><span class="line">  <span class="type">Age</span>      int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复数表名"><a href="#复数表名" class="headerlink" title="复数表名"></a>复数表名</h4><p>表名是结构体名称的复数形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认的表名是 `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 `User` 的表名为 `profiles`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;profiles&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin_users&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;users&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果设置禁用表名复数形式属性为 true，`User` 的表名将是 `user`</span></span><br><span class="line">db.SingularTable(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h4 id="指定表名"><a href="#指定表名" class="headerlink" title="指定表名"></a>指定表名</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 用 `<span class="keyword">User</span>` 结构体创建 `delete_users` 表</span><br><span class="line">db.<span class="keyword">Table</span>(&quot;deleted_users&quot;).CreateTable(&amp;<span class="keyword">User</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">var deleted_users []<span class="keyword">User</span></span><br><span class="line">db.<span class="keyword">Table</span>(&quot;deleted_users&quot;).Find(&amp;deleted_users)</span><br><span class="line">//// <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> deleted_users;</span><br><span class="line"></span><br><span class="line">db.<span class="keyword">Table</span>(&quot;deleted_users&quot;).<span class="keyword">Where</span>(&quot;name = ?&quot;, &quot;jinzhu&quot;).<span class="keyword">Delete</span>()</span><br><span class="line">//// <span class="keyword">DELETE</span> <span class="keyword">FROM</span> deleted_users <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;jinzhu&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="修改默认表名"><a href="#修改默认表名" class="headerlink" title="修改默认表名"></a>修改默认表名</h4><p>你可以通过定义 DefaultTableNameHandler 字段来对表名使用任何规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gorm.DefaultTableNameHandler = <span class="function"><span class="keyword">func</span> <span class="params">(db *gorm.DB, defaultTableName <span class="type">string</span>)</span></span> <span class="type">string</span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;prefix_&quot;</span> + defaultTableName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="蛇形列名"><a href="#蛇形列名" class="headerlink" title="蛇形列名"></a>蛇形列名</h4><p>列名是字段名的蛇形小写形式</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">  ID        uint      // 字段名是 `id`</span><br><span class="line">  Name      string    // 字段名是 `name`</span><br><span class="line">  Birthday  time.Time // 字段名是 `birthday`</span><br><span class="line">  CreatedAt time.Time // 字段名是 `created_at`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写列名</span><br><span class="line">type Animal struct &#123;</span><br><span class="line"><span class="title">    AnimalId    int64     `gorm:</span><span class="string">&quot;column:beast_id&quot;</span>`         // 设置列名为 `beast_id`</span><br><span class="line"><span class="title">    Birthday    time.Time `gorm:</span><span class="string">&quot;column:day_of_the_beast&quot;</span>` // 设置列名为 `day_of_the_beast`</span><br><span class="line"><span class="title">    Age         int64     `gorm:</span><span class="string">&quot;column:age_of_the_beast&quot;</span>` // 设置列名为 `age_of_the_beast`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间戳跟踪"><a href="#时间戳跟踪" class="headerlink" title="时间戳跟踪"></a>时间戳跟踪</h4><h5 id="CreatedAt"><a href="#CreatedAt" class="headerlink" title="CreatedAt"></a>CreatedAt</h5><p>对于有 CreatedAt 字段的模型，它将被设置为首次创建记录的当前时间。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="constructor">Create(&amp;<span class="params">user</span>)</span> <span class="comment">// 将设置 `CreatedAt` 为当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以使用 `Update` 方法来更改默认时间</span></span><br><span class="line">db.<span class="constructor">Model(&amp;<span class="params">user</span>)</span>.<span class="constructor">Update(<span class="string">&quot;CreatedAt&quot;</span>, <span class="params">time</span>.Now()</span>)</span><br></pre></td></tr></table></figure><h5 id="UpdatedAt"><a href="#UpdatedAt" class="headerlink" title="UpdatedAt"></a>UpdatedAt</h5><p>对于有 UpdatedAt 字段的模型，它将被设置为记录更新时的当前时间。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="constructor">Save(&amp;<span class="params">user</span>)</span> <span class="comment">// 将设置 `UpdatedAt` 为当前时间</span></span><br><span class="line"></span><br><span class="line">db.<span class="constructor">Model(&amp;<span class="params">user</span>)</span>.<span class="constructor">Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span> <span class="comment">// 将设置 `UpdatedAt` 为当前时间</span></span><br></pre></td></tr></table></figure><h5 id="DeletedAt"><a href="#DeletedAt" class="headerlink" title="DeletedAt"></a>DeletedAt</h5><p>对于有 DeletedAt 字段的模型，当删除它们的实例时，它们并没有被从数据库中删除，只是将 DeletedAt 字段设置为当前时间。参考 Soft Delete</p><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>为了连接数据库，你首先要导入数据库驱动程序。例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="literal">_</span> <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br></pre></td></tr></table></figure><p>GORM 已经包含了一些驱动程序，为了方便的去记住它们的导入路径，你可以像下面这样导入 mysql 驱动程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line"><span class="regexp">//</span> import _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line"><span class="regexp">//</span> import _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line"><span class="regexp">//</span> import _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mssql&quot;</span></span><br></pre></td></tr></table></figure><h4 id="支持的数据库"><a href="#支持的数据库" class="headerlink" title="支持的数据库"></a>支持的数据库</h4><h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><p>注意： 为了正确的处理 time.Time ，你需要包含 parseTime 作为参数。 (More supported parameters)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;host=myhost port=myport user=gorm dbname=gorm password=mypassword&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Sqlite3"><a href="#Sqlite3" class="headerlink" title="Sqlite3"></a>Sqlite3</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;/tmp/gorm.db&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h5><p><a href="https://sqlchoice.azurewebsites.net/en-us/sql-server/developer-get-started/go/windows/">Get started with SQL Server</a>，它可以通过 Docker 运行在你的 Mac， Linux 上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mssql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;mssql&quot;</span>, <span class="string">&quot;sqlserver://username:password@localhost:1433?database=dbname&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="并发介绍"><a href="#并发介绍" class="headerlink" title="并发介绍"></a>并发介绍</h2><p>多线程程序在一个核的cpu上运行，就是并发。<br>多线程程序在多个核的cpu上运行，就是并行。</p><h3 id="协程和线程"><a href="#协程和线程" class="headerlink" title="协程和线程"></a>协程和线程</h3><p>协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。<br>线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p><p>goroutine 只是由官方实现的超级”线程池”。每个实例4~5KB的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因。</p><p>并发主要由切换时间片来实现”同时”运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。</p><p>goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</p><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><p>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p><h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">func</span> <span class="function"><span class="title">hello</span>() &#123;</span></span><br><span class="line"><span class="function">    <span class="variable">fmt.Println</span>(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="variable">func</span> <span class="function"><span class="title">main</span>() &#123;</span></span><br><span class="line"><span class="function">    <span class="title">hello</span>()</span></span><br><span class="line">    <span class="variable">fmt.Println</span>(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完Hello Goroutine!后打印main goroutine done!。接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="function">go <span class="title">hello</span>() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span></span><br><span class="line"><span class="function">    fmt.<span class="title">Println</span>(<span class="params"><span class="string">&quot;main goroutine done!&quot;</span></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    go <span class="built_in">hello</span>() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">    <span class="selector-tag">time</span><span class="selector-class">.Sleep</span>(<span class="selector-tag">time</span>.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码你会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!。首先为什么会先打印main goroutine done!是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。</p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">        <span class="keyword">go</span> hello(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p><p>注意：</p><p>如果主协程退出了，其他任务还执行吗（运行下面的代码测试一下吧）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 合起来写</span></span><br><span class="line">    go <span class="built_in">func</span>() &#123;</span><br><span class="line">        <span class="selector-tag">i</span> := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">            fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">            <span class="selector-tag">time</span><span class="selector-class">.Sleep</span>(<span class="selector-tag">time</span>.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="selector-tag">i</span> := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;main goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        <span class="selector-tag">time</span><span class="selector-class">.Sleep</span>(<span class="selector-tag">time</span>.Second)</span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">i</span> == <span class="number">2</span> &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h3><h4 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h4><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</p><h4 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h4><p>GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p><ol><li>G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li><li>P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li><li>M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li></ol><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><h2 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h2><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p>让出CPU时间片，重新等待安排任务(大概意思就是本来计划的好好的周末出去烧烤，但是你妈让你去相亲,两种情况第一就是你相亲速度非常快，见面就黄不耽误你继续烧烤，第二种情况就是你相亲速度特别慢，见面就是你侬我侬的，耽误了烧烤，但是还馋就是耽误了烧烤你还得去烧烤)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="comment">// 主协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 切一下，再次分配任务</span></span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h3><p>退出当前协程(一边烧烤一边相亲，突然发现相亲对象太丑影响烧烤，果断让她滚蛋，然后也就没有然后了)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">            <span class="comment">// 结束协程</span></span><br><span class="line">            runtime.Goexit()</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;C.defer&quot;</span>)</span><br><span class="line">            fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS"></a>runtime.GOMAXPROCS</h3><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p><p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> a()</span><br><span class="line">    <span class="keyword">go</span> b()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> a()</span><br><span class="line">    <span class="keyword">go</span> b()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中的操作系统线程和goroutine的关系：</p><ul><li>一个操作系统线程对应用户态多个goroutine。</li><li>go程序可以同时使用多个操作系统线程。</li><li>goroutine和OS线程是多对多的关系，即m:n。</li></ul><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><p>channel是一种类型，一种引用类型。声明通道类型的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>通道是引用类型，通道类型的空值是nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure><p>声明的通道后需要使用make函数初始化之后才能使用。<br>创建channel的格式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">make</span><span class="params">(chan 元素类型, [缓冲大小])</span></span></span><br></pre></td></tr></table></figure><p>channel的缓冲大小是可选的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。<br>发送和接收都使用&lt;-符号。现在我们先使用以下语句定义一个通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>将一个值发送到通道中。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ch</span> &lt;- <span class="number">10</span> // 把<span class="number">10</span>发送到ch中</span><br></pre></td></tr></table></figure><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>从一个通道中接收值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="regexp">//</span> 从ch中接收值并赋值给变量x</span><br><span class="line">&lt;-ch       <span class="regexp">//</span> 从ch中接收值，忽略结果</span><br></pre></td></tr></table></figure><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>我们通过调用内置的close函数来关闭通道。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">close</span><span class="params">(ch)</span></span></span><br></pre></td></tr></table></figure><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93.png"></p><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        ...<span class="regexp">/src/gi</span>thub.com<span class="regexp">/pprof/</span>studygo<span class="regexp">/day06/</span>channel02/main.go:<span class="number">8</span> +<span class="number">0</span>x54</span><br></pre></td></tr></table></figure><p>为什么会出现deadlock错误呢？</p><p>因为我们使用ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。<br>上面的代码会阻塞在ch &lt;- 10这一行代码形成死锁，那如何解决这个问题呢？一种方法是启用一个goroutine去接收值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ret := &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">&quot;接收成功&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。</p><h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93.png"></p><p>我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。<br>我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。</p><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>可以通过内置的close()函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> data, ok := &lt;-c; ok &#123;</span><br><span class="line">            fmt.Println(data)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何优雅的从通道循环取值"><a href="#如何优雅的从通道循环取值" class="headerlink" title="如何优雅的从通道循环取值"></a>如何优雅的从通道循环取值</h3><p>当通过通道发送有限的数据时，我们可以通过close函数关闭通道来告知从该通道接收值的goroutine停止等待。当通道被关闭时，往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？我们来看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel 练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">            ch1 &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(ch1)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ch2 &lt;- i * i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(ch2)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 在主goroutine中从ch2中接收值打印</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ch2 &#123; <span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子中我们看到有两种方式在接收值的时候判断通道是否被关闭，我们通常使用的是for range的方式。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。<br>Go语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- i * i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)&#125;<span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(ch1)</span><br><span class="line">    <span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">    printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">chan</span>&lt;- <span class="type">int</span>是一个只能发送的通道，可以发送但是不能接收；</span><br><span class="line"><span class="number">2.</span>&lt;-<span class="keyword">chan</span> <span class="type">int</span>是一个只能接收的通道，可以接收但是不能发送。</span><br></pre></td></tr></table></figure><p>在函数传参及任何赋值操作中将双向通道转换为单向通道是可以的，但反过来是不可以的。</p><h3 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h3><p>channel常见的异常总结，如下图：<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E9%80%9A%E9%81%93%E6%80%BB%E7%BB%93.png"><br>注意:关闭已经关闭的channel也会引发panic。</p><h2 id="Goroutine池"><a href="#Goroutine池" class="headerlink" title="Goroutine池"></a>Goroutine池</h2><h3 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a>worker pool（goroutine池）</h3><ul><li>本质上是生产者消费者模型</li><li>可以有效控制goroutine数量，防止暴涨</li></ul><p>需求：</p><ul><li>计算一个数字的各个位数之和，例如数字123，结果为1+2+3=6</li><li>随机生成数字进行计算</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// id</span></span><br><span class="line">    Id <span class="type">int</span></span><br><span class="line">    <span class="comment">// 需要计算的随机数</span></span><br><span class="line">    RandNum <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 这里必须传对象实例</span></span><br><span class="line">    job *Job</span><br><span class="line">    <span class="comment">// 求和</span></span><br><span class="line">    sum <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要2个管道</span></span><br><span class="line">    <span class="comment">// 1.job管道</span></span><br><span class="line">    jobChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *Job, <span class="number">128</span>)</span><br><span class="line">    <span class="comment">// 2.结果管道</span></span><br><span class="line">    resultChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *Result, <span class="number">128</span>)</span><br><span class="line">    <span class="comment">// 3.创建工作池</span></span><br><span class="line">    createPool(<span class="number">64</span>, jobChan, resultChan)</span><br><span class="line">    <span class="comment">// 4.开个打印的协程</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(resultChan <span class="keyword">chan</span> *Result)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 遍历结果管道打印</span></span><br><span class="line">        <span class="keyword">for</span> result := <span class="keyword">range</span> resultChan &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;job id:%v randnum:%v result:%d\n&quot;</span>, result.job.Id,</span><br><span class="line">                result.job.RandNum, result.sum)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(resultChan)</span><br><span class="line">    <span class="keyword">var</span> id <span class="type">int</span></span><br><span class="line">    <span class="comment">// 循环创建job，输入到管道</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        id++</span><br><span class="line">        <span class="comment">// 生成随机数</span></span><br><span class="line">        r_num := rand.Int()</span><br><span class="line">        job := &amp;Job&#123;</span><br><span class="line">            Id:      id,</span><br><span class="line">            RandNum: r_num,</span><br><span class="line">        &#125;</span><br><span class="line">        jobChan &lt;- job</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建工作池// 参数1：开几个协程func createPool(num int, jobChan chan *Job, resultChan chan *Result) &#123;</span></span><br><span class="line">    <span class="comment">// 根据开协程个数，去跑运行</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(jobChan <span class="keyword">chan</span> *Job, resultChan <span class="keyword">chan</span> *Result)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 执行运算</span></span><br><span class="line">            <span class="comment">// 遍历job管道所有数据，进行相加</span></span><br><span class="line">            <span class="keyword">for</span> job := <span class="keyword">range</span> jobChan &#123;</span><br><span class="line">                <span class="comment">// 随机数接过来</span></span><br><span class="line">                r_num := job.RandNum</span><br><span class="line">                <span class="comment">// 随机数每一位相加</span></span><br><span class="line">                <span class="comment">// 定义返回值</span></span><br><span class="line">                <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">                <span class="keyword">for</span> r_num != <span class="number">0</span> &#123;</span><br><span class="line">                    tmp := r_num % <span class="number">10</span></span><br><span class="line">                    sum += tmp</span><br><span class="line">                    r_num /= <span class="number">10</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 想要的结果是Result</span></span><br><span class="line">                r := &amp;Result&#123;</span><br><span class="line">                    job: job,</span><br><span class="line">                    sum: sum,</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//运算结果扔到管道</span></span><br><span class="line">                resultChan &lt;- r</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(jobChan, resultChan)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>Timer：时间到了，执行只执行1次</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="number">1</span>.timer基本使用</span><br><span class="line">    <span class="regexp">//</span>timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="regexp">//</span>t1 := time.Now()</span><br><span class="line">    <span class="regexp">//</span>fmt.Printf(<span class="string">&quot;t1:%v\n&quot;</span>, t1)</span><br><span class="line">    <span class="regexp">//</span>t2 := &lt;-timer1.C</span><br><span class="line">    <span class="regexp">//</span>fmt.Printf(<span class="string">&quot;t2:%v\n&quot;</span>, t2)</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> <span class="number">2</span>.验证timer只能响应<span class="number">1</span>次</span><br><span class="line">    <span class="regexp">//</span>timer2 := time.NewTimer(time.Second)</span><br><span class="line">    <span class="regexp">//</span><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> &lt;-timer2.C</span><br><span class="line">    <span class="regexp">//</span> fmt.Println(<span class="string">&quot;时间到&quot;</span>)</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> <span class="number">3</span>.timer实现延时的功能</span><br><span class="line">    <span class="regexp">//</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="regexp">//</span>time.Sleep(time.Second)</span><br><span class="line">    <span class="regexp">//</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="regexp">//</span>timer3 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="regexp">//</span>&lt;-timer3.C</span><br><span class="line">    <span class="regexp">//</span>fmt.Println(<span class="string">&quot;2秒到&quot;</span>)</span><br><span class="line">    <span class="regexp">//</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="regexp">//</span>&lt;-time.After(<span class="number">2</span>*time.Second)</span><br><span class="line">    <span class="regexp">//</span>fmt.Println(<span class="string">&quot;2秒到&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> <span class="number">4</span>.停止定时器</span><br><span class="line">    <span class="regexp">//</span>timer4 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="regexp">//g</span>o <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="regexp">//</span> &lt;-timer4.C</span><br><span class="line">    <span class="regexp">//</span> fmt.Println(<span class="string">&quot;定时器执行了&quot;</span>)</span><br><span class="line">    <span class="regexp">//</span>&#125;()</span><br><span class="line">    <span class="regexp">//</span>b := timer4.Stop()</span><br><span class="line">    <span class="regexp">//i</span>f b &#123;</span><br><span class="line">    <span class="regexp">//</span> fmt.Println(<span class="string">&quot;timer4已经关闭&quot;</span>)</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> <span class="number">5</span>.重置定时器</span><br><span class="line">    timer5 := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">    timer5.Reset(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(time.Now())</span><br><span class="line">    fmt.Println(&lt;-timer5.C)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ticker：时间到了，多次执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取ticker对象</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 子协程</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;-ticker.C</span></span><br><span class="line">            i++</span><br><span class="line">            fmt.Println(&lt;-ticker.C)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">                <span class="comment">//停止</span></span><br><span class="line">                ticker.Stop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h3><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">for</span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从ch1接收值</span></span><br><span class="line">    <span class="meta">data</span>, ok := &lt;-ch1</span><br><span class="line">    <span class="comment">// 尝试从ch2接收值</span></span><br><span class="line">    <span class="meta">data</span>, ok := &lt;-ch2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。</p><p>select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">   // 如果chan1成功读到数据，则进行该<span class="keyword">case</span>处理语句</span><br><span class="line"><span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">   // 如果成功向chan2写入数据，则进行该<span class="keyword">case</span>处理语句</span><br><span class="line"><span class="literal">default</span>:</span><br><span class="line">   // 如果上面都没有成功，则进入<span class="literal">default</span>处理流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select可以同时监听一个或多个channel，直到其中一个channel ready</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">   ch &lt;- <span class="string">&quot;test1&quot;</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">   ch &lt;- <span class="string">&quot;test2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 2个管道</span></span><br><span class="line">   output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">   output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">   <span class="comment">// 跑2个子协程，写数据</span></span><br><span class="line">   <span class="keyword">go</span> test1(output1)</span><br><span class="line">   <span class="keyword">go</span> test2(output2)</span><br><span class="line">   <span class="comment">// 用select监控</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">      fmt.Println(<span class="string">&quot;s1=&quot;</span>, s1)</span><br><span class="line">   <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">      fmt.Println(<span class="string">&quot;s2=&quot;</span>, s2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个channel同时ready，则随机选择一个执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建2个管道</span></span><br><span class="line">   int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">   string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//time.Sleep(2 * time.Second)</span></span><br><span class="line">      int_chan &lt;- <span class="number">1</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">      fmt.Println(<span class="string">&quot;int:&quot;</span>, value)</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">      fmt.Println(<span class="string">&quot;string:&quot;</span>, value)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用于判断管道是否存满</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断管道有没有存满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建管道</span></span><br><span class="line">   output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="comment">// 子协程写数据</span></span><br><span class="line">   <span class="keyword">go</span> write(output1)</span><br><span class="line">   <span class="comment">// 取数据</span></span><br><span class="line">   <span class="keyword">for</span> s := <span class="keyword">range</span> output1 &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;res:&quot;</span>, s)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      <span class="keyword">case</span> ch &lt;- <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;write hello&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;channel full&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x int64var wg sync.<span class="function">WaitGroup</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">func <span class="title">add</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">func <span class="title">main</span>()</span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="function">go <span class="title">add</span>()</span></span><br><span class="line"><span class="function">    go <span class="title">add</span>()</span></span><br><span class="line"><span class="function">    wg.<span class="title">Wait</span>()</span></span><br><span class="line"><span class="function">    fmt.<span class="title">Println</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x int64var wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">lock</span> sync.<span class="function">Mutex</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">func <span class="title">add</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">lock</span>.Lock() <span class="comment">// 加锁</span></span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        <span class="keyword">lock</span>.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()&#125;<span class="function">func <span class="title">main</span>()</span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="function">go <span class="title">add</span>()</span></span><br><span class="line"><span class="function">    go <span class="title">add</span>()</span></span><br><span class="line"><span class="function">    wg.<span class="title">Wait</span>()</span></span><br><span class="line"><span class="function">    fmt.<span class="title">Println</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。</p><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。</p><p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    x      int64</span><br><span class="line">    wg     sync.WaitGroup</span><br><span class="line">    lock   sync.Mutex</span><br><span class="line">    rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> write() &#123;</span><br><span class="line">    <span class="regexp">//</span> lock.Lock()   <span class="regexp">//</span> 加互斥锁</span><br><span class="line">    rwlock.Lock() <span class="regexp">//</span> 加写锁</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="regexp">//</span> 假设读操作耗时<span class="number">10</span>毫秒</span><br><span class="line">    rwlock.Unlock()                   <span class="regexp">//</span> 解写锁</span><br><span class="line">    <span class="regexp">//</span> lock.Unlock()                     <span class="regexp">//</span> 解互斥锁</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> read() &#123;</span><br><span class="line">    <span class="regexp">//</span> lock.Lock()                  <span class="regexp">//</span> 加互斥锁</span><br><span class="line">    rwlock.RLock()               <span class="regexp">//</span> 加读锁</span><br><span class="line">    time.Sleep(time.Millisecond) <span class="regexp">//</span> 假设读操作耗时<span class="number">1</span>毫秒</span><br><span class="line">    rwlock.RUnlock()             <span class="regexp">//</span> 解读锁</span><br><span class="line">    <span class="regexp">//</span> lock.Unlock()                <span class="regexp">//</span> 解互斥锁</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        go write()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        go read()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    end := time.Now()</span><br><span class="line">    fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>(wg * WaitGroup) Add(delta int)</td><td>计数器+delta</td></tr><tr><td>(wg * WaitGroup) Done()</td><td>计数器-1</td></tr><tr><td>(wg * WaitGroup) Wait()</td><td>阻塞直到计数器变为0</td></tr></tbody></table><p>sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> wg sync<span class="selector-class">.WaitGroup</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">hello</span>() &#123;</span><br><span class="line">    defer wg<span class="selector-class">.Done</span>()</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;Hello Goroutine!&quot;</span>)&#125;func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    wg<span class="selector-class">.Add</span>(<span class="number">1</span>)</span><br><span class="line">    go <span class="built_in">hello</span>() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">    wg<span class="selector-class">.Wait</span>()&#125;</span><br></pre></td></tr></table></figure><p>需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。</p><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>说在前面的话：这是一个进阶知识点。在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。<br>Go语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。sync.Once只有一个Do方法，其签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>注意：如果要执行的函数f需要传递参数就需要搭配闭包来使用。</p><h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> icons map<span class="selector-attr">[string]</span>image<span class="selector-class">.Image</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">loadIcons</span>() &#123;</span><br><span class="line">    icons = map<span class="selector-attr">[string]</span>image.Image&#123;</span><br><span class="line">        <span class="string">&quot;left&quot;</span>:  <span class="built_in">loadIcon</span>(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;up&quot;</span>:    <span class="built_in">loadIcon</span>(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: <span class="built_in">loadIcon</span>(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;down&quot;</span>:  <span class="built_in">loadIcon</span>(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的func Icon(name string) image.Image &#123;</span></span><br><span class="line">    <span class="keyword">if</span> icons == nil &#123;</span><br><span class="line">        <span class="built_in">loadIcons</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    return icons<span class="selector-attr">[name]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="built_in">loadIcons</span>() &#123;</span><br><span class="line">    icons = <span class="built_in">make</span>(map<span class="selector-attr">[string]</span>image.Image)</span><br><span class="line">    icons<span class="selector-attr">[<span class="string">&quot;left&quot;</span>]</span> = <span class="built_in">loadIcon</span>(<span class="string">&quot;left.png&quot;</span>)</span><br><span class="line">    icons<span class="selector-attr">[<span class="string">&quot;up&quot;</span>]</span> = <span class="built_in">loadIcon</span>(<span class="string">&quot;up.png&quot;</span>)</span><br><span class="line">    icons<span class="selector-attr">[<span class="string">&quot;right&quot;</span>]</span> = <span class="built_in">loadIcon</span>(<span class="string">&quot;right.png&quot;</span>)</span><br><span class="line">    icons<span class="selector-attr">[<span class="string">&quot;down&quot;</span>]</span> = <span class="built_in">loadIcon</span>(<span class="string">&quot;down.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。<br>使用sync.Once改造的示例代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> icons map<span class="selector-attr">[string]</span>image<span class="selector-class">.Image</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> loadIconsOnce sync<span class="selector-class">.Once</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">loadIcons</span>() &#123;</span><br><span class="line">    icons = map<span class="selector-attr">[string]</span>image.Image&#123;</span><br><span class="line">        <span class="string">&quot;left&quot;</span>:  <span class="built_in">loadIcon</span>(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;up&quot;</span>:    <span class="built_in">loadIcon</span>(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: <span class="built_in">loadIcon</span>(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;down&quot;</span>:  <span class="built_in">loadIcon</span>(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line">func <span class="built_in">Icon</span>(name string) image<span class="selector-class">.Image</span> &#123;</span><br><span class="line">    loadIconsOnce<span class="selector-class">.Do</span>(loadIcons)</span><br><span class="line">    return icons<span class="selector-attr">[name]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            set(key, n)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, get(key))</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。<br>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            m.Store(key, n)</span><br><span class="line">            value, _ := m.Load(key)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="原子操作-atomic包"><a href="#原子操作-atomic包" class="headerlink" title="原子操作(atomic包)"></a>原子操作(atomic包)</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h1&gt;&lt;h2 id=&quot;go的安装&quot;&gt;&lt;a href=&quot;#go的安装&quot; class=&quot;headerlink&quot; title=&quot;go的安装&quot;&gt;&lt;/a&gt;go的安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装 mercurial、git、gcc包&lt;/p&gt;
&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]&lt;span class=&quot;comment&quot;&gt;# yum install mercurial git gcc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载Go的压缩包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用tar 命令来解压压缩包。&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf go1.&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.linux-amd64&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tar&lt;/span&gt;.gz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建立Go的工作空间（workspace，也就是GOPATH环境变量指向的目录），GO代码必须在工作空间内。工作空间是一个目录，其中包含三个子目录：&lt;br&gt;src —- 里面每一个子目录，就是一个包。包内是Go的源码文件&lt;br&gt;pkg —- 编译后生成的，包的目标文件&lt;br&gt;bin —- 生成的可执行文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里，我们在/home目录下, 建立一个名为go(可以不是go, 任意名字都可以)的文件夹， 然后再建立三个子文件夹(子文件夹名必须为src、pkg、bin)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加PATH环境变量and设置GOPATH环境变量&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt;]# &lt;span class=&quot;keyword&quot;&gt;vi&lt;/span&gt; /etc/&lt;span class=&quot;keyword&quot;&gt;profile&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
加入下面这三行:&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;GOROOT&lt;/span&gt;=/usr/local/go        ##Golang安装目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;PATH&lt;/span&gt;=&lt;span class=&quot;variable&quot;&gt;$GOROOT&lt;/span&gt;/bin:$PATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;GOPATH&lt;/span&gt;=/home/go  ##Golang项目目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="go" scheme="https://shenhongwei33.github.io/categories/go/"/>
    
    
    <category term="go基础" scheme="https://shenhongwei33.github.io/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://shenhongwei33.github.io/2023/01/24/MySQL/"/>
    <id>https://shenhongwei33.github.io/2023/01/24/MySQL/</id>
    <published>2023-01-24T14:39:21.000Z</published>
    <updated>2023-01-24T15:10:41.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="数据基础知识总结"><a href="#数据基础知识总结" class="headerlink" title="数据基础知识总结"></a>数据基础知识总结</h2><h3 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h3><ul><li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li></ul><p>数据库系统基本构成如下图所示：<br><img src="/2023/01/24/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90.jpg"></p><h3 id="什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h3><ul><li><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li><li><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li><li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li><strong>非主属性</strong>： 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li></ul><h3 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别?"></a>主键和外键有什么区别?</h3><ul><li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h3 id="为什么不推荐使用外键与级联？"><a href="#为什么不推荐使用外键与级联？" class="headerlink" title="为什么不推荐使用外键与级联？"></a>为什么不推荐使用外键与级联？</h3><p>对于外键和级联，阿里巴巴开发手册这样说到：</p><blockquote><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度</p></blockquote><p>为什么不要用外键呢？大部分人可能会这样回答：</p><blockquote><p>1.增加了复杂性： a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。<br>2.增加了额外工作： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）<br>3.对分库分表不友好 ：因为分库分表下外键是无法生效的。</p></blockquote><p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p><ol><li>保证了数据库数据的一致性和完整性；</li><li>级联操作方便，减轻了程序代码量；</li></ol><h3 id="什么是-ER-图？"><a href="#什么是-ER-图？" class="headerlink" title="什么是 ER 图？"></a>什么是 ER 图？</h3><p>E-R 图 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。<br>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种关系是：1 对 1（1:1）、1 对多（1: N）。<br><img src="/2023/01/24/MySQL/E-R.png"></p><p>我们试着将上面的 ER 图转换成数据库实际的关系模型(实际设计中，我们通常会将任课教师也作为一个实体来处理)：<br><img src="/2023/01/24/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93.png"></p><h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p><strong>1NF(第一范式)</strong><br>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。1NF 是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式。</p><p><strong>2NF(第二范式)</strong></p><p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。<br><img src="/2023/01/24/MySQL/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F.png"></p><p>一些重要的概念：</p><ul><li><strong>函数依赖</strong>（functional dependency） ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li><li><strong>部分函数依赖</strong>（partial functional dependency） ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li><li><strong>完全函数依赖</strong>(Full functional dependency) ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li><li><strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。</li></ul><p><strong>3NF(第三范式)</strong></p><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p><p><strong>总结</strong></p><ul><li>1NF：属性不可再分。</li><li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串SQL语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p><p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p><p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。</p><h3 id="数据库设计通常步骤"><a href="#数据库设计通常步骤" class="headerlink" title="数据库设计通常步骤"></a>数据库设计通常步骤</h3><ol><li>需求分析 : 分析用户的需求，包括数据、功能和性能需求。</li><li>概念结构设计 : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li>逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li>物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li>数据库实施 : 包括编程、测试和试运行</li><li>数据库的运行和维护 : 系统的运行与数据库的日常维护。</li></ol><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p><ul><li><strong>utf8</strong> ： utf8编码只支持1-3个字节 。 在utf8编码中，中文是占3个字节，其他数字、英文、符号占一个字节。但emoji符号占4个字节，一些较复杂的文字、繁体字也是4个字节。</li><li><strong>utf8mb4</strong> ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li></ul><p>因此，如果你需要存储emoji类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为utf8mb4 而不是utf8 ，要不然存储的时候就会报错了。</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="MySQL 基础架构"></a>MySQL 基础架构</h2><p>从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的：<br><img src="/2023/01/24/MySQL/MySQL%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png"></p><p>从上图可以看出， MySQL 主要由下面几部分构成：</p><ul><li>连接器： 身份认证和权限相关(登录 MySQL 的时候)。</li><li>查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li>分析器： 没有命中缓存的话，SQL语句就会经过分析器，分析器说白了就是要先看你的SQL语句要干嘛，再检查你的SQL语句语法是否正确。</li><li>优化器： 按照MySQL认为最优的方案去执行。</li><li>执行器： 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li>插件式存储引擎 ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><h3 id="MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="MySQL 支持哪些存储引擎？默认使用哪个？"></a>MySQL 支持哪些存储引擎？默认使用哪个？</h3><p>MySQL 支持多种存储引擎，你可以通过 <code>show engines</code> 命令来查看 MySQL 支持的所有存储引擎。<br><img src="/2023/01/24/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png"></p><p>从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。<br>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>你也可以通过 <code>show variables like &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎。<br><img src="/2023/01/24/MySQL/%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png"></p><p>如果你只想查看数据库中某个表使用的存储引擎的话，可以使用 <code>show table status from db_name where name=&#39;table_name&#39;</code>命令。<br><img src="/2023/01/24/MySQL/%E6%9F%90%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png"></p><h3 id="MySQL-存储引擎架构"><a href="#MySQL-存储引擎架构" class="headerlink" title="MySQL 存储引擎架构"></a>MySQL 存储引擎架构</h3><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库</strong>。并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。</p><h3 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a>MyISAM 和 InnoDB 的区别</h3><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。<br>具体对比如下：</p><ol><li><strong>是否支持行级锁</strong><br>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li><li><strong>是否支持事务</strong><br>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了SQL标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</li><li><strong>是否支持数据库异常崩溃后的安全恢复</strong><br>MyISAM 不支持，而 InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log 。</li><li><strong>是否支持外键</strong><br>MyISAM 不支持，而 InnoDB 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</li><li><strong>是否支持 MVCC</strong><br>MyISAM 不支持，而 InnoDB 支持。讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</li><li><strong>索引实现不一样</strong><br>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</li></ol><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><p>大多数情况下，我们在谈论事务的时候，如果没有特指分布式事务，往往指的就是数据库事务。</p><p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：要么全部执行成功,要么全部不执行 。<br><img src="/2023/01/24/MySQL/ACID.png"></p><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p><h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题：</p><ul><li><strong>脏读（Dirty read）</strong>: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）</strong>: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）</strong>: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）</strong>: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p>不可重复读和幻读的区别：</p><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。举个例子：执行delete和update操作的时候，可以直接对记录加锁，保证事务安全。而执行insert操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行insert操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h3 id="SQL-标准定义的事务隔离级别"><a href="#SQL-标准定义的事务隔离级别" class="headerlink" title="SQL 标准定义的事务隔离级别"></a>SQL 标准定义的事务隔离级别</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><h4 id="MySQL-的隔离级别的实现方式"><a href="#MySQL-的隔离级别的实现方式" class="headerlink" title="MySQL 的隔离级别的实现方式"></a>MySQL 的隔离级别的实现方式</h4><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。<br><strong>SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。</strong> 不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><p>MySQL InnoDB存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过SELECT @@tx_isolation;命令来查看，MySQL 8.0 该命令改为SELECT @@transaction_isolation;</p><h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h2><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p>表级锁和行级锁对比 ：</p><ul><li><strong>表级锁</strong>： MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁</strong>： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><h3 id="行级锁的使用的注意事项"><a href="#行级锁的使用的注意事项" class="headerlink" title="行级锁的使用的注意事项"></a>行级锁的使用的注意事项</h3><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p>由于MVCC的存在，对于一般的 SELECT 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 共享锁</span></span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE<span class="comment">;</span></span><br><span class="line"><span class="meta"># 排他锁</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> UPDATE<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢？一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS锁</th><th>IX锁</th></tr></thead><tbody><tr><td>IS锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。<br>|      | IS锁 | IX锁 |<br>| —- | —- | —- |<br>| S锁  | 兼容 | 互斥 |<br>| X锁  | 互斥 | 互斥 |</p><h3 id="InnoDB-支持的行锁"><a href="#InnoDB-支持的行锁" class="headerlink" title="InnoDB 支持的行锁"></a>InnoDB 支持的行锁</h3><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读（一致性非锁定读）</strong> ：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读 （一致性锁定读）</strong>： 使用 Next-Key Lock 进行加锁来保证不出现幻读。</li></ul><h4 id="当前读和快照读的区别"><a href="#当前读和快照读的区别" class="headerlink" title="当前读和快照读的区别"></a>当前读和快照读的区别</h4><p>快照读（一致性非锁定读）就是单纯的 SELECT 语句，但不包括下面这两类 SELECT 语句：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">SELECT</span></span> ... <span class="keyword">FOR</span> UPDATE</span><br><span class="line"><span class="function"><span class="title">SELECT</span></span> ... LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上X锁的释放，而是会去读取行的一个快照。<br>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。<strong>当前读 （一致性锁定读）就是给行记录加 X 锁或 S 锁</strong>。</p><p>当前读的一些常见 SQL 语句类型如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 对读的记录加一个X锁</span><br><span class="line"><span class="function"><span class="title">SELECT</span></span>...<span class="keyword">FOR</span> UPDATE</span><br><span class="line"># 对读的记录加一个S锁</span><br><span class="line"><span class="function"><span class="title">SELECT</span></span>...LOCK IN SHARE MODE</span><br><span class="line"># 对修改的记录加一个X锁</span><br><span class="line"><span class="function"><span class="title">INSERT</span></span>...</span><br><span class="line"><span class="function"><span class="title">UPDATE</span></span>...</span><br><span class="line"><span class="function"><span class="title">DELETE</span></span>...</span><br></pre></td></tr></table></figure><h2 id="MySQL索引详解"><a href="#MySQL索引详解" class="headerlink" title="MySQL索引详解"></a>MySQL索引详解</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p><strong>优点 ：</strong></p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点 ：</strong></p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗?</strong> 大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h3 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h3><h4 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h4><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。<br>为何能够通过 key 快速取出 value呢？ 原因在于<strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hash</span> <span class="operator">=</span> hashfunc(key)</span><br><span class="line"><span class="attribute">index</span> <span class="operator">=</span> hash % array_size</span><br></pre></td></tr></table></figure><p><img src="/2023/01/24/MySQL/Hash.png"></p><p>但是！哈希算法有个<strong>Hash冲突 问题</strong>，也就是说多个不同的key最后得到的 index 相同。通常情况下，我们常用的解决办法是<strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后HashMap为了减少链表过长的时候搜索时间过长引入了红黑树。<br><img src="/2023/01/24/MySQL/%E9%93%BE%E5%9C%B0%E5%9D%80.png"></p><p>为了减少Hash冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。既然哈希表这么快，为什么MySQL 没有使用其作为索引的数据结构呢？</p><ol><li><strong>Hash冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</li><li><strong>Hash索引不支持顺序和范围查询</strong>(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</li></ol><p>试想一种情况:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> id &lt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure><p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p><h4 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h4><p>B 树也称 B-树,全称为多路平衡查找树，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced（平衡）的意思。目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p><p>MyISAM 引擎中，B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的Key存在，则取出其 data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h4><p>数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 null，不能重复。<br>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。<br><img src="/2023/01/24/MySQL/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png"></p><h4 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h4><p>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。唯一索引，普通索引，前缀索引等索引属于二级索引。</p><ul><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ul><p><img src="/2023/01/24/MySQL/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png"></p><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。<br>在 MySQL 中，InnoDB 引擎的表的 .ibd文件就包含了该表的索引和数据，对于InnoDB引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p><strong>优点：</strong> 聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。<br><strong>缺点：</strong></p><ol><li>依赖于有序的数据 ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li>更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><p>非聚集索引即索引结构和数据分开存放的索引。</p><p>二级索引属于非聚集索引。非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。<br><strong>优点：</strong> 更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><p><strong>缺点</strong>：</p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li>可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><p>这是 MySQL 的表的文件截图:<br><img src="/2023/01/24/MySQL/MySQL%E8%A1%A8%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%AA%E5%9B%BE.png"></p><p>聚集索引和非聚集索引:<br><img src="/2023/01/24/MySQL/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png"></p><h4 id="非聚集索引一定回表查询吗"><a href="#非聚集索引一定回表查询吗" class="headerlink" title="非聚集索引一定回表查询吗"></a>非聚集索引一定回表查询吗</h4><p>非聚集索引不一定回表查询。</p><p>试想一种情况，用户准备使用SQL查询用户名，而用户名字段正好建立了索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">试想一种情况，用户准备使用 <span class="keyword">SQL</span> 查询用户名，而用户名字段正好建立了索引。</span><br></pre></td></tr></table></figure><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p><p><strong>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?</strong><br>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p><img src="/2023/01/24/MySQL/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.png"></p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>使用表中的多个字段创建索引，就是 联合索引，也叫 组合索引 或 复合索引。</p><h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 &gt;、&lt;、between 和 以%开头的like查询 等条件，才会停止匹配。<br><strong>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</strong></p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推是 MySQL 5.6版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><h3 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h3><ol><li><p>选择合适的字段创建索引</p><ul><li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul></li><li><p>被频繁更新的字段应该慎重建立索引，虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p></li><li><p>尽可能的考虑建立联合索引而不是单列索引，因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p></li><li><p>注意避免冗余索引，冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p></li><li><p>考虑在字符串类型的字段上使用前缀索引代替普通索引。前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p></li></ol><h3 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h3><ul><li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li><li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li><li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li><li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li></ul><h2 id="MySQL三大日志-binlog、redo-log和undo-log-详解"><a href="#MySQL三大日志-binlog、redo-log和undo-log-详解" class="headerlink" title="MySQL三大日志(binlog、redo log和undo log)详解"></a>MySQL三大日志(binlog、redo log和undo log)详解</h2><p>MySQL日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）。<br><img src="/2023/01/24/MySQL/MySQL%E6%97%A5%E5%BF%97.png"></p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力。比如MySQL实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性与完整性。<br><img src="/2023/01/24/MySQL/redoLog.png"></p><p>MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。<br>更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在Buffer Pool里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。<br><img src="/2023/01/24/MySQL/redo%E5%88%B7%E7%9B%98.png"></p><p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p><blockquote><p>每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p></blockquote><h4 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h4><p>InnoDB存储引擎为redo log的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持三种策略：</p><ul><li>0 ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li><li>1 ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li><li>2 ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li></ul><p>innodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘，另外，InnoDB存储引擎有一个后台线程，每隔1 秒，就会把redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。<br>也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入redo log buffer 中，这些 redo log 记录会被后台线程刷盘。<br><img src="/2023/01/24/MySQL/%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA.png"></p><p>除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。下面是不同刷盘策略的流程图。</p><h5 id="innodb-flush-log-at-trx-commit-0"><a href="#innodb-flush-log-at-trx-commit-0" class="headerlink" title="innodb_flush_log_at_trx_commit=0"></a>innodb_flush_log_at_trx_commit=0</h5><p><img src="/2023/01/24/MySQL/innodb_flush_log_at_trx_commit.png"></p><p>为0时，如果MySQL挂了或宕机可能会有1秒数据的丢失。</p><h5 id="innodb-flush-log-at-trx-commit-1"><a href="#innodb-flush-log-at-trx-commit-1" class="headerlink" title="innodb_flush_log_at_trx_commit=1"></a>innodb_flush_log_at_trx_commit=1</h5><p><img src="/2023/01/24/MySQL/innodb_flush_log_at_trx_commit_1.png"></p><p>为1时， 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p><h5 id="innodb-flush-log-at-trx-commit-2"><a href="#innodb-flush-log-at-trx-commit-2" class="headerlink" title="innodb_flush_log_at_trx_commit=2"></a>innodb_flush_log_at_trx_commit=2</h5><p><img src="/2023/01/24/MySQL/innodb_flush_log_at_trx_commit_2.png"></p><p>为2时， 只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page cache）。如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</p><h4 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h4><p>硬盘上存储的redo log日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。<br><img src="/2023/01/24/MySQL/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84.png"></p><p>在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint：</p><ul><li>write pos 是当前记录的位置，一边写一边后移</li><li>checkpoint 是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。<br><img src="/2023/01/24/MySQL/%E5%88%B7%E7%9B%98redolog.png"></p><p>如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。<br><img src="/2023/01/24/MySQL/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E6%BB%A1.png"></p><h2 id="MySQL-性能优化"><a href="#MySQL-性能优化" class="headerlink" title="MySQL 性能优化"></a>MySQL 性能优化</h2><h3 id="数据库命令规范"><a href="#数据库命令规范" class="headerlink" title="数据库命令规范"></a>数据库命令规范</h3><ul><li>所有数据库对象名称必须使用小写字母并用下划线分割</li><li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li><li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li><li>临时库表必须以 tmp_ 为前缀并以日期为后缀，备份表必须以 bak_ 为前缀并以日期 (时间戳) 为后缀</li><li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li></ul><h3 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h3><h4 id="所有表必须使用-InnoDB-存储引擎"><a href="#所有表必须使用-InnoDB-存储引擎" class="headerlink" title="所有表必须使用 InnoDB 存储引擎"></a>所有表必须使用 InnoDB 存储引擎</h4><p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p><h4 id="数据库和表的字符集统一使用-UTF8"><a href="#数据库和表的字符集统一使用-UTF8" class="headerlink" title="数据库和表的字符集统一使用 UTF8"></a>数据库和表的字符集统一使用 UTF8</h4><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><h4 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="所有表和字段都需要添加注释"></a>所有表和字段都需要添加注释</h4><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p><h4 id="尽量控制单表数据量的大小，建议控制在-500-万以内"><a href="#尽量控制单表数据量的大小，建议控制在-500-万以内" class="headerlink" title="尽量控制单表数据量的大小，建议控制在 500 万以内"></a>尽量控制单表数据量的大小，建议控制在 500 万以内</h4><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。<br>可以用<strong>历史数据归档</strong>（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。</p><h4 id="谨慎使用-MySQL-分区表"><a href="#谨慎使用-MySQL-分区表" class="headerlink" title="谨慎使用 MySQL 分区表"></a>谨慎使用 MySQL 分区表</h4><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；谨慎选择分区键，跨分区查询效率可能更低；建议采用物理分表的方式管理大数据。</p><h4 id="经常一起使用的列放到一个表中"><a href="#经常一起使用的列放到一个表中" class="headerlink" title="经常一起使用的列放到一个表中"></a>经常一起使用的列放到一个表中</h4><p>避免更多的关联操作。</p><h4 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="禁止在表中建立预留字段"></a>禁止在表中建立预留字段</h4><ul><li>预留字段的命名很难做到见名识义。</li><li>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li><li>对预留字段类型的修改，会对表进行锁定。</li></ul><h4 id="禁止在数据库中存储文件（比如图片）这类大的二进制数据"><a href="#禁止在数据库中存储文件（比如图片）这类大的二进制数据" class="headerlink" title="禁止在数据库中存储文件（比如图片）这类大的二进制数据"></a>禁止在数据库中存储文件（比如图片）这类大的二进制数据</h4><p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。</p><h4 id="不要被数据库范式所束缚"><a href="#不要被数据库范式所束缚" class="headerlink" title="不要被数据库范式所束缚"></a>不要被数据库范式所束缚</h4><p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p><h3 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h3><h4 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h4><p>存储字节越小，占用也就空间越小，性能也越好。</p><p><strong>a.某些字符串可以转换成数字类型存储比如可以将IP地址转换成整形数据。</strong><br>数字是连续的，性能更好，占用空间也更小。<br>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。MySQL 提供了两个方法来处理 ip 地址：</p><ul><li>INET_ATON() ： 把 ip 转为无符号整型 (4-8 位)</li><li>INET_NTOA() :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 INET_ATON() 把 ip 地址转为整型，显示数据时，使用 INET_NTOA() 把整型的 ip 地址转为地址显示即可。</p><p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。</strong></p><p>无符号相对于有符号可以多出一倍的存储空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SIGNED</span> INT -<span class="number">2147483648</span>~<span class="number">2147483647</span></span><br><span class="line"><span class="attribute">UNSIGNED</span> INT <span class="number">0</span>~<span class="number">4294967295</span></span><br></pre></td></tr></table></figure><p><strong>c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p><h4 id="避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据"><a href="#避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据" class="headerlink" title="避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据"></a>避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h4><p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong><br>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p><p><strong>b. TEXT 或 BLOB 类型只能使用前缀索引</strong></p><p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p><h4 id="避免使用-ENUM-类型"><a href="#避免使用-ENUM-类型" class="headerlink" title="避免使用 ENUM 类型"></a>避免使用 ENUM 类型</h4><ul><li>修改 ENUM 值需要使用 ALTER 语句；</li><li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li><li>ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li></ul><h4 id="尽可能把所有列定义为-NOT-NULL"><a href="#尽可能把所有列定义为-NOT-NULL" class="headerlink" title="尽可能把所有列定义为 NOT NULL"></a>尽可能把所有列定义为 NOT NULL</h4><p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p><ul><li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li><li>进行比较和计算时要对 NULL 值做特别的处理。</li></ul><h4 id="使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间"><a href="#使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间" class="headerlink" title="使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间"></a>使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h4><p>TIMESTAMP存储的时间范围1970-01-01 00:00:01 ~ 2038-01-19-03:14:07TIMESTAMP 占用4字节和INT相同，但比INT可读性高，超出TIMESTAMP取值范围的使用DATETIME类型存储。</p><p>经常会有人用字符串存储日期型的数据（不正确的做法）：</p><ul><li>缺点 1：无法用日期函数进行计算和比较</li><li>缺点 2：用字符串存储日期要占用更多的空间</li></ul><h4 id="同财务相关的金额类数据必须使用-decimal-类型"><a href="#同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="同财务相关的金额类数据必须使用 decimal 类型"></a>同财务相关的金额类数据必须使用 decimal 类型</h4><ul><li>非精准浮点 ：float,double</li><li>精准浮点 ：decimal</li></ul><p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据。<br>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p><h4 id="单表不要包含过多字段"><a href="#单表不要包含过多字段" class="headerlink" title="单表不要包含过多字段"></a>单表不要包含过多字段</h4><p>如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。</p><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><h4 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h4><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h4 id="禁止使用全文索引"><a href="#禁止使用全文索引" class="headerlink" title="禁止使用全文索引"></a>禁止使用全文索引</h4><p>全文索引不适用于OLTP场景。</p><h4 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h4><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h4 id="每个-InnoDB-表必须有个主键"><a href="#每个-InnoDB-表必须有个主键" class="headerlink" title="每个 InnoDB 表必须有个主键"></a>每个 InnoDB 表必须有个主键</h4><p>InnoDB是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>InnoDB 是按照主键索引的顺序来组织表的</p><ul><li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li><li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li><li>主键建议使用自增 ID 值</li></ul><h4 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h4><ul><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>多表 join 的关联列</li></ul><h4 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h4><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li><li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><h4 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h4><ul><li>重复索引示例：primary key(id)、index(id)、unique index(id)</li><li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li></ul><h4 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h4><blockquote><p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p></blockquote><p>覆盖索引的好处：</p><ul><li>避免InnoDB表进行索引的二次查询: InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li>可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><h4 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="索引 SET 规范"></a>索引 SET 规范</h4><p>尽量避免使用外键约束</p><ul><li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li><li>外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>外键会影响父表和子表的写操作从而降低性能</li></ul><h3 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h3><h4 id="优化对性能影响较大的-SQL-语句"><a href="#优化对性能影响较大的-SQL-语句" class="headerlink" title="优化对性能影响较大的 SQL 语句"></a>优化对性能影响较大的 SQL 语句</h4><p>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句；通俗的说，MySQL慢查询日志是排查问题的SQL语句，以及检查当前MySQL性能的一个重要功能。如果不是调优需要，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。默认情况下，慢查询日志功能是关闭的。可以通过以下命令查看是否开启慢查询日志功能。<br>查看是否开启慢查询功能：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; SHOW VARIABLES LIKE &#x27;slow_query%&#x27;;</span></span><br><span class="line"><span class="section">+---------------------+---------------------------------------------------------------------+</span></span><br><span class="line"><span class="section">| Variable_name       | Value                                                               |</span></span><br><span class="line"><span class="section">+---------------------+---------------------------------------------------------------------+</span></span><br><span class="line">| slow<span class="emphasis">_query_log      | OFF                                                                 |</span></span><br><span class="line"><span class="emphasis">| slow_query_log_</span>file | C:\ProgramData\MySQL\MySQL Server 5.7\Data\LAPTOP-UHQ6V8KP-slow.log |</span><br><span class="line"><span class="code">+---------------------+</span>---------------------------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.02 sec)</span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; SHOW VARIABLES LIKE &#x27;long_query_time&#x27;;</span></span><br><span class="line"><span class="section">+-----------------+-----------+</span></span><br><span class="line"><span class="section">| Variable_name   | Value     |</span></span><br><span class="line"><span class="section">+-----------------+-----------+</span></span><br><span class="line"><span class="section">| long_query_time | 10.000000 |</span></span><br><span class="line"><span class="section">+-----------------+-----------+</span></span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p><img src="/2023/01/24/MySQL/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%9F%A5%E7%9C%8B.png"></p><p>参数说明如下：</p><ul><li>slow_query_log：慢查询开启状态</li><li>slow_query_log_file：慢查询日志存放的位置（一般设置为 MySQL 的数据存放目录）</li><li>long_query_time：查询超过多少秒才记录</li><li>log_queries_not_using_indexes 如果值设置为ON，则会记录所有没有利用索引的查询（注意：如果只是将log_queries_not_using_indexes设置为ON，而将slow_query_log设置为OFF，此时该设置也不会生效，即该设置生效的前提是slow_query_log的值设置为ON），一般在性能调优的时候会暂时开启。</li></ul><h4 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="充分利用表上已经存在的索引"></a>充分利用表上已经存在的索引</h4><p>避免使用双%号的查询条件。如：a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。<br>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><h4 id="禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h4><ul><li>SELECT * 消耗更多的 CPU 和 IO 以网络带宽资源</li><li>SELECT * 无法使用覆盖索引</li><li>SELECT &lt;字段列表&gt; 可减少表结构变更带来的影响</li></ul><h4 id="禁止使用不含字段列表的-INSERT-语句"><a href="#禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="禁止使用不含字段列表的 INSERT 语句"></a>禁止使用不含字段列表的 INSERT 语句</h4><p>如：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><p>应使用：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into <span class="literal">t</span>(<span class="name">c1</span>,c2,c3) values (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h4><ul><li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li><li>只传参数，比传递 SQL 语句更高效。</li><li>相同语句可以一次解析，多次使用，提高处理效率。</li></ul><h4 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h4><p>隐式转换会导致索引失效如:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="type">name</span>,phone <span class="keyword">from</span> customer <span class="keyword">where</span> id = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="避免使用子查询，可以把子查询优化为 join 操作"></a>避免使用子查询，可以把子查询优化为 join 操作</h4><p>通常子查询在in子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p>子查询性能差的原因： 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h4 id="避免使用-JOIN-关联太多的表"><a href="#避免使用-JOIN-关联太多的表" class="headerlink" title="避免使用 JOIN 关联太多的表"></a>避免使用 JOIN 关联太多的表</h4><p>对于MySQL来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。<br>在 MySQL 中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。同时对于关联操作来说，会产生临时表操作，影响查询效率，<strong>MySQL 最多允许关联 61 个表，建议不超过 5 个</strong>。</p><h4 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h4><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><h4 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="对应同一列进行 or 判断时，使用 in 代替 or"></a>对应同一列进行 or 判断时，使用 in 代替 or</h4><p>in的值不要超过500个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><h4 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="禁止使用 order by rand() 进行随机排序"></a>禁止使用 order by rand() 进行随机排序</h4><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h4 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE 从句中禁止对列进行函数转换和计算"></a>WHERE 从句中禁止对列进行函数转换和计算</h4><p>对列进行函数转换或计算时会导致无法使用索引。</p><p>不推荐：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="built_in">date</span>(create_time)=<span class="string">&#x27;20190101&#x27;</span></span><br></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where create_time &gt;= &#x27;<span class="number">20190101</span>&#x27; and create_time &lt; &#x27;<span class="number">20190102</span>&#x27;</span><br></pre></td></tr></table></figure><h4 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h4><ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>UNION ALL 不会再对结果集进行去重操作</li></ul><h4 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="拆分复杂的大 SQL 为多个小 SQL"></a>拆分复杂的大 SQL 为多个小 SQL</h4><ul><li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li><li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>SQL 拆分后可以通过并行执行来提高处理效率</li></ul><h4 id="程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="程序连接不同的数据库使用不同的账号，禁止跨库查询"></a>程序连接不同的数据库使用不同的账号，禁止跨库查询</h4><ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul><h3 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h3><h4 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h4><p><strong>大批量操作可能会造成严重的主从延迟</strong></p><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p><p><strong>避免产生大事务操作</strong></p><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。</p><h4 id="对于大表使用-pt-online-schema-change-修改表结构"><a href="#对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="对于大表使用 pt-online-schema-change 修改表结构"></a>对于大表使用 pt-online-schema-change 修改表结构</h4><ul><li>避免大表修改产生的主从延迟</li><li>避免在对表字段进行修改时进行锁表</li></ul><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。<br>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p><h4 id="禁止为程序使用的账号赋予-super-权限"><a href="#禁止为程序使用的账号赋予-super-权限" class="headerlink" title="禁止为程序使用的账号赋予 super 权限"></a>禁止为程序使用的账号赋予 super 权限</h4><ul><li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li><li>super 权限只能留给 DBA 处理问题的账号使用</li></ul><h4 id="对于程序连接数据库账号-遵循权限最小原则"><a href="#对于程序连接数据库账号-遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号,遵循权限最小原则"></a>对于程序连接数据库账号,遵循权限最小原则</h4><ul><li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li><li>程序使用的账号原则上不准有 drop 权限</li></ul><h2 id="InnoDB存储引擎对MVCC的实现"><a href="#InnoDB存储引擎对MVCC的实现" class="headerlink" title="InnoDB存储引擎对MVCC的实现"></a>InnoDB存储引擎对MVCC的实现</h2><h3 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h3><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>对于 一致性非锁定读（Consistent Nonlocking Reads）的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。<br>在 InnoDB 存储引擎中，多版本控制 (multi versioning)就是对非锁定读的实现。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)</p><p>在Repeatable Read 和Read Committed两个隔离级别下，如果是执行普通的 select 语句（不包括 select … lock in share mode ,select … for update）则会使用 一致性非锁定读（MVCC）。并且在 Repeatable Read 下 MVCC 实现了可重复读和防止部分幻读。</p><h4 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h4><p>如果执行的是下列语句，就是锁定读（Locking Reads）。</p><ul><li>select … lock in share mode</li><li>select … for update</li><li>insert、update、delete 操作</li></ul><p>在锁定读下，读取的是数据的最新版本，这种读也被称为当前读（current read）。锁定读会对读取到的记录加锁：</p><ul><li>select … lock in share mode：对记录加 S 锁，其它事务也可以加S锁，如果加 x 锁则会被阻塞</li><li>select … for update、insert、update、delete：对记录加 X 锁，且其它事务不能加任何锁</li></ul><p>在一致性非锁定读下，即使读取的记录已被其它事务加上 X 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 Repeatable Read 下 MVCC 防止了部分幻读，这边的 “部分” 是指在 一致性非锁定读 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong>InnoDB 在实现Repeatable Read 时，如果执行的是当前读，则会对读取的记录使用 Next-key Lock ，来防止其它事务在间隙间插入数据</strong>。</p><h3 id="InnoDB-对-MVCC-的实现"><a href="#InnoDB-对-MVCC-的实现" class="headerlink" title="InnoDB 对 MVCC 的实现"></a>InnoDB 对 MVCC 的实现</h3><p>MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的DB_TRX_ID和Read View来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改。</p><h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><p>在内部，InnoDB 存储引擎为每行数据添加了三个 隐藏字段：</p><ul><li>DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务 id。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除</li><li>DB_ROLL_PTR（7字节） 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空</li><li>DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引</li></ul><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadView</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">trx_id_t</span> m_low_limit_id;      <span class="comment">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">trx_id_t</span> m_up_limit_id;       <span class="comment">/* 小于这个 ID 的事务均可见 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">trx_id_t</span> m_creator_trx_id;    <span class="comment">/* 创建该 Read View 的事务ID */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">trx_id_t</span> m_low_limit_no;      <span class="comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">ids_t</span> m_ids;                  <span class="comment">/* 创建 Read View 时的活跃事务列表 */</span></span><br><span class="line"></span><br><span class="line">  m_closed;                     <span class="comment">/* 标记 Read View 是否 close */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Read View主要是用来做可见性判断，里面保存了当前对本事务不可见的其他活跃事务，主要有以下字段：</p><ul><li>m_low_limit_id：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li><li>m_up_limit_id：活跃事务列表 m_ids 中最小的事务 ID，如果 m_ids 为空，则 m_up_limit_id 为 m_low_limit_id。小于这个 ID 的数据版本均可见</li><li>m_ids：Read View 创建时其他未提交的活跃事务 ID 列表。创建 Read View时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。m_ids 不包括当前事务自己和已提交的事务（正在内存中）</li><li>m_creator_trx_id：创建该 Read View 的事务 ID</li></ul><p><strong>事务可见性示意图：</strong><br><img src="/2023/01/24/MySQL/%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%A7%81%E6%80%A7.png"></p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo-log"></a>undo-log</h4><p>undo log 主要有两个作用：</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读</li></ul><p><strong>在InnoDB 存储引擎中undo log分为两种：insert undo log和update undo log：</strong></p><ol><li>insert undo log：指在insert操作中产生的undo log。因为insert操作的记录只对事务本身可见，对其他事务不可见，故该undo log可以在事务提交后直接删除。不需要进行purge操作</li></ol><p><strong>insert 时的数据初始状态：</strong><br><img src="/2023/01/24/MySQL/insert.png"></p><ol start="2"><li>update undo log：update 或 delete 操作中产生的 undo log。该 undo log可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge线程 进行最后的删除</li></ol><p><strong>数据第一次被修改时：</strong><br><img src="/2023/01/24/MySQL/update.png"><br><strong>数据第二次被修改时：</strong><br><img src="/2023/01/24/MySQL/update_2.png"></p><p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 undo log 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p><h4 id="数据可见性算法"><a href="#数据可见性算法" class="headerlink" title="数据可见性算法"></a>数据可见性算法</h4><p>在InnoDB存储引擎中，创建一个新事务后，执行每个select语句前，都会创建一个快照（Read View），快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号。<br>其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，InnoDB 会将该记录行的 DB_TRX_ID 与 Read View 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件。<br>具体的比较算法如下：<br><img src="/2023/01/24/MySQL/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AE%97%E6%B3%95.png"></p><ol><li><p>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</p></li><li><p>如果 DB_TRX_ID &gt;= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</p></li><li><p>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</p></li><li><p>如果 m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）</p><ul><li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</li><li>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</li></ul></li><li><p>在该记录行的 DB_ROLL_PTR 指针所指向的 undo log 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</p></li></ol><h3 id="RC-和-RR-隔离级别下-MVCC-的差异"><a href="#RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="RC 和 RR 隔离级别下 MVCC 的差异"></a>RC 和 RR 隔离级别下 MVCC 的差异</h3><p>在事务隔离级别RC和RR（InnoDB 存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用 MVCC（非锁定一致性读），但它们生成 Read View 的时机却不同：</p><ul><li>在 RC 隔离级别下的 每次select 查询前都生成一个Read View (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 第一次select 数据前生成一个Read View（m_ids 列表）</li></ul><h3 id="MVCC-解决不可重复读问题"><a href="#MVCC-解决不可重复读问题" class="headerlink" title="MVCC 解决不可重复读问题"></a>MVCC 解决不可重复读问题</h3><p>虽然RC和RR都通过 MVCC 来读取快照数据，但由于 生成 Read View 时机不同，从而在 RR 级别下实现可重复读。<br>举个例子：<br><img src="/2023/01/24/MySQL/MVCC%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png"></p><h4 id="在-RC-下-ReadView-生成情况"><a href="#在-RC-下-ReadView-生成情况" class="headerlink" title="在 RC 下 ReadView 生成情况"></a>在 RC 下 ReadView 生成情况</h4><p><strong>1. 假设时间线来到 T4 ，那么此时数据行 id = 1 的版本链为：</strong><br><img src="/2023/01/24/MySQL/RC%E4%B8%8BReadView.png"></p><p>由于 RC 级别下每次查询都会生成Read View ，并且事务 101、102 并未提交，此时 103 事务生成的 Read View 中活跃的事务 m_ids 为：[101,102] ，m_low_limit_id为：104，m_up_limit_id为：101，m_creator_trx_id 为：103</p><ul><li>此时最新记录的 DB_TRX_ID 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 m_ids 列表中查找，发现 DB_TRX_ID 存在列表中，那么这个记录不可见</li><li>根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 还是 101，不可见</li><li>继续找上一条 DB_TRX_ID为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 name = 菜花</li></ul><p><strong>2. 时间线来到 T6 ，数据的版本链为：</strong><br><img src="/2023/01/24/MySQL/T6.png"></p><p>因为在 RC 级别下，重新生成 Read View，这时事务 101 已经提交，102 并未提交，所以此时 Read View 中活跃的事务 m_ids：[102] ，m_low_limit_id为：104，m_up_limit_id为：102，m_creator_trx_id为：103</p><ul><li>此时最新记录的 DB_TRX_ID 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 m_ids 列表中查找，发现 DB_TRX_ID 存在列表中，那么这个记录不可见</li><li>根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 为 101，满足 101 &lt; m_up_limit_id，记录可见，所以在 T6 时间点查询到数据为 name = 李四，与时间 T4 查询到的结果不一致，不可重复读！</li></ul><p><strong>3. 时间线来到 T9 ，数据的版本链为：</strong><br><img src="/2023/01/24/MySQL/T9.png"></p><p>重新生成 Read View， 这时事务 101 和 102 都已经提交，所以 m_ids 为空，则 m_up_limit_id = m_low_limit_id = 104，最新版本事务 ID 为 102，满足 102 &lt; m_low_limit_id，可见，查询结果为 name = 赵六</p><p><strong>总结： 在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p><h4 id="在-RR-下-ReadView-生成情况"><a href="#在-RR-下-ReadView-生成情况" class="headerlink" title="在 RR 下 ReadView 生成情况"></a>在 RR 下 ReadView 生成情况</h4><p>在可重复读级别下，只会在事务开始后第一次读取数据时生成一个 Read View（m_ids 列表）</p><p><strong>1. 在 T4 情况下的版本链为：</strong><br><img src="/2023/01/24/MySQL/RR-T4.png"></p><p>在当前执行 select 语句时生成一个 Read View，此时 m_ids：[101,102] ，m_low_limit_id为：104，m_up_limit_id为：101，m_creator_trx_id 为：103</p><p>此时和 RC 级别下一样：</p><ul><li>最新记录的 DB_TRX_ID 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 m_ids 列表中查找，发现 DB_TRX_ID 存在列表中，那么这个记录不可见</li><li>根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 还是 101，不可见</li><li>继续找上一条 DB_TRX_ID为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 name = 菜花</li></ul><p><strong>2. 时间点 T6 情况下：</strong><br><img src="/2023/01/24/MySQL/RR-T6.png"></p><p>在 RR 级别下只会生成一次Read View，所以此时依然沿用 m_ids ：[101,102] ，m_low_limit_id为：104，m_up_limit_id为：101，m_creator_trx_id 为：103</p><ul><li>最新记录的 DB_TRX_ID 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 m_ids 列表中查找，发现 DB_TRX_ID 存在列表中，那么这个记录不可见</li><li>根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 为 101，不可见</li><li>继续根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 还是 101，不可见</li><li>继续找上一条 DB_TRX_ID为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 name = 菜花</li></ul><p><strong>3. 时间点 T9 情况下：</strong><br><img src="/2023/01/24/MySQL/RR-T9.png"></p><p>此时情况跟 T6 完全一样，由于已经生成了 Read View，此时依然沿用 m_ids ：[101,102] ，所以查询结果依然是 name = 菜花</p><h3 id="MVCC➕Next-key-Lock-防止幻读"><a href="#MVCC➕Next-key-Lock-防止幻读" class="headerlink" title="MVCC➕Next-key-Lock 防止幻读"></a>MVCC➕Next-key-Lock 防止幻读</h3><p>InnoDB存储引擎在 RR 级别下通过 MVCC和 Next-key Lock 来解决幻读问题：</p><ol><li>执行普通 select，此时会以 MVCC 快照读的方式读取数据<br>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</li><li>执行 select…for update/lock in share mode、insert、update、delete 等当前读<br>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="能用-MySQL-直接存储文件（比如图片）吗？"><a href="#能用-MySQL-直接存储文件（比如图片）吗？" class="headerlink" title="能用 MySQL 直接存储文件（比如图片）吗？"></a>能用 MySQL 直接存储文件（比如图片）吗？</h3><p>可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。可以选择使用云服务厂商提供的开箱即用的文件存储或者对象存储服务，成熟稳定，价格也比较低。<br><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p><h3 id="表中有大字段-X（例如：text-类型），且字段-X-不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#表中有大字段-X（例如：text-类型），且字段-X-不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="表中有大字段 X（例如：text 类型），且字段 X 不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>表中有大字段 X（例如：text 类型），且字段 X 不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h3><p>如果字段里面有大字段（text,blob)类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了。 MYSQL 数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多。此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后，对字段的 UPDAE 就要 UPDATE 多个表了。</p><h3 id="MySQL-中-InnoDB-引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#MySQL-中-InnoDB-引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成（或称实现）的？"></a>MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成（或称实现）的？</h3><p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</p><h3 id="MySQL-中控制内存分配的全局参数，有哪些？"><a href="#MySQL-中控制内存分配的全局参数，有哪些？" class="headerlink" title="MySQL 中控制内存分配的全局参数，有哪些？"></a>MySQL 中控制内存分配的全局参数，有哪些？</h3><ol><li><strong>Keybuffersize</strong><ul><li>keybuffersize 指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Keyreadrequests 和 Keyreads，可以知道 keybuffersize 设置是否合理。比例 keyreads/keyreadrequests 应该尽可能的低，至少是1:100，1:1000 更好（上述状态值可以使用 SHOW STATUS LIKE‘keyread%’获得）。</li><li> keybuffersize 只对 MyISAM 表起作用。即使你不使用 MyISAM 表，但是内部的临时磁盘表是 MyISAM 表，也要使用该值。可以使用检查状态值 createdtmpdisktables 得知详情。对于 1G 内存的机器，如果不使用 MyISAM 表，推荐值是 16M（8-64M）</li><li>keybuffersize 设置注意事项 <ol><li>单个 keybuffer 的大小不能超过 4G，如果设置超过 4G，就有可能遇到下面 3 个bug: <a href="http://bugs.mysql.com/bug.php?id=29446">http://bugs.mysql.com/bug.php?id=29446</a>  <a href="http://bugs.mysql.com/bug.php?id=29419">http://bugs.mysql.com/bug.php?id=29419</a> <a href="http://bugs.mysql.com/bug.php?id=5731">http://bugs.mysql.com/bug.php?id=5731</a></li><li>建议 keybuffer 设置为物理内存的 1/4(针对 MyISAM 引擎)，甚至是物理内存的 30%~40%，如果 keybuffersize 设置太大，系统就会频繁的换页，降低系统性能。因为 MySQL 使用操作系统的缓存来缓存数据，所以我们得为系统留够足够的内存；在很多情况下数据要比索引大得多。</li><li>如果机器性能优越，可以设置多个keybuffer,分别让不同的 keybuffer 来缓存专门的索引；</li></ol></li><li>innodbbufferpool_size表示缓冲池字节大小，InnoDB 缓存表和索引数据的内存区域。mysql 默认的值是 128M。最大值与你的CPU 体系结构有关，在 32 位操作系统，最大值是 4294967295(2^32-1) ，在 64 位操作系统，最大值为18446744073709551615 (2^64-1)。<ol><li> 在 32 位操作系统中，CPU 和操作系统实用的最大大小低于设置的最大值。如果设定的缓冲池的大小大于 1G，设置 innodbbufferpoolinstances 的值大于 1</li><li> .数据读写在内存中非常快, innodbbufferpoolsize 减少了对磁盘的读写。 当数据提交或满足检查点条件后才一次性将内存数据刷新到磁盘中。然而内存还有操作系统或数据库其他进程使用, 一般设置 buffer pool 大小为总内存的 3/4 至 4/5。 若设置不当, 内存使用可能浪费或者使用过多。 对于繁忙的服务器, buffer pool 将划分为多个实例以提高系统并发性, 减少线程间读写缓存的争用。buffer pool 的大小首先受 innodbbufferpool_instances 影响, 当然影响较小。</li></ol></li><li>querycachesize 当 mysql 接收到一条 select 类型的 query时，mysql 会对这条 query 进行 hash 计算而得到一个 hash 值，然后通过该 hash 值到 query cache 中去匹配，如果没有匹配中，则将这个hash 值存放在一个 hash 链表中，同时将 query 的结果集存放进cache 中，存放 hash 值的链表的每一个 hash 节点存放了相应 query结果集在 cache 中的地址，以及该 query 所涉及到的一些 table 的相关信息；如果通过 hash 值匹配到了一样的 query，则直接将 cache 中相应的 query 结果集返回给客户端。如果 mysql 任何一个表中的任何一条数据发生了变化，便会通知 query cache 需要与该 table 相关的query 的 cache 全部失效，并释放占用的内存地址。query cache 优缺点：<ol><li> query 语句的 hash 计算和 hash 查找带来的资源消耗。mysql 会对每条接收到的 select 类型的 query 进行 hash 计算然后查找该 query 的 cache 是否存在，虽然 hash 计算和查找的效率已经足够高了，一条 query 所带来的消耗可以忽略，但一旦涉及到高并发，有成千上万条 query 时，hash 计算和查找所带来的开销就的重视了；</li><li> query cache 的失效问题。如果表变更比较频繁，则会造成 query cache 的失效率非常高。表变更不仅仅指表中的数据发生变化，还包括结构或者索引的任何变化；</li><li> 对于不同 sql 但同一结果集的 query 都会被缓存，这样便会造成内存资源的过渡消耗。sql 的字符大小写、空格或者注释的不同，缓存都是认为是不同的 sql（因为他们的 hash 值会不同）；</li><li> 相关参数设置不合理会造成大量内存碎片，相关的参数设置会稍后介绍。</li></ol></li><li> readbuffersize 是 MySQL 读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL 会为它分配一段内存缓冲区。readbuffersize 变量控制这一缓冲区的大小。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。</li></ul></li></ol><h3 id="若一张表中只有一个字段-VARCHAR-N-类型，utf8-编码，则-N-最大值为多少-精确到数量级即可"><a href="#若一张表中只有一个字段-VARCHAR-N-类型，utf8-编码，则-N-最大值为多少-精确到数量级即可" class="headerlink" title="若一张表中只有一个字段 VARCHAR(N)类型，utf8 编码，则 N 最大值为多少(精确到数量级即可)?"></a>若一张表中只有一个字段 VARCHAR(N)类型，utf8 编码，则 N 最大值为多少(精确到数量级即可)?</h3><p>由于 utf8 的每个字符最多占用 3 个字节。而 MySQL 定义行的长度不能超过65535，因此 N 的最大值计算方法为：(65535-1-2)/3。减去 1 的原因是实际存储从第二个字节开始，减去 2 的原因是因为要在列表长度存储实际的字符长度，除以 3 是因为 utf8 限制：每个字符最多占用 3 个字节。</p><h3 id="SELECT-和-SELECT-全部字段-的-2-种写法有何优缺点"><a href="#SELECT-和-SELECT-全部字段-的-2-种写法有何优缺点" class="headerlink" title="[SELECT * ] 和[SELECT 全部字段]的 2 种写法有何优缺点?"></a>[SELECT * ] 和[SELECT 全部字段]的 2 种写法有何优缺点?</h3><ol><li>前者要解析数据字典，后者不需要</li><li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li><li>表字段改名，前者不需要修改，后者需要改</li><li>后者可以建立索引进行优化，前者无法优化</li><li>后者的可读性比前者要高</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;数据基础知识总结&quot;&gt;&lt;a href=&quot;#数据基础知识总结&quot; class=&quot;headerlink&quot; title=&quot;数据基础知识总结&quot;&gt;&lt;/a&gt;数据基础知识总结&lt;/h2&gt;&lt;h3 id=&quot;什么是数据库-数据库管理系统-数据库系统-数据库管理员&quot;&gt;&lt;a href=&quot;#什么是数据库-数据库管理系统-数据库系统-数据库管理员&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?&quot;&gt;&lt;/a&gt;什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据库&lt;/strong&gt; : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库管理系统&lt;/strong&gt; : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库系统&lt;/strong&gt; : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库管理员&lt;/strong&gt; : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据库系统基本构成如下图所示：&lt;br&gt;&lt;img src=&quot;/2023/01/24/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://shenhongwei33.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://shenhongwei33.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JAVA八股文</title>
    <link href="https://shenhongwei33.github.io/2023/01/24/JAVA%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>https://shenhongwei33.github.io/2023/01/24/JAVA%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2023-01-24T10:10:19.000Z</published>
    <updated>2023-01-24T13:08:23.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA基础功能"><a href="#JAVA基础功能" class="headerlink" title="JAVA基础功能"></a>JAVA基础功能</h1><h2 id="hashCode-与-equals（重要）"><a href="#hashCode-与-equals（重要）" class="headerlink" title="hashCode 与 equals（重要）"></a>hashCode 与 equals（重要）</h2><p>你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？” </p><h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。 </p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） </p><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 </p><h3 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h3><ol><li>如果两个对象相等，则hashcode一定也是相同的 </li><li>两个对象相等,对两个对象分别调用equals方法都返回true </li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） </li></ol><h2 id="简述线程，程序、进程的基本概念。以及他们之间关系是什么"><a href="#简述线程，程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="简述线程，程序、进程的基本概念。以及他们之间关系是什么"></a>简述线程，程序、进程的基本概念。以及他们之间关系是什么</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 </p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。 </p><h2 id="finally块不会被执行"><a href="#finally块不会被执行" class="headerlink" title="finally块不会被执行"></a>finally块不会被执行</h2><ul><li>在finally语句块中发生了异常。 </li><li>在前面的代码中用了System.exit()退出程序。 </li><li>程序所在的线程死亡。 </li><li>关闭CPU。 </li></ul><h2 id="Java序列化中如果有些字段不想进行序列化"><a href="#Java序列化中如果有些字段不想进行序列化" class="headerlink" title="Java序列化中如果有些字段不想进行序列化"></a>Java序列化中如果有些字段不想进行序列化</h2><p>对于不想进行序列化的变量，使用transient关键字修饰。 transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。 </p><h1 id="JAVA集合"><a href="#JAVA集合" class="headerlink" title="JAVA集合"></a>JAVA集合</h1><p><img src="en-resource://database/2953:1" alt="5f07aab90bf7d60222f47241e6951f2f.jpeg"></p><h2 id="集合底层的数据结构"><a href="#集合底层的数据结构" class="headerlink" title="集合底层的数据结构"></a>集合底层的数据结构</h2><ul><li>collection<ul><li>List<ul><li>ArrayList：Object数组</li><li>Vector：Object数组</li><li>LinkedList： 双向循环链表</li></ul></li><li>Set<ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet：LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li></ul></li></ul></li><li>Map<ul><li>HashMap：JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul></li></ul><h2 id="Java集合的快速失败机制-“fail-fast”"><a href="#Java集合的快速失败机制-“fail-fast”" class="headerlink" title="Java集合的快速失败机制 “fail-fast”"></a>Java集合的快速失败机制 “fail-fast”</h2><ul><li>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast 机制。</li><li>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li><li>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>解决办法：<ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol></li></ul><h2 id="怎么确保一个集合不能被修改"><a href="#怎么确保一个集合不能被修改" class="headerlink" title="怎么确保一个集合不能被修改"></a>怎么确保一个集合不能被修改</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"><span class="title class_">Collection</span>&lt;<span class="title class_">String</span>&gt; reslt = <span class="title class_">Collections</span>.<span class="title function_">unmodifiableCollection</span>(list);</span><br><span class="line">reslt.<span class="title function_">add</span>(<span class="string">&quot;tset&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h2><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。因为所有Collection接继承了Iterator迭代器。</p><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h3 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h3><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="literal">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">list</span>.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"><span class="keyword">list</span>.add(<span class="string">&quot;tset&quot;</span>);</span><br><span class="line">Iterator&lt;<span class="built_in">String</span>&gt; <span class="literal">it</span> = <span class="keyword">list</span>.iterator();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">it</span>.hasNext())&#123;</span><br><span class="line"><span class="literal">it</span>.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterator-和-ListIterator-的区别"><a href="#Iterator-和-ListIterator-的区别" class="headerlink" title="Iterator 和 ListIterator 的区别"></a>Iterator 和 ListIterator 的区别</h3><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h2 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List遍历的最佳实践是什么？</h2><p>遍历方式有以下几种：</p><ul><li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li><li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li><li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li></ul><p><strong>最佳实践</strong>：：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><ul><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li><li>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或foreach 遍历。</li></ul><h2 id="多线程场景下如何使用-ArrayList"><a href="#多线程场景下如何使用-ArrayList" class="headerlink" title="多线程场景下如何使用 ArrayList"></a>多线程场景下如何使用 ArrayList</h2><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.<span class="keyword">add</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">synchronizedList.<span class="keyword">add</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(synchronizedList.<span class="keyword">get</span>(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h2><p>ArrayList 中的数组定义如下：<br><code>private transient Object[] elementData;</code><br>ArrayList 的定义：<br><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code><br>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void write<span class="constructor">Object(<span class="params">java</span>.<span class="params">io</span>.ObjectOutputStream <span class="params">s</span>)</span></span><br><span class="line">        throws java.io.IOException&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="built_in">int</span> expectedModCount = modCount;</span><br><span class="line">        s.default<span class="constructor">WriteObject()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.write<span class="constructor">Int(<span class="params">size</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.write<span class="constructor">Object(<span class="params">elementData</span>[<span class="params">i</span>])</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">ConcurrentModificationException()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，<strong>只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小</strong>。</p><h2 id="HashSet-的实现原理"><a href="#HashSet-的实现原理" class="headerlink" title="HashSet 的实现原理"></a>HashSet 的实现原理</h2><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h2 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的</h2><ul><li>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</li><li>HashSet 中的add ()方法会使用HashMap 的put()方法。</li><li>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Object</span> PRESENT = <span class="keyword">new </span><span class="class title_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="built_in">HashMap</span>&lt;E,<span class="built_in">Object</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span>() &#123;</span><br><span class="line"><span class="built_in">map</span> = <span class="keyword">new </span><span class="class title_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="built_in">add</span>(E e) &#123;</span><br><span class="line"><span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>.<span class="property">put</span>(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h2><h3 id="HashMap-JDK1-8之前"><a href="#HashMap-JDK1-8之前" class="headerlink" title="HashMap JDK1.8之前"></a>HashMap JDK1.8之前</h3><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h3 id="HashMap-JDK1-8之后"><a href="#HashMap-JDK1-8之后" class="headerlink" title="HashMap JDK1.8之后"></a>HashMap JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><h3 id="JDK1-7-VS-JDK1-8-比较"><a href="#JDK1-7-VS-JDK1-8-比较" class="headerlink" title="JDK1.7 VS JDK1.8 比较"></a>JDK1.7 VS JDK1.8 比较</h3><p>JDK1.8主要解决或优化了一下问题：</p><ol><li>resize 扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li><li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol><table><thead><tr><th>不同</th><th>JDK1.7</th><th>JDK1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组+链表</td><td>数组+链表+红黑树</td></tr><tr><td>初始化方式</td><td>单独函数： inflateTable()</td><td>直接集成到了扩容函数resize() 中</td></tr><tr><td>hash值计算方式</td><td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td><td>扰动处理 =2次扰动 = 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据的规则</td><td>无冲突时，存放数组；冲突时，存放链表</td><td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt;8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr><tr><td>插入数据的方式</td><td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td><td>尾插法（直接插入到链表尾部/红黑树）</td></tr><tr><td>扩容后存储位置的计算方式</td><td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td></tr></tbody></table><h2 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a>HashMap的put方法的具体流程</h2><p>当我们put的时候，首先计算 key 的hash 值，这里调用了 hash 方法， hash 方法实际是让key.hashCode() 与key.hashCode()&gt;&gt;&gt;16 进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) &amp; hash ，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。<br><img src="en-resource://database/2955:1" alt="a4b4b97c026055cc7cae4c0a141367d6.jpeg"></p><ol><li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ol><h2 id="HashMap的扩容操作"><a href="#HashMap的扩容操作" class="headerlink" title="HashMap的扩容操作"></a>HashMap的扩容操作</h2><ol><li>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</li><li>每次扩展的时候，都是扩展2倍；</li><li>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</li></ol><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上。</p><h2 id="HashMap是怎么解决哈希冲突的"><a href="#HashMap是怎么解决哈希冲突的" class="headerlink" title="HashMap是怎么解决哈希冲突的"></a>HashMap是怎么解决哈希冲突的</h2><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞。<br>通常我们通过链地址法和开放地址法解决哈希冲突：</p><ol><li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li><li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li></ol><p>但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 （即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化。</p><h3 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash()函数"></a>hash()函数</h3><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span>(<span class="built_in">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="title function_">return</span> (<span class="built_in">key</span> == <span class="literal">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.<span class="property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p><h2 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h2><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h2 id="为什么HashMap中String、Integer这样的包装类适合作为K"><a href="#为什么HashMap中String、Integer这样的包装类适合作为K" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为K"></a>为什么HashMap中String、Integer这样的包装类适合作为K</h2><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率。</p><ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了equals() 、hashCode() 等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ul><h2 id="如果使用Object作为HashMap的Key，应该怎么办呢"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢"></a>如果使用Object作为HashMap的Key，应该怎么办呢</h2><p>重写hashCode() 和equals() 方法</p><ul><li>重写hashCode() 是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li>重写equals() 方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</li></ul><h2 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p><ul><li>这个算法应该如何设计呢<ul><li>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li></ul></li><li>那为什么是两次扰动呢？<ul><li>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</li></ul></li></ul><h2 id="HashMap-与-HashTable-有什么区别？"><a href="#HashMap-与-HashTable-有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h2><ol><li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li><li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li><li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同</strong> ：</li><li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ol><h2 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h2><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h2 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><ul><li>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</li><li>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</li><li>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的Segment的锁。<ol><li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li><li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol></li></ul><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><ul><li><p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。<br><img src="en-resource://database/2957:1" alt="3611f2c94036b29367e17023470fe888.jpeg"></p></li><li><p>插入元素过程：</p><ul><li>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</li><li>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</li><li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li><li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li></ul></li></ul><h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。</li><li>Collections 工具类的 sort 方法有两种重载的形式<ul><li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li><li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</li></ul></li></ul><h1 id="JAVA异常"><a href="#JAVA异常" class="headerlink" title="JAVA异常"></a>JAVA异常</h1><h2 id="JVM-是如何处理异常的"><a href="#JVM-是如何处理异常的" class="headerlink" title="JVM 是如何处理异常的"></a>JVM 是如何处理异常的</h2><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p><h2 id="NoClassDefFoundError-和ClassNotFoundException-区别"><a href="#NoClassDefFoundError-和ClassNotFoundException-区别" class="headerlink" title="NoClassDefFoundError 和ClassNotFoundException 区别"></a>NoClassDefFoundError 和ClassNotFoundException 区别</h2><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该<br>尝试捕获这个异常。引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致；<br>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用Class.forName,ClassLoader.loadClass 或 ClassLoader.findSystemClass<br>动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p><h2 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h2><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><p>异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。</p><ul><li>仅在异常情况下使用异常；</li><li>在可恢复的异常情况下使用异常；</li></ul><p>尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。</p><h1 id="JAVA并发编程"><a href="#JAVA并发编程" class="headerlink" title="JAVA并发编程"></a>JAVA并发编程</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="并发编程三个必要因素"><a href="#并发编程三个必要因素" class="headerlink" title="并发编程三个必要因素"></a>并发编程三个必要因素</h3><ul><li>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么，全部执行失败。</li><li>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</li></ul><h3 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h3><ul><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li><li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。</li><li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</li></ul><p>比喻：<br>并发 = 俩个人用一台电脑。<br>并行 = 俩个人分配了俩台电脑。<br>串行 = 俩个人排队使用一台电脑。</p><h3 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h3><p>可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</p><h3 id="多线程的劣势"><a href="#多线程的劣势" class="headerlink" title="多线程的劣势"></a>多线程的劣势</h3><ul><li>线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；</li><li>多线程需要协调和管理，所以需要 CPU 时间跟踪线程；</li><li>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。</li></ul><h3 id="形成死锁的四个必要条件"><a href="#形成死锁的四个必要条件" class="headerlink" title="形成死锁的四个必要条件"></a>形成死锁的四个必要条件</h3><ul><li>互斥条件：在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，就只能等待，直至占有资源的进程用毕释放。</li><li>占有且等待条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不可抢占条件：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。（比如一个进程集合，A在等B，B在等C，C在等A）</li></ul><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h4><ul><li>避免一个线程同时获得多个锁</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制</li></ul><h3 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h3><ul><li><p>继承 Thread 类；</p></li><li><p>实现 Runnable 接口；</p></li><li><p>实现 Callable 接口；</p></li><li><p>使用匿名内部类方式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateRunnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建多线程创建开始</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="keyword">new</span> <span class="built_in">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;i:&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runnable-和-callable-的区别"><a href="#runnable-和-callable-的区别" class="headerlink" title="runnable 和 callable 的区别"></a>runnable 和 callable 的区别</h3><p>相同点：</p></li><li><p>都是接口</p></li><li><p>都可以编写多线程程序</p></li><li><p>都采用Thread.start()启动线程</p></li></ul><p>不同点：</p><ul><li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息 注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li></ul><h3 id="Callable-和-Future"><a href="#Callable-和-Future" class="headerlink" title="Callable 和 Future"></a>Callable 和 Future</h3><ul><li>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</li><li>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 Callable用于产生结果，Future 用于获取结果。</li></ul><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img src="en-resource://database/2986:1" alt="feee2d7197b3927b3cae4cd9038aec09.png"></p><ul><li><p>新建(new)：新创建了一个线程对象。</p></li><li><p>就绪（可运行状态）(runnable)：线程对象创建后，当调用线程对象的start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</p></li><li><p>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p></li><li><p>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态。</p><ul><li>等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；</li><li>其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。</li></ul></li><li><p>死亡(dead)(结束)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ul><h3 id="Java-中用到的线程调度算法"><a href="#Java-中用到的线程调度算法" class="headerlink" title="Java 中用到的线程调度算法"></a>Java 中用到的线程调度算法</h3><p>计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。（Java是由JVM中的线程计数器来实现线程调度）</p><p>有两种调度模型：分时调度模型和抢占式调度模型：</p><ul><li>分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU的时间片这个也比较好理解。</li><li>Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</li></ul><h4 id="线程的调度策略"><a href="#线程的调度策略" class="headerlink" title="线程的调度策略"></a>线程的调度策略</h4><p>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p><ol><li>线程体中调用了 yield 方法让出了对 cpu 的占用权利</li><li>线程体中调用了 sleep 方法使线程进入睡眠状态</li><li>线程由于 IO 操作受到阻塞</li><li>另外一个更高优先级线程出现</li><li>在支持时间片的系统中，该线程的时间片用完</li></ol><h4 id="线程同步以及线程调度相关的方法"><a href="#线程同步以及线程调度相关的方法" class="headerlink" title="线程同步以及线程调度相关的方法"></a>线程同步以及线程调度相关的方法</h4><ul><li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li></ul><h3 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep() 和 wait() 的区别"></a>sleep() 和 wait() 的区别</h3><p>两者都可以暂停线程的执行</p><ul><li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li><li>是否释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用途不同：wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li><li>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li></ul><h3 id="你是如何调用-wait-方法的？使用-if-块还是循环？为什么？"><a href="#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？" class="headerlink" title="你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h3><ul><li>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</li><li>wait()方法应该在循环调用，因为当线程获取到CPU开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">synchronized (monitor) &#123;</span><br><span class="line">    <span class="regexp">//</span> 判断条件谓词是否得到满足</span><br><span class="line">    <span class="keyword">while</span>(!locked) &#123;</span><br><span class="line">    <span class="regexp">//</span> 等待唤醒</span><br><span class="line">        monitor.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="regexp">//</span> 处理其他的业务逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>比如：<br><img src="en-resource://database/3118:1" alt="6dc81de5ec62a231ca7a8afe234514fe.png"></li></ul><p>队列中被添加了一个元素,A,B线程被notifyAll()唤醒,可以取元素.<br><img src="en-resource://database/3120:1" alt="5368396e3293b89af6e49221751b0837.png"><br><img src="en-resource://database/3122:1" alt="0503f2c1edce6459c6fda19dfdd5d6aa.png"></p><p>我们来从代码分析:  若用if:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">synchronized (monitor) &#123;</span><br><span class="line">    <span class="comment">//  判断条件谓词是否得到满足</span></span><br><span class="line">    <span class="built_in">if</span>(queue.IsEmpty()) &#123;</span><br><span class="line">        <span class="comment">//  等待唤醒</span></span><br><span class="line">        monitor<span class="selector-class">.wait</span>(); <span class="comment">// 第五行等待状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  处理业务逻辑:从队列中取出元素</span></span><br><span class="line">       queue<span class="selector-class">.get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>则执行流程为:</strong> 线程A取出最后一个元素&gt; A释放锁 -&gt; B得到锁 -&gt; B从第五行向下执行 -&gt; B从队列中取出元素 -&gt; 越界异常</p><p>值得注意的是,因为wait住在第五行, 那么A线程执行完后,B线程也被唤醒,并且从第五行向下执行,于是就执行get()方法,发生越界异常.</p><p>若用while:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">synchronized (monitor) &#123;</span><br><span class="line">    <span class="regexp">//</span>  判断条件谓词是否得到满足</span><br><span class="line">    <span class="keyword">while</span>(queue.IsEmpty()) &#123;</span><br><span class="line">        <span class="regexp">//</span>  等待唤醒</span><br><span class="line">        monitor.wait(); <span class="regexp">//</span>第五行等待状态</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="regexp">//</span>  处理业务逻辑:从队列中取出元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>则执行流程为:</strong> 线程A取出最后一个元素&gt; A释放锁 -&gt; B得到锁 -&gt; B从第五行向下执行 -&gt; 又进行while循环 -&gt; 发现队列为空 -&gt; 继续等待</p><p>wait()方法之所以要用while而不是if是因为 :当多个线程并发访问同一个资源的时候, 若消费者同时被唤醒,但是只有一个资源可用, 那么if会导致资源被用完后直接去获取资源(发生越界异常等),而while则会让每个消费者获取之前再去判断一下资源是否可用.可用则获取,不可用则继续wait住.</p><h3 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用</h3><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p><h3 id="什么是线程同步和线程互斥，有哪几种实现方式"><a href="#什么是线程同步和线程互斥，有哪几种实现方式" class="headerlink" title="什么是线程同步和线程互斥，有哪几种实现方式"></a>什么是线程同步和线程互斥，有哪几种实现方式</h3><ul><li>当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。</li><li>在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。</li><li>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</li><li>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</li><li>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</li><li>实现线程同步的方法：<ul><li>同步代码方法：sychronized 关键字修饰的方法</li><li>同步代码块：sychronized 关键字修饰的代码块</li><li>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</li><li>使用重入锁实现线程同步：reentrantlock类是可冲入、互斥、实现了lock接口的锁他与sychronized方法具有相同的基本行为和语义</li></ul></li></ul><h3 id="在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><ul><li>在 java 虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</li><li>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</li><li>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</li></ul><h3 id="如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么"></a>如果你提交任务时，线程池队列已满，这时会发生什么</h3><p>有俩种可能：</p><ol><li>如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务。</li><li>如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue 满了，会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是 AbortPolicy。</li></ol><h3 id="对线程优先级的理解"><a href="#对线程优先级的理解" class="headerlink" title="对线程优先级的理解"></a>对线程优先级的理解</h3><ul><li>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。</li><li>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</li><li>当然，如果你真的想设置优先级可以通过setPriority()方法设置，但是设置了不一定会该变，这个是不准确的。</li></ul><h3 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h3><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><h3 id="一个线程运行时发生异常会怎样"><a href="#一个线程运行时发生异常会怎样" class="headerlink" title="一个线程运行时发生异常会怎样"></a>一个线程运行时发生异常会怎样</h3><p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</p><h3 id="Java-线程数过多会造成什么异常"><a href="#Java-线程数过多会造成什么异常" class="headerlink" title="Java 线程数过多会造成什么异常"></a>Java 线程数过多会造成什么异常</h3><ul><li>线程的生命周期开销非常高</li><li>消耗过多的 CPU：资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。</li><li>降低JVM的稳定性：在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</li></ul><h2 id="并发理论"><a href="#并发理论" class="headerlink" title="并发理论"></a>并发理论</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入时,能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。<br><img src="en-resource://database/3224:1" alt="7a393e5fb9410a7751eb3c31a0e443df.jpeg"><br>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p><ol><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li><li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li></ol><p>总结：什么是Java内存模型：java内存模型简称jmm，定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。</p><h3 id="finalize-方法什么时候被调用？析构函数-finalization-的目的是什么"><a href="#finalize-方法什么时候被调用？析构函数-finalization-的目的是什么" class="headerlink" title="finalize()方法什么时候被调用？析构函数(finalization)的目的是什么"></a>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么</h3><p>垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；finalize是Object类的一个方法，该方法在Object类中的声明protected void finalize() throws<br>Throwable { } 在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间。<br>GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。<br>Finalizetion主要用来释放被对象占用的资源（不是指内存，而是指其他资源，比如文件(File Handle)、端口(ports)、数据库连接(DB Connection)等）。然而，它不能真正有效地工作。</p><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><ul><li>程序执行的顺序按照代码的先后顺序执行。</li><li>一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，进行重新排序（重排序），它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int <span class="keyword">a</span> = <span class="number">5</span>;<span class="comment"> //语句1</span></span><br><span class="line">int r = <span class="number">3</span>;<span class="comment"> //语句2</span></span><br><span class="line"><span class="keyword">a</span> = <span class="keyword">a</span> + <span class="number">2</span>;<span class="comment"> //语句3</span></span><br><span class="line">r = <span class="keyword">a</span>*<span class="keyword">a</span>;<span class="comment"> //语句4</span></span><br></pre></td></tr></table></figure></li><li>因为重排序，他还可能执行顺序为（这里标注的是语句的执行顺序） 2-1-3-4，1-3-2-4 但绝不可能 2-1-4-3，因为这打破了依赖关系。</li><li>显然重排序对单线程运行是不会有任何问题，但是多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。</li></ul><h4 id="重排序实际执行的指令步骤"><a href="#重排序实际执行的指令步骤" class="headerlink" title="重排序实际执行的指令步骤"></a>重排序实际执行的指令步骤</h4><p><img src="en-resource://database/3225:1" alt="fc508d04001053ba3651077dc42d8fa0.jpeg"></p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p><strong>这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。</strong></p><h4 id="重排序遵守的规则"><a href="#重排序遵守的规则" class="headerlink" title="重排序遵守的规则"></a>重排序遵守的规则</h4><p><strong>as-if-serial：</strong></p><ol><li>不管怎么排序，结果不能改变</li><li>不存在数据依赖的可以被编译器和处理器重排序</li><li>一个操作依赖两个操作，这两个操作如果不存在依赖可以重排序</li><li>单线程根据此规则不会有问题，但是重排序后多线程会有问题</li></ol><p><strong>as-if-serial规则和happens-before规则的区别：</strong></p><ol><li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li><li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li></ol><h3 id="双重检验锁方式实现单例模式"><a href="#双重检验锁方式实现单例模式" class="headerlink" title="双重检验锁方式实现单例模式"></a>双重检验锁方式实现单例模式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span>&#123;</span><br><span class="line">        <span class="comment">//第一次校验singleton是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized (Singleton.<span class="keyword">class</span>)&#123;</span><br><span class="line">                <span class="comment">//第二次校验singleton是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>第一次校验：也就是第一个if（singleton==null），这个是为了代码提高代码执行效率，由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getInstance方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。</li><li>第二次校验：也就是第二个if（singleton==null），这个校验是防止二次创建实例，假如有一种情况，当singleton还未被创建时，线程t1调用getInstance方法，由于第一次判断singleton==null，此时线程t1准备继续执行，但是由于资源被线程t2抢占了，此时t2页调用getInstance方法，同样的，由于singleton并没有实例化，t2同样可以通过第一个if，然后继续往下执行，同步代码块，第二个if也通过，然后t2线程创建了一个实例singleton。此时t2线程完成任务，资源又回到t1线程，t1此时也进入同步代码块，如果没有这个第二个if，那么，t1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。</li></ul><p><strong>另外，需要注意 singleton 采用 volatile 关键字修饰也是很有必要。</strong> singleton = new Singleton();这段代码其实是分为三步执行：</p><ol><li>为 singleton 分配内存空间</li><li>初始化 singleton</li><li>将 singleton 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用getUniqueInstance() 后发现 singleton 不为空，因此返回 singleton，但此时singleton 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h3 id="synchronized-底层实现原理"><a href="#synchronized-底层实现原理" class="headerlink" title="synchronized 底层实现原理"></a>synchronized 底层实现原理</h3><ul><li>Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成，</li><li>每个对象有一个监视器锁(monitor)。每个Synchronized修饰过的代码当它的monitor被占用时就会处于锁定状态并且尝试获取monitor的所有权 ，过程：<ul><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li></ul></li></ul><blockquote><p>synchronized是可以通过 反汇编指令 javap命令，查看相应的字节码文件。</p></blockquote><h3 id="synchronized可重入的原理"><a href="#synchronized可重入的原理" class="headerlink" title="synchronized可重入的原理"></a>synchronized可重入的原理</h3><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p><h3 id="什么是自旋"><a href="#什么是自旋" class="headerlink" title="什么是自旋"></a>什么是自旋</h3><ul><li>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然</li><li>synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</li><li>忙循环：就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</li></ul><h3 id="多线程中-synchronized-锁升级的原理是什么"><a href="#多线程中-synchronized-锁升级的原理是什么" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么"></a>多线程中 synchronized 锁升级的原理是什么</h3><ul><li>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</li></ul><blockquote><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p></blockquote><ul><li>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</li><li>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，轻量级锁就会升级为重量级锁；</li><li>重量级锁是synchronized ，是 Java 虚拟机中最为基础的锁实现。在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</li></ul><h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><p><strong>相同点</strong>：两者都是可重入锁</p><blockquote><p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对<br>象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不<br>可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器<br>下降为0时才能释放锁。</p></blockquote><p><strong>主要区别如下：</strong></p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li><li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word</li></ul><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul><h3 id="Java-中能创建-volatile-数组吗"><a href="#Java-中能创建-volatile-数组吗" class="headerlink" title="Java 中能创建 volatile 数组吗"></a>Java 中能创建 volatile 数组吗</h3><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p><h3 id="volatile-变量和-atomic-变量的不同"><a href="#volatile-变量和-atomic-变量的不同" class="headerlink" title="volatile 变量和 atomic 变量的不同"></a>volatile 变量和 atomic 变量的不同</h3><ul><li>volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。</li><li>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li></ul><p>简单的说，修改volatile变量分为四步：<br>1）读取volatile变量到local<br>2）修改变量值<br>3）local值写回<br>4）插入内存屏障，即lock指令，让其他线程可见<br>这样就很容易看出来，前三步都是不安全的，取值和写回之间，不能保证没有其他线程修改。原子性需要锁来保证。</p><h3 id="Lock-接口和synchronized-对比"><a href="#Lock-接口和synchronized-对比" class="headerlink" title="Lock 接口和synchronized 对比"></a>Lock 接口和synchronized 对比</h3><ul><li>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</li><li>它的优势有：<ul><li>可以使锁更公平</li><li>可以使线程在等待锁的时候响应中断</li><li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li><li>可以在不同的范围，以不同的顺序获取和释放锁</li></ul></li><li>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</li></ul><h3 id="CAS-会产生的问题"><a href="#CAS-会产生的问题" class="headerlink" title="CAS 会产生的问题"></a>CAS 会产生的问题</h3><ul><li>ABA 问题：比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</li><li>循环时间长开销大：对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</li><li>只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h3><ul><li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li><li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</li></ul><h3 id="ThreadPoolExecutor饱和策略"><a href="#ThreadPoolExecutor饱和策略" class="headerlink" title="ThreadPoolExecutor饱和策略"></a>ThreadPoolExecutor饱和策略</h3><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:</p><ul><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：不处理新任务，直接丢弃掉。</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>： 此策略将丢弃最早的未处理的任务请求。</li></ul><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModifificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。但是由于写入时会优先创建一个副本，所以如果频繁写入，会导致性能很差，所以适合读多写少的场景。</p><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><ul><li>读写分离，读和写分开</li><li>最终一致性</li><li>使用另外开辟空间的思路，来解决并发冲突</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc 或者 full gc。</li><li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li><li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li></ul><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM-内存分哪几个区，每个区的作用"><a href="#JVM-内存分哪几个区，每个区的作用" class="headerlink" title="JVM 内存分哪几个区，每个区的作用"></a>JVM 内存分哪几个区，每个区的作用</h2><ul><li>方法区<ul><li>有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生 GC，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载</li><li>方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</li><li>该区域是被线程共享的。</li><li>方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</li></ul></li><li>虚拟机栈<ul><li>虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</li><li>虚拟机栈是线程私有的，它的生命周期与线程相同。</li><li>局部变量表里存储的是基本数据类型、returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定。</li><li>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</li><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</li></ul></li><li>本地方法栈：本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。</li><li>堆：java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作，初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配。<ul><li>堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），新生代包含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区，当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。</li></ul></li><li>程序计数器：内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。</li></ul><h2 id="GC-的两种判定方法"><a href="#GC-的两种判定方法" class="headerlink" title="GC 的两种判定方法"></a>GC 的两种判定方法</h2><ul><li><strong>引用计数法</strong>：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）的情况</li><li><strong>引用链法</strong>： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，如果有一条链能够到达 GC ROOT 就说明，不能到达 GC ROOT 就说明可以回收<ul><li>在 java 中可以作为 GC Roots 的对象有以下几种:<ul><li>虚拟机栈中引用的对象</li><li>方法区类静态属性引用的对象</li><li>方法区常量池引用的对象</li><li>本地方法栈 JNI 引用的对象</li></ul></li></ul></li></ul><p>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。</p><p>如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。</p><h2 id="SafePoint-是什么"><a href="#SafePoint-是什么" class="headerlink" title="SafePoint 是什么"></a>SafePoint 是什么</h2><p>比如 GC 的时候必须要等到 Java 线程都进入到 safepoint 的时候 VMThread 才能开始执行 GC，通常入以下位置：</p><ol><li>循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入safepoint)</li><li>方法返回前</li><li>调用方法的 call 之后</li><li>抛出异常的位置</li></ol><h2 id="GC-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"><a href="#GC-的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？" class="headerlink" title="GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？"></a>GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</h2><ul><li><strong>标记清除</strong>：这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：<ul><li>效率不高，标记和清除的效率都很低；</li><li>会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作</li></ul></li><li><strong>复制算法</strong>：为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(java 堆又分为新生代和老年代)</li><li><strong>标记整理</strong>：该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</li><li><strong>分代收集</strong>：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</li></ul><h2 id="GC-收集器有哪些？CMS-收集器与-G1-收集器的特点。"><a href="#GC-收集器有哪些？CMS-收集器与-G1-收集器的特点。" class="headerlink" title="GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。"></a>GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。</h2><ul><li>串行收集器：串行收集器使用一个单独的线程进行收集，GC 时服务有停顿时间</li><li>并行收集器：次要回收中使用多线程来执行</li></ul><p>CMS 收集器是基于“标记—清除”算法实现的，经过多次标记才会被清除；G1 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的。</p><h2 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些"></a>什么是类加载器，类加载器有哪些</h2><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。主要有一下四种类加载器:</p><ul><li>启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</li></ul><h2 id="java-类加载过程"><a href="#java-类加载过程" class="headerlink" title="java 类加载过程"></a>java 类加载过程</h2><p>java 类加载需要经历以下7个过程：</p><ul><li><strong>加载</strong>：加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：<ul><li>通过一个类的全限定名获取该类的二进制流。</li><li>将该二进制流中的静态存储结构转化为方法去运行时数据结构。</li><li>在内存中生成该类的 Class 对象，作为该类的数据访问入口。</li></ul></li><li><strong>验证</strong>：验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:<ul><li>文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型</li><li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</li><li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</li><li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</li></ul></li><li><strong>准备</strong>：准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</li><li><strong>解析</strong>：该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</li><li><strong>初始化</strong>：初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</li></ul><h2 id="简述-java-内存分配与回收策率以及Minor-GC和Major-GC"><a href="#简述-java-内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="简述 java 内存分配与回收策率以及Minor GC和Major GC"></a>简述 java 内存分配与回收策率以及Minor GC和Major GC</h2><ol><li>对象优先在堆的 Eden 区分配。</li><li>大对象直接进入老年代.</li><li>长期存活的对象将直接进入老年代.当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代 GC的时候不会触发 Minor GC,但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。</li></ol><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JAVA基础功能&quot;&gt;&lt;a href=&quot;#JAVA基础功能&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础功能&quot;&gt;&lt;/a&gt;JAVA基础功能&lt;/h1&gt;&lt;h2 id=&quot;hashCode-与-equals（重要）&quot;&gt;&lt;a href=&quot;#hashCode-与-equals（重要）&quot; class=&quot;headerlink&quot; title=&quot;hashCode 与 equals（重要）&quot;&gt;&lt;/a&gt;hashCode 与 equals（重要）&lt;/h2&gt;&lt;p&gt;你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？” &lt;/p&gt;
&lt;h3 id=&quot;hashCode（）介绍&quot;&gt;&lt;a href=&quot;#hashCode（）介绍&quot; class=&quot;headerlink&quot; title=&quot;hashCode（）介绍&quot;&gt;&lt;/a&gt;hashCode（）介绍&lt;/h3&gt;&lt;p&gt;hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。 &lt;/p&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://shenhongwei33.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA八股文" scheme="https://shenhongwei33.github.io/tags/JAVA%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>高可用设计</title>
    <link href="https://shenhongwei33.github.io/2023/01/24/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://shenhongwei33.github.io/2023/01/24/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-01-24T10:06:15.000Z</published>
    <updated>2023-01-24T14:34:17.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高可用系统设计"><a href="#高可用系统设计" class="headerlink" title="高可用系统设计"></a>高可用系统设计</h1><h2 id="什么是高可用？可用性的判断标准是啥？"><a href="#什么是高可用？可用性的判断标准是啥？" class="headerlink" title="什么是高可用？可用性的判断标准是啥？"></a>什么是高可用？可用性的判断标准是啥？</h2><p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</p><p>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</p><p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p><h2 id="系统不可用的情况"><a href="#系统不可用的情况" class="headerlink" title="系统不可用的情况"></a>系统不可用的情况</h2><ol><li>黑客攻击</li><li>硬件故障，比如服务器坏掉</li><li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。</li><li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li><li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li><li>自然灾害或者人为破坏。</li><li>。。。</li></ol><h2 id="有哪些提高系统可用性的方法"><a href="#有哪些提高系统可用性的方法" class="headerlink" title="有哪些提高系统可用性的方法"></a>有哪些提高系统可用性的方法</h2><h3 id="注重代码质量，测试严格把关"><a href="#注重代码质量，测试严格把关" class="headerlink" title="注重代码质量，测试严格把关"></a>注重代码质量，测试严格把关</h3><p>这个是最最最重要的，代码质量有问题比如比较常见的<strong>内存泄漏</strong>、<strong>循环依赖</strong>都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p><p>另外，安利这个对提高代码质量有实际效果的宝贝：</p><ul><li>sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。</li><li>Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。</li><li>IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。</li></ul><h3 id="使用集群，减少单点故障"><a href="#使用集群，减少单点故障" class="headerlink" title="使用集群，减少单点故障"></a>使用集群，减少单点故障</h3><p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。</p><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><h3 id="超时和重试机制设置"><a href="#超时和重试机制设置" class="headerlink" title="超时和重试机制设置"></a>超时和重试机制设置</h3><p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p><h3 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h3><p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 适当修改业务流程进行配合，比如用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p><h3 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h3><p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>核心应用和服务优先使用更好的硬件</li><li>监控系统资源使用情况增加报警设置。</li><li>注意备份，必要时候回滚。</li><li>灰度发布： 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li><li>定期检查/更换硬件： 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li></ol><h1 id="限流-1"><a href="#限流-1" class="headerlink" title="限流"></a>限流</h1><h2 id="何为限流？为什么要限流？"><a href="#何为限流？为什么要限流？" class="headerlink" title="何为限流？为什么要限流？"></a>何为限流？为什么要限流？</h2><p>针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。<br>限流可能会导致用户的请求无法被正确处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。<br>现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售票员无法处理。</p><h2 id="常见限流算法"><a href="#常见限流算法" class="headerlink" title="常见限流算法"></a>常见限流算法</h2><h3 id="固定窗口计数器算法"><a href="#固定窗口计数器算法" class="headerlink" title="固定窗口计数器算法"></a>固定窗口计数器算法</h3><p>固定窗口其实就是时间窗口。固定窗口计数器算法 规定了我们单位时间处理的请求数量。</p><ul><li>给定一个变量 counter 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。</li><li>1 分钟之内每处理一个请求之后就将 counter+1 ，当 counter=33 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。</li><li>等到 1 分钟结束后，将 counter 重置 0，重新开始计数。</li></ul><p>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。</p><p>就比如说我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。</p><p><img src="/2023/01/24/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%97%E6%B3%95.png"></p><h3 id="滑动窗口计数器算法"><a href="#滑动窗口计数器算法" class="headerlink" title="滑动窗口计数器算法"></a>滑动窗口计数器算法</h3><p><strong>滑动窗口计数器算法</strong>算的上是固定窗口计数器算法的升级版。</p><p>滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：它把时间以一定比例分片 。</p><p>例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理 不大于 60(请求数)/60（窗口数） 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p><p>很显然， <strong>当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</strong><br><img src="/2023/01/24/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%97%E6%B3%95.png"></p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。</p><p>如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。<br><img src="/2023/01/24/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95.png"></p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。<br><img src="/2023/01/24/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png"></p><h2 id="单机限流"><a href="#单机限流" class="headerlink" title="单机限流"></a>单机限流</h2><p>单机限流可以直接使用 Google Guava 自带的限流工具类 RateLimiter 。 RateLimiter 基于令牌桶算法，可以应对突发流量。除了最基本的令牌桶算法(平滑突发限流)实现之外，Guava 的RateLimiter还提供了<strong>平滑预热限流</strong>的算法实现。</p><p>平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。</p><p>我们直接在项目中引入 Guava 相关的依赖即可使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>31.0.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是一个简单的 Guava 平滑突发限流的 Demo。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里</span></span><br><span class="line">        RateLimiter rateLimiter = RateLimiter.<span class="built_in">create</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">double</span> sleepingTime = rateLimiter.<span class="built_in">acquire</span>(<span class="number">1</span>);</span><br><span class="line">            System.out.<span class="built_in">printf</span>(<span class="string">&quot;get 1 tokens: %ss%n&quot;</span>, sleepingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">0</span>s</span><br><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">188413</span>s</span><br><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">197811</span>s</span><br><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">198316</span>s</span><br><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">19864</span>s</span><br><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">199363</span>s</span><br><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">193997</span>s</span><br><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">199623</span>s</span><br><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">199357</span>s</span><br><span class="line"><span class="attribute">get</span> <span class="number">1</span> tokens: <span class="number">0</span>.<span class="number">195676</span>s</span><br></pre></td></tr></table></figure><p>另外，Bucket4j 是一个非常不错的基于令牌/漏桶算法的限流库。相对于，Guava 的限流工具类来说，Bucket4j 提供的限流功能更加全面。不仅支持单机限流和分布式限流，还可以集成监控，搭配 Prometheus 和 Grafana 使用。不过，毕竟 Guava 也只是一个功能全面的工具类库，其提供的开箱即用的限流功能在很多单机场景下还是比较实用的。<br>Spring Cloud Gateway 中自带的单机限流的早期版本就是基于 Bucket4j 实现的。后来，替换成了 Resilience4j。<strong>Resilience4j</strong> 是一个轻量级的容错组件，其灵感来自于 Hystrix。自Netflix 宣布不再积极开发 Hystrixopen in new window 之后，Spring 官方和 Netflix 都更推荐使用 Resilience4j 来做限流熔断。</p><p>一般情况下，为了保证系统的高可用，项目的限流和熔断都是要一起做的Resilience4j 不仅提供限流，还提供了熔断、负载保护、自动重试等保障系统高可用开箱即用的功能。并且，Resilience4j 的生态也更好，很多网关都使用 Resilience4j 来做限流熔断的。</p><p>因此，在绝大部分场景下 Resilience4j 或许会是更好的选择。如果是一些比较简单的限流场景的话，Guava 或者 Bucket4j 也是不错的选择。</p><h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><p>分布式限流常见的方案：</p><ul><li>借助中间件架限流 ：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。</li><li>网关层限流 ：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件/框架。就比如 Spring Cloud Gateway 的分布式限流实现RedisRateLimiter就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。</li></ul><p>如果你要基于 Redis 来手动实现限流逻辑的话，建议配合 Lua 脚本来做。<br>网上也有很多现成的脚本供你参考，就比如 Apache 网关项目 <a href="https://github.com/apache/incubator-shenyu">ShenYu</a> 的 RateLimiter 限流插件就基于 Redis + Lua 实现了令牌桶算法/并发令牌桶算法、漏桶算法、滑动窗口算法。</p><h1 id="降级-amp-熔断"><a href="#降级-amp-熔断" class="headerlink" title="降级&amp;熔断"></a>降级&amp;熔断</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;高可用系统设计&quot;&gt;&lt;a href=&quot;#高可用系统设计&quot; class=&quot;headerlink&quot; title=&quot;高可用系统设计&quot;&gt;&lt;/a&gt;高可用系统设计&lt;/h1&gt;&lt;h2 id=&quot;什么是高可用？可用性的判断标准是啥？&quot;&gt;&lt;a href=&quot;#什么是高可用？可用性的判断标准是啥？&quot; class=&quot;headerlink&quot; title=&quot;什么是高可用？可用性的判断标准是啥？&quot;&gt;&lt;/a&gt;什么是高可用？可用性的判断标准是啥？&lt;/h2&gt;&lt;p&gt;高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。&lt;/p&gt;
&lt;p&gt;一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。&lt;/p&gt;
&lt;p&gt;除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。&lt;/p&gt;</summary>
    
    
    
    <category term="系统设计" scheme="https://shenhongwei33.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="高可用设计" scheme="https://shenhongwei33.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>性能设计</title>
    <link href="https://shenhongwei33.github.io/2023/01/24/%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    <id>https://shenhongwei33.github.io/2023/01/24/%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-01-24T09:56:37.000Z</published>
    <updated>2023-01-24T10:03:54.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读写分离-amp-分库分表"><a href="#读写分离-amp-分库分表" class="headerlink" title="读写分离&amp;分库分表"></a>读写分离&amp;分库分表</h1><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。<br><img src="/2023/01/24/%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.png"></p><p>一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p><h3 id="读写分离会带来什么问题？如何解决？"><a href="#读写分离会带来什么问题？如何解决？" class="headerlink" title="读写分离会带来什么问题？如何解决？"></a>读写分离会带来什么问题？如何解决？</h3><p>读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 主从同步延迟 。</p><p>主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。</p><h4 id="强制将读请求路由到主库处理"><a href="#强制将读请求路由到主库处理" class="headerlink" title="强制将读请求路由到主库处理"></a>强制将读请求路由到主库处理</h4><p>既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。比如 Sharding-JDBC 就是采用的这种方案。通过使用 Sharding-JDBC 的 HintManager 分片键值管理器，我们可以强制使用主库。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HintManager hintManager = <span class="module-access"><span class="module"><span class="identifier">HintManager</span>.</span></span>get<span class="constructor">Instance()</span>;</span><br><span class="line">hintManager.set<span class="constructor">MasterRouteOnly()</span>;</span><br><span class="line"><span class="comment">// 继续JDBC操作</span></span><br></pre></td></tr></table></figure><p>对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。</p><h4 id="延迟读取"><a href="#延迟读取" class="headerlink" title="延迟读取"></a>延迟读取</h4><p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p><h3 id="如何实现读写分离？"><a href="#如何实现读写分离？" class="headerlink" title="如何实现读写分离？"></a>如何实现读写分离？</h3><p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p><ol><li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li><li>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的主从复制。</li><li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li></ol><p>落实到项目本身的话，常用的方式有两种：</p><p><strong>1.代理方式</strong><br><img src="/2023/01/24/%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F.png"></p><p>我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。提供类似功能的中间件有 MySQL Router（官方）、Atlas（基于 MySQL Proxy）、Maxscale、MyCat。<br><strong>2.组件方式</strong></p><p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 <a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/">sharding-jdbc</a> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p><h3 id="主从复制原理了解么？"><a href="#主从复制原理了解么？" class="headerlink" title="主从复制原理了解么？"></a>主从复制原理了解么？</h3><p>MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p><p>更具体和详细的过程如下：<br><img src="/2023/01/24/%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png"></p><ol><li>主库将数据库中数据的变化写入到 binlog</li><li>从库连接主库</li><li>从库会创建一个 I/O 线程向主库请求更新的 binlog</li><li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收</li><li>从库的 I/O 线程将接收的 binlog 写入到 relay log 中。</li><li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li></ol><p>你一般看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。</p><p>不知道大家有没有使用过阿里开源的一个叫做<strong>canal</strong>的工具。这个工具可以帮助我们实现 MySQL 和其他数据源比如 Elasticsearch 或者另外一台 MySQL 数据库之间的数据同步。很显然，这个工具的底层原理肯定也是依赖 binlog。canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。</p><p>另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。</p><p><strong>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</strong></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>读写分离主要应对的是数据库读并发，没有解决<strong>数据库存储问题</strong>。试想一下：如果 MySQL 一张表的数据量过大怎么办?换言之，我们该如何解决<strong>MySQL的存储压力</strong>呢？答案之一就是 分库分表。</p><h3 id="何为分库？"><a href="#何为分库？" class="headerlink" title="何为分库？"></a>何为分库？</h3><p>分库就是将数据库中的数据分散到不同的数据库上。下面这些操作都涉及到了分库：</p><ul><li>你将数据库中的用户表和用户订单表分别放在两个不同的数据库。</li><li>由于用户表数据量太大，你对用户表进行了水平切分，然后将切分后的 2 张用户表分别放在两个不同的数据库。</li></ul><h3 id="何为分表？"><a href="#何为分表？" class="headerlink" title="何为分表？"></a>何为分表？</h3><p>分表 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>简单来说，垂直拆分是对数据表列的拆分，比如某张表的数据量太大，但是行数没有达到上限，就可以把一张列比较多的表拆分为多张表。举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p>简单来说，水平拆分是对数据表行的拆分，把一张行比较多的表拆分为多张表。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><h3 id="什么情况下需要分库分表？"><a href="#什么情况下需要分库分表？" class="headerlink" title="什么情况下需要分库分表？"></a>什么情况下需要分库分表？</h3><p>遇到下面几种场景可以考虑分库分表：</p><ul><li>单表的数据达到千万级别以上，数据库读写速度比较缓慢（分表）。</li><li>数据库中的数据占用的空间越来越大，备份时间越来越长（分库）。</li><li>应用的并发量太大（分库）。</li></ul><h3 id="分库分表会带来什么问题呢？"><a href="#分库分表会带来什么问题呢？" class="headerlink" title="分库分表会带来什么问题呢？"></a>分库分表会带来什么问题呢？</h3><p>记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。引入分库分表之后，会给系统带来什么挑战呢？</p><ul><li><strong>join 操作</strong> ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</li><li>事务问题 ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。</li><li>分布式 id ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。</li><li>……</li></ul><p>另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。</p><h3 id="分库分表有没有什么比较推荐的方案？"><a href="#分库分表有没有什么比较推荐的方案？" class="headerlink" title="分库分表有没有什么比较推荐的方案？"></a>分库分表有没有什么比较推荐的方案？</h3><p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。<br><img src="/2023/01/24/%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/ShardingSphere.png"></p><p>ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p><h3 id="分库分表后，数据怎么迁移呢？"><a href="#分库分表后，数据怎么迁移呢？" class="headerlink" title="分库分表后，数据怎么迁移呢？"></a>分库分表后，数据怎么迁移呢？</h3><p>分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？比较简单同时也是非常常用的方案就是停机迁移，写个脚本老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p><p>如果你不想停机迁移数据的话，也可以考虑双写方案。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：</p><ul><li>我们对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，咱们新库里的数据是最新的。</li><li>在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li><li>重复上一步的操作，直到老库和新库的数据一致为止。</li></ul><p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。</p><h2 id="ShardingSphere5"><a href="#ShardingSphere5" class="headerlink" title="ShardingSphere5"></a>ShardingSphere5</h2><p>官网见：<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/">https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/</a></p><h3 id="分库分表（springboot-Mybatis-plus）"><a href="#分库分表（springboot-Mybatis-plus）" class="headerlink" title="分库分表（springboot+Mybatis-plus）"></a>分库分表（springboot+Mybatis-plus）</h3><p><strong>依赖导入：</strong></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;lombok.version&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.shardingsphere/shardingsphere-jdbc-core-spring-boot-starter --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>配置文件：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="comment">#  一个实体类对应三张表，覆盖，不然启动报错</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Sharding-JDBC的配置</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">mode:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Standalone</span></span><br><span class="line">      <span class="attr">repository:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">JDBC</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="comment"># 数据源（逻辑名字）</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">m0,m1</span></span><br><span class="line">      <span class="comment"># 配置数据源</span></span><br><span class="line">      <span class="attr">m0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.8.128:3306/test_0?characterEncoding=utf8&amp;useSSL=true&amp;createDatabaseIfNotExist=true&amp;serverTimezone=GMT&amp;nullNamePatternMatchesAll=true</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">Haha135790!</span></span><br><span class="line">      <span class="attr">m1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.8.128:3307/test_1?characterEncoding=utf8&amp;useSSL=true&amp;createDatabaseIfNotExist=true&amp;serverTimezone=GMT&amp;nullNamePatternMatchesAll=true</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">Haha135790!</span></span><br><span class="line">    <span class="comment"># 分片的配置</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="attr">sharding:</span></span><br><span class="line">        <span class="comment"># 表的分片策略</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">          <span class="comment"># 逻辑表的名称</span></span><br><span class="line">          <span class="attr">user:</span></span><br><span class="line">            <span class="comment"># 数据节点配置，采用Groovy表达式</span></span><br><span class="line">            <span class="attr">actual-data-nodes:</span> <span class="string">m$-&gt;&#123;0..1&#125;.user_$-&gt;&#123;0..1&#125;</span></span><br><span class="line">            <span class="attr">database-strategy:</span></span><br><span class="line">              <span class="attr">standard:</span></span><br><span class="line">                <span class="attr">sharding-column:</span> <span class="string">cid</span></span><br><span class="line">                <span class="attr">sharding-algorithm-name:</span> <span class="string">user-data-inline</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#配置策略</span></span><br><span class="line">            <span class="attr">table-strategy:</span></span><br><span class="line">              <span class="attr">standard:</span></span><br><span class="line">                <span class="attr">sharding-column:</span> <span class="string">name</span></span><br><span class="line">                <span class="comment"># 精确匹配</span></span><br><span class="line">                <span class="attr">sharding-algorithm-name:</span> <span class="string">user-inline</span></span><br><span class="line">            <span class="attr">key-generate-strategy:</span></span><br><span class="line">              <span class="attr">column:</span> <span class="string">cid</span></span><br><span class="line">              <span class="attr">key-generator-name:</span> <span class="string">cid_snowflake</span></span><br><span class="line">        <span class="attr">sharding-algorithms:</span></span><br><span class="line">          <span class="attr">user-data-inline:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">INLINE</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">m$&#123;cid</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span></span><br><span class="line">          <span class="attr">user-inline:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">HASH_MOD</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="attr">sharding-count:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">default-sharding-column:</span> <span class="string">cid</span></span><br><span class="line">        <span class="attr">binding-tables:</span> <span class="string">user</span></span><br><span class="line">        <span class="attr">key-generators:</span></span><br><span class="line">          <span class="attr">cid_snowflake:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql-show:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.example.shardingjdbc:</span> <span class="string">DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.shardingjdbc.entity</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#主键类型 AUTO:&quot;数据库ID自增&quot; INPUT:&quot;用户输入ID&quot;,ID_WORKER:&quot;全局唯一ID (数字类型唯一ID)&quot;, UUID:&quot;全局唯一ID UUID&quot;;</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment">#字段策略 IGNORED:&quot;忽略判断&quot;  NOT_NULL:&quot;非 NULL 判断&quot;)  NOT_EMPTY:&quot;非空判断&quot;</span></span><br><span class="line">      <span class="attr">field-strategy:</span> <span class="string">NOT_EMPTY</span></span><br><span class="line">      <span class="comment">#数据库类型</span></span><br><span class="line">      <span class="attr">db-type:</span> <span class="string">MYSQL</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">      <span class="comment"># 是否开启自动驼峰命名规则映射:从数据库列名到Java属性驼峰命名的类似映射</span></span><br><span class="line">      <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 如果查询结果中包含空值的列，则 MyBatis 在映射的时候，不会映射这个字段</span></span><br><span class="line">      <span class="attr">call-setters-on-nulls:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 这个配置会将执行的sql打印出来，在开发或测试的时候可以用</span></span><br><span class="line">      <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>其中有两个数据源，test_0库和test_1库，每个库中都包含user_0表和user_1表。</p><p>实体类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.<span class="keyword">annotation</span>.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.<span class="keyword">annotation</span>.TableName;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.<span class="keyword">annotation</span>.JsonFormat;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.format.<span class="keyword">annotation</span>.DateTimeFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@TableName(<span class="string">&quot;user&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该配置会优先于ShardingSphere在配置文件中的主键生成策略</span></span><br><span class="line"><span class="comment">     * 所以，如果想使得ShardingSphere的主键策略生效，需要配置为AUTO</span></span><br><span class="line"><span class="comment">     * 但是配置了AUTO，但是没有配置ShardingSphere的主键生成策略，则会依赖于数据库本生的主键自增策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Long</span> cid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Boolean</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>,timezone=<span class="string">&quot;GMT+8&quot;</span>)</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>实体类这里需要注意主键的配置，Mybatis-plus的主键策略优先级高于ShardingSphere，上述配置是基于ShardingSphere的主键生成策略，如果想使得ShardingSphere的主键策略生效，需要配置为AUTO，但是配置了AUTO，但是没有配置ShardingSphere的主键生成策略，则会依赖于数据库本生的主键自增策略，如果都没有则会报错。</p><h3 id="读写分离-1"><a href="#读写分离-1" class="headerlink" title="读写分离"></a>读写分离</h3><p>依赖具体与分库分表一致<br><strong>配置文件：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="comment">#  一个实体类对应三张表，覆盖，不然启动报错</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Sharding-JDBC的配置</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">mode:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Standalone</span></span><br><span class="line">      <span class="attr">repository:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">JDBC</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="comment"># 数据源（逻辑名字）</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">m0,m1</span></span><br><span class="line">      <span class="comment"># 配置数据源</span></span><br><span class="line">      <span class="attr">m0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.8.128:3306/test?characterEncoding=utf8&amp;useSSL=true&amp;createDatabaseIfNotExist=true&amp;serverTimezone=GMT&amp;nullNamePatternMatchesAll=true</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">Haha135790!</span></span><br><span class="line">      <span class="attr">m1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.8.128:3307/test?characterEncoding=utf8&amp;useSSL=true&amp;createDatabaseIfNotExist=true&amp;serverTimezone=GMT&amp;nullNamePatternMatchesAll=true</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">Haha135790!</span></span><br><span class="line">    <span class="comment"># 分片的配置</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="attr">readwrite-splitting:</span></span><br><span class="line">        <span class="attr">data-sources:</span></span><br><span class="line">          <span class="attr">myds:</span></span><br><span class="line">            <span class="attr">static-strategy:</span></span><br><span class="line">              <span class="attr">write-data-source-name:</span> <span class="string">m0</span></span><br><span class="line">              <span class="attr">read-data-source-names:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">m1</span></span><br><span class="line">            <span class="attr">load-balancer-name:</span> <span class="string">alg_round</span> <span class="comment">#自定义</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">load-balancers:</span></span><br><span class="line">          <span class="attr">alg_round:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql-show:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.example.shardingjdbc:</span> <span class="string">DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.shardingjdbc.entity</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#主键类型 AUTO:&quot;数据库ID自增&quot; INPUT:&quot;用户输入ID&quot;,ID_WORKER:&quot;全局唯一ID (数字类型唯一ID)&quot;, UUID:&quot;全局唯一ID UUID&quot;;</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment">#字段策略 IGNORED:&quot;忽略判断&quot;  NOT_NULL:&quot;非 NULL 判断&quot;)  NOT_EMPTY:&quot;非空判断&quot;</span></span><br><span class="line">      <span class="attr">field-strategy:</span> <span class="string">NOT_EMPTY</span></span><br><span class="line">      <span class="comment">#数据库类型</span></span><br><span class="line">      <span class="attr">db-type:</span> <span class="string">MYSQL</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">      <span class="comment"># 是否开启自动驼峰命名规则映射:从数据库列名到Java属性驼峰命名的类似映射</span></span><br><span class="line">      <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 如果查询结果中包含空值的列，则 MyBatis 在映射的时候，不会映射这个字段</span></span><br><span class="line">      <span class="attr">call-setters-on-nulls:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 这个配置会将执行的sql打印出来，在开发或测试的时候可以用</span></span><br><span class="line">      <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>实体类的主键使用mybatis-plus的分布式主键，具体根据业务结合就好</li><li>配置容器化mysql的主从，开启binlog需要在配置文件目录的conf.d目录下新建my.cnf，并且配置binlog的配置来开启</li><li>若是开启了事务，则同一事务内的读写都会在主节点执行</li></ul><p>binlog配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#binlog格式</span></span><br><span class="line"><span class="attr">binlog_format</span> = mixed</span><br><span class="line"><span class="comment">#存放地址，注意这个地址是docker容器里面的地址，不是宿主机里面的地址</span></span><br><span class="line"><span class="attr">log-bin</span>=/var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">server-id</span>=<span class="number">123654</span></span><br><span class="line"><span class="comment">#存放时间</span></span><br><span class="line"><span class="attr">expire_logs_days</span>=<span class="number">30</span></span><br><span class="line"><span class="comment">#最大文件大小</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="number">50</span>m</span><br><span class="line"><span class="comment">#缓存大小</span></span><br><span class="line"><span class="attr">binlog_cache_size</span>=<span class="number">10</span>m</span><br><span class="line"><span class="comment">#最大缓存大小</span></span><br><span class="line"><span class="attr">max_binlog_cache_size</span>=<span class="number">512</span>m</span><br></pre></td></tr></table></figure><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡系统通常用于将任务比如用户请求处理分配到多个服务器处理以提高网站、应用或者数据库的性能和可靠性。常见的负载均衡系统包括 3 种：</p><ol><li>DNS 负载均衡 ：一般用来实现地理级别的均衡。</li><li>硬件负载均衡 ： 通过单独的硬件设备比如 F5 来实现负载均衡功能（硬件的价格一般很贵）。</li><li>软件负载均衡 ：通过负载均衡软件比如 Nginx 来实现负载均衡功能。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;读写分离-amp-分库分表&quot;&gt;&lt;a href=&quot;#读写分离-amp-分库分表&quot; class=&quot;headerlink&quot; title=&quot;读写分离&amp;amp;分库分表&quot;&gt;&lt;/a&gt;读写分离&amp;amp;分库分表&lt;/h1&gt;&lt;h2 id=&quot;读写分离&quot;&gt;&lt;a href=&quot;#读写分离&quot; class=&quot;headerlink&quot; title=&quot;读写分离&quot;&gt;&lt;/a&gt;读写分离&lt;/h2&gt;&lt;p&gt;读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。&lt;br&gt;&lt;img src=&quot;/2023/01/24/%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。&lt;/p&gt;
&lt;h3 id=&quot;读写分离会带来什么问题？如何解决？&quot;&gt;&lt;a href=&quot;#读写分离会带来什么问题？如何解决？&quot; class=&quot;headerlink&quot; title=&quot;读写分离会带来什么问题？如何解决？&quot;&gt;&lt;/a&gt;读写分离会带来什么问题？如何解决？&lt;/h3&gt;</summary>
    
    
    
    <category term="系统设计" scheme="https://shenhongwei33.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="性能设计" scheme="https://shenhongwei33.github.io/tags/%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>系统设计基础</title>
    <link href="https://shenhongwei33.github.io/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://shenhongwei33.github.io/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2023-01-24T08:52:30.000Z</published>
    <updated>2023-01-24T09:14:23.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统设计基础"><a href="#系统设计基础" class="headerlink" title="系统设计基础"></a>系统设计基础</h1><h2 id="系统设计必备基础"><a href="#系统设计必备基础" class="headerlink" title="系统设计必备基础"></a>系统设计必备基础</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API 。RESTful API 是一种基于 REST 构建的 API，它是一种被设计的更好使用的 API。</p><p>API（Application Programming Interface） 翻译过来是应用程序编程接口的意思。<br>但是， API 不仅仅代表后端系统暴露的接口，像框架中提供的方法也属于 API 的范畴。</p><p>RESTful API 经常也被叫做 REST API，它是基于 REST 构建的 API。这个 REST 到底是什么，我们后文在讲，涉及到的概念比较多。</p><p>RESTful API 可以让你看到 URL+Http Method 就知道这个 URL 是干什么的，让你看到了 HTTP 状态码（status code）就知道请求结果如何。像咱们在开发过程中设计 API 的时候也应该至少要满足 RESTful API 的最基本的要求（比如接口中尽量使用名词，使用 POST 请求创建资源，DELETE 请求删除资源等等，示例：GET /notes/id：获取某个指定 id 的笔记的信息）。</p><h4 id="解读-REST"><a href="#解读-REST" class="headerlink" title="解读 REST"></a>解读 REST</h4><p>REST 是 REpresentational State Transfer 的缩写。这个词组的翻译过来就是“表现层状态转化”。</p><ul><li><strong>资源（Resource）</strong> ：我们可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源。每一种资源都有特定的 URI（统一资源标识符）与之对应，如果我们需要获取这个资源，访问这个 URI 就可以了，比如获取特定的班级：/class/12。另外，资源也可以包含子资源，比如 /classes/classId/teachers：列出某个指定班级的所有老师的信息。</li><li><strong>表现形式（Representational）</strong>：”资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式比如 json，xml，image,txt 等等叫做它的”表现层/表现形式”。</li><li><strong>状态转移（State Transfer）</strong> ：大家第一眼看到这个词语一定会很懵逼？内心 BB：这尼玛是啥啊？ 大白话来说 REST 中的状态转移更多地描述的服务器端资源的状态，比如你通过增删改查（通过 HTTP 动词实现）引起资源状态的改变。ps:互联网通信协议 HTTP 协议，是一个无状态协议，所有的资源状态都保存在服务器端。</li></ul><p>综合上面的解释，我们总结一下什么是 RESTful 架构：</p><ol><li>每一个 URI 代表一种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现形式比如 json，xml，image,txt 等等；</li><li>客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ol><h4 id="RESTful-API-规范"><a href="#RESTful-API-规范" class="headerlink" title="RESTful API 规范"></a>RESTful API 规范</h4><p><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/RESTfulAPI%E8%A7%84%E8%8C%83.png"></p><h5 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h5><ul><li>GET：请求从服务器获取特定资源。举个例子：GET /classes（获取所有班级）</li><li>POST ：在服务器上创建一个新的资源。举个例子：POST /classes（创建班级）</li><li>PUT ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：PUT /classes/12（更新编号为 12 的班级）</li><li>DELETE ：从服务器删除特定的资源。举个例子：DELETE /classes/12（删除编号为 12 的班级）</li><li>PATCH ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li></ul><h5 id="路径（接口命名）"><a href="#路径（接口命名）" class="headerlink" title="路径（接口命名）"></a>路径（接口命名）</h5><p>路径又称”终点”（endpoint），表示 API 的具体网址。实际开发中常见的规范如下：</p><ol><li>网址中不能有动词，只能有名词，API 中的名词也应该使用复数。</li></ol><p>因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的”集合”（collection）。如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。比如：GET /calculate?param1=11&amp;param2=33 。</p><ol start="2"><li>不用大写字母，建议用中杠 - 不用下杠 _ 。</li></ol><p>比如邀请码写成 invitation-code而不是 invitation_code 。</p><ol start="3"><li>善用版本化 API。</li></ol><p>当我们的 API 发生了重大改变而不兼容前期版本的时候，我们可以通过 URL 来实现版本化，比如 <a href="http://api.example.com/v1%E3%80%81http://apiv1.example.com">http://api.example.com/v1、http://apiv1.example.com</a> 。版本不必非要是数字，只是数字用的最多，日期、季节都可以作为版本标识符，项目团队达成共识就可。</p><ol start="4"><li>接口尽量使用名词，避免使用动词。</li></ol><p>RESTful API 操作（HTTP Method）的是资源（名词）而不是动作（动词）。</p><p>现在有这样一个 API 提供班级（class）的信息，还包括班级中的学生和教师的信息，则它的路径应该设计成下面这样：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET    /classes：列出所有班级</span><br><span class="line">POST   /classes：新建一个班级</span><br><span class="line">GET    <span class="regexp">/classes/</span>&#123;classId&#125;：获取某个指定班级的信息</span><br><span class="line">PUT    <span class="regexp">/classes/</span>&#123;classId&#125;：更新某个指定班级的信息（一般倾向整体更新）</span><br><span class="line">PATCH  <span class="regexp">/classes/</span>&#123;classId&#125;：更新某个指定班级的信息（一般倾向部分更新）</span><br><span class="line"><span class="keyword">DELETE</span> <span class="regexp">/classes/</span>&#123;classId&#125;：删除某个班级</span><br><span class="line">GET    <span class="regexp">/classes/</span>&#123;classId&#125;/teachers：列出某个指定班级的所有老师的信息</span><br><span class="line">GET    <span class="regexp">/classes/</span>&#123;classId&#125;/students：列出某个指定班级的所有学生的信息</span><br><span class="line"><span class="keyword">DELETE</span> <span class="regexp">/classes/</span>&#123;classId&#125;<span class="regexp">/teachers/</span>&#123;ID&#125;：删除某个指定班级下的指定的老师的信息</span><br></pre></td></tr></table></figure><p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:/schools，老师: /schools/teachers，学生: /schools/students 就是二级资源。</p><h5 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h5><p>如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET    /classes?<span class="keyword">state</span>=active&amp;name=guidegege</span><br></pre></td></tr></table></figure><p>比如我们要实现分页查询：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GET</span>    /classes?page=<span class="number">1</span>&amp;size=<span class="number">10</span> //指定第<span class="number">1</span>页，每页<span class="number">10</span>个数据</span><br></pre></td></tr></table></figure><h5 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h5><p>状态码范围：</p><table><thead><tr><th>2xx：成功</th><th>3xx：重定向</th><th>4xx：客户端错误</th><th>5xx：服务器错误</th></tr></thead><tbody><tr><td>200 成功</td><td>301 永久重定向</td><td>400 错误请求</td><td>500 服务器错误</td></tr><tr><td>201 创建</td><td>304 资源未修改</td><td>401 未授权</td><td>502 网关错误</td></tr><tr><td></td><td></td><td>403 禁止访问</td><td>504 网关超时</td></tr><tr><td></td><td></td><td>404 未找到</td><td></td></tr><tr><td></td><td></td><td>405 请求方法不对</td><td></td></tr></tbody></table><h4 id="RESTful-的极致-HATEOAS"><a href="#RESTful-的极致-HATEOAS" class="headerlink" title="RESTful 的极致 HATEOAS"></a>RESTful 的极致 HATEOAS</h4><blockquote><p>RESTful 的极致是 hateoas ，但是这个基本不会在实际项目中用到。</p></blockquote><p>上面是 RESTful API 最基本的东西，也是我们平时开发过程中最容易实践到的。实际上，RESTful API 最好做到 Hypermedia，即返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向 api.example.com 的根目录发出请求，会得到这样一个返回结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;rel&quot;</span><span class="punctuation">:</span>   <span class="string">&quot;collection https://www.example.com/classes&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;https://api.example.com/classes&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;List of classes&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;application/vnd.yourformat+json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码表示，文档中有一个 link 属性，用户读取这个属性就知道下一步该调用什么 API 了。rel 表示这个 API 与当前网址的关系（collection 关系，并给出该 collection 的网址），href 表示 API 的路径，title 表示 API 的标题，type 表示返回类型 Hypermedia API 的设计被称为HATEOAS。<br>在 Spring 中有一个叫做 HATEOAS 的 API 库，通过它我们可以更轻松的创建出符合 HATEOAS 设计的 API。</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><h4 id="常见命名规则以及适用场景"><a href="#常见命名规则以及适用场景" class="headerlink" title="常见命名规则以及适用场景"></a>常见命名规则以及适用场景</h4><h5 id="驼峰命名法（CamelCase）"><a href="#驼峰命名法（CamelCase）" class="headerlink" title="驼峰命名法（CamelCase）"></a>驼峰命名法（CamelCase）</h5><p>驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式</p><h6 id="大驼峰命名法（UpperCamelCase）"><a href="#大驼峰命名法（UpperCamelCase）" class="headerlink" title="大驼峰命名法（UpperCamelCase）"></a>大驼峰命名法（UpperCamelCase）</h6><p>类名需要使用大驼峰命名法（UpperCamelCase）<br>正例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceDiscovery、ServiceInstance、LruCacheFactory</span><br></pre></td></tr></table></figure><h6 id="小驼峰命名法（lowerCamelCase）"><a href="#小驼峰命名法（lowerCamelCase）" class="headerlink" title="小驼峰命名法（lowerCamelCase）"></a>小驼峰命名法（lowerCamelCase）</h6><p>方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。正例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getUserInfo</span>()</span><br><span class="line"><span class="built_in">createCustomThreadPool</span>()</span><br><span class="line"><span class="built_in">setNameFormat</span>(String nameFormat)</span><br><span class="line">Uservice userService;</span><br></pre></td></tr></table></figure><h5 id="蛇形命名法（snake-case）"><a href="#蛇形命名法（snake-case）" class="headerlink" title="蛇形命名法（snake_case）"></a>蛇形命名法（snake_case）</h5><p>测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）<br>在蛇形命名法中，各个单词之间通过下划线“_”连接，比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下：“shouldGet200StatusCodeWhenRequestIsValid”。感觉如何？ 相比于使用蛇形命名法（snake_case）来说是不是不那么易读？</p><h5 id="串式命名法（kebab-case）"><a href="#串式命名法（kebab-case）" class="headerlink" title="串式命名法（kebab-case）"></a>串式命名法（kebab-case）</h5><p>在串式命名法中，各个单词之间通过连接符“-”连接，比如dubbo-registry。建议项目文件夹名称使用串式命名法（kebab-case），比如 dubbo 项目的各个模块的命名是下面这样的。</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>重构就是利用设计模式(如组合模式、策略模式、责任链模式)、软件设计原则（如 SOLID 原则、YAGNI 原则、KISS 原则）和重构手段（如封装、继承、构建测试体系）来让代码更容易理解，更易于修改。</p><p>软件设计原则指导着我们组织和规范代码，同时，重构也是为了能够尽量设计出尽量满足软件设计原则的软件。正确重构的核心在于 步子一定要小，<strong>每一步的重构都不会影响软件的正常运行，可以随时停止重构</strong>。</p><p>常见的设计模式如下 ：<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png"></p><p>常见的软件设计原则如下 ：<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.png"></p><h4 id="为什么要重构？"><a href="#为什么要重构？" class="headerlink" title="为什么要重构？"></a>为什么要重构？</h4><p>在上面介绍重构定义的时候，我从比较抽象的角度介绍了重构的好处：重构的主要目的主要是提升代码&amp;架构的灵活性/可扩展性以及复用性。</p><p>如果对应到一个真实的项目，重构具体能为我们带来什么好处呢？</p><ol><li><strong>让代码更容易理解</strong>： 通过添加注释、命名规范、逻辑优化等手段可以让我们的代码更容易被理解；</li><li><strong>避免代码腐化</strong> ：通过重构干掉坏味道代码；</li><li><strong>加深对代码的理解</strong> ：重构代码的过程会加深你对某部分代码的理解；</li><li><strong>发现潜在 bug</strong> ：是这样的，很多潜在的 bug ，都是我们在重构的过程中发现的；</li></ol><h4 id="何时进行重构？"><a href="#何时进行重构？" class="headerlink" title="何时进行重构？"></a>何时进行重构？</h4><p>重构在是开发过程中随时可以进行的，见机行事即可，并不需要单独分配一两天的时间专门用来重构。</p><h5 id="提交代码之前"><a href="#提交代码之前" class="headerlink" title="提交代码之前"></a>提交代码之前</h5><p>《重构：改善代码既有设计》这本书介绍了一个 营地法则 的概念:</p><blockquote><p>编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。</p></blockquote><p>这个概念表达的核心思想其实很简单：在你提交代码的之前，花一会时间想一想，我这次的提交是让项目代码变得更健康了，还是更腐化了，或者说没什么变化？项目团队的每一个人只有保证自己的提交没有让项目代码变得更腐化，项目代码才会朝着健康的方向发展。</p><h5 id="开发一个新功能之后-amp-之前"><a href="#开发一个新功能之后-amp-之前" class="headerlink" title="开发一个新功能之后&amp;之前"></a>开发一个新功能之后&amp;之前</h5><p>在开发一个新功能之后，我们应该回过头看看是不是有可以改进的地方。在添加一个新功能之前，我们可以思考一下自己是否可以重构代码以让新功能的开发更容易。<br>一个新功能的开发不应该仅仅只有功能验证通过那么简单，我们还应该尽量保证代码质量。</p><h5 id="Code-Review-之后"><a href="#Code-Review-之后" class="headerlink" title="Code Review 之后"></a>Code Review 之后</h5><p>Code Review 可以非常有效提高代码的整体质量，它会帮助我们发现代码中的坏味道以及可能存在问题的地方。并且， Code Review 可以帮助项目团队其他程序员理解你负责的业务模块，有效避免人员方面的单点风险。经历一次 Code Review ，你的代码可能会收到很多改进建议。</p><h5 id="捡垃圾式重构"><a href="#捡垃圾式重构" class="headerlink" title="捡垃圾式重构"></a>捡垃圾式重构</h5><p>当我们发现坏味道代码（垃圾）的时候，如果我们不想停下手头自己正在做的工作，但又不想放着垃圾不管，我们可以这样做：</p><ul><li>如果这个垃圾很容易重构的话，我们可以立即重构它。</li><li>如果这个垃圾不太容易重构的话，我们可以先记录下来，当完成当下的任务再回来重构它。</li></ul><h5 id="阅读理解代码的时候"><a href="#阅读理解代码的时候" class="headerlink" title="阅读理解代码的时候"></a>阅读理解代码的时候</h5><p>搞开发的小伙伴应该非常有体会：我们经常需要阅读项目团队中其他人写的代码，也经常需要阅读自己过去写的代码。阅读代码的时候，通常要比我们写代码的时间还要多很多。我们在阅读理解代码的时候，如果发现一些坏味道的话，我们就可以对其进行重构。就比如说你在阅读张三写的某段代码的时候，你发现这段代码逻辑过于复杂难以理解，你有更好的写法，那你就可以对张三的这段代码逻辑进行重构。</p><h4 id="重构有哪些注意事项？"><a href="#重构有哪些注意事项？" class="headerlink" title="重构有哪些注意事项？"></a>重构有哪些注意事项？</h4><h5 id="单元测试是重构的保护网"><a href="#单元测试是重构的保护网" class="headerlink" title="单元测试是重构的保护网"></a>单元测试是重构的保护网</h5><p>单元测试可以为重构提供信心，降低重构的成本。我们要像重视生产代码那样，重视单元测试。另外，多提一句：持续集成也要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。</p><p>怎样才能算单元测试呢？ 网上的定义很多，很抽象，很容易把人给看迷糊了。我觉得对于单元测试的定义主要取决于你的项目，一个函数甚至是一个类都可以看作是一个单元。就比如说我们写了一个计算个人股票收益率的方法，我们为了验证它的正确性专门为它写了一个单元测试。再比如说我们代码有一个类专门负责数据脱敏，我们为了验证脱敏是否符合预期专门为这个类写了一个单元测试。</p><h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h4><p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h4 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h4><ul><li>工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li><li>代理设计模式 : Spring AOP 功能的实现。</li><li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li><li>模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li>包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li>适配器模式 : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="认证授权基础"><a href="#认证授权基础" class="headerlink" title="认证授权基础"></a>认证授权基础</h3><h4 id="认证-Authentication-和授权-Authorization-的区别"><a href="#认证-Authentication-和授权-Authorization-的区别" class="headerlink" title="认证 (Authentication) 和授权 (Authorization)的区别"></a>认证 (Authentication) 和授权 (Authorization)的区别</h4><ul><li>Authentication（认证） 是验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。</li><li>Authorization（授权） 发生在 Authentication（认证） 之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。</li></ul><h4 id="RBAC-模型"><a href="#RBAC-模型" class="headerlink" title="RBAC 模型"></a>RBAC 模型</h4><p>系统权限控制最常采用的访问控制模型就是 RBAC 模型 。</p><p>RBAC 即基于角色的权限访问控制（Role-Based Access Control）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/RBAC.png"></p><p>在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。</p><h4 id="为什么-Cookie-无法防止-CSRF-攻击，而-Token-可以？"><a href="#为什么-Cookie-无法防止-CSRF-攻击，而-Token-可以？" class="headerlink" title="为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？"></a>为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？</h4><p>CSRF（Cross Site Request Forgery）一般被翻译为 跨站请求伪造 。那么什么是 跨站请求伪造 呢？说简单用你的身份去发送一些对你不友好的请求。</p><p>进行 Session 认证的时候，我们一般使用 Cookie 来存储 SessionId,当我们登陆后后端生成一个 SessionId 放在 Cookie 中返回给客户端，服务端通过 Redis 或者其他存储工具记录保存着这个 SessionId，客户端登录以后每次请求都会带上这个 SessionId，服务端通过这个 SessionId 来标示你这个人。如果别人通过 Cookie 拿到了 SessionId 后就可以代替你的身份访问系统了。Session 认证中 Cookie 中的 SessionId 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p><p>但是，我们使用 Token 的话就不会存在这个问题，在我们登录成功获得 Token 之后，一般会选择存放在 localStorage （浏览器本地存储）中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 Token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 Token 的，所以这个请求将是非法的。</p><h3 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h3><ul><li>JWT ：JWT（JSON Web Token）是一种身份认证的方式，JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性</li><li>SSO(单点登录) ：SSO(Single Sign On) 即单点登录说的是用户登陆多个子系统的其中一个就有权访问与其相关的其他系统。</li></ul><h4 id="JWT-身份认证优缺点分析以及常见问题解决方案"><a href="#JWT-身份认证优缺点分析以及常见问题解决方案" class="headerlink" title="JWT 身份认证优缺点分析以及常见问题解决方案"></a>JWT 身份认证优缺点分析以及常见问题解决方案</h4><h5 id="Token-认证的优势"><a href="#Token-认证的优势" class="headerlink" title="Token 认证的优势"></a>Token 认证的优势</h5><p>1.无状态<br>token 自身包含了身份验证所需要的所有信息，使得我们的服务器不需要存储 Session 信息，这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。但是，也正是由于 token 的无状态，也导致了它最大的缺点：当后端在token 有效期内废弃一个 token 或者更改它的权限的话，不会立即生效，一般需要等到有效期过后才可以。另外，当用户 Logout 的话，token 也还有效。除非，我们在后端增加额外的处理逻辑。</p><p>2.有效避免了CSRF 攻击</p><p>3.适合移动端应用</p><p>使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 SessionId），所以不适合移动端。但是，使用 token 进行身份认证就不会存在这种问题，因为只要 token 可以被客户端存储就能够使用，而且 token 还可以跨语言使用。</p><p>4.单点登录友好</p><p>使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 token 进行认证的话， token 被保存在客户端，不会存在这些问题。</p><h5 id="Token-认证常见问题以及解决办法"><a href="#Token-认证常见问题以及解决办法" class="headerlink" title="Token 认证常见问题以及解决办法"></a>Token 认证常见问题以及解决办法</h5><p>1.注销登录等场景下 token 还有效</p><p>与之类似的具体相关场景有：</p><ol><li>退出登录;</li><li>修改密码;</li><li>服务端修改了某个用户具有的权限或者角色；</li><li>用户的帐户被删除/暂停。</li><li>用户由管理员注销；</li></ol><p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。但是，使用 token 认证的方式就不好解决了。我们也说过了，token 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。为了应对这类型问题，总结了下面几种方案：</p><ul><li>将 token 存入内存数据库：将 token 存入 DB 中，redis 内存数据库在这里是不错的选择。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则。</li><li>黑名单机制：和上面的方式类似，使用内存数据库比如 redis 维护一个黑名单，如果想让某个 token 失效的话就直接将这个 token 加入到 黑名单 即可。然后，每次使用 token 进行请求的话都会先判断这个 token 是否存在于黑名单中。</li><li>修改密钥 (Secret) : 我们为每个用户都创建一个专属密钥，如果我们想让某个 token 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大，比如：1) 如果服务是分布式的，则每次发出新的 token 时都必须在多台机器同步密钥。为此，你需要将密钥存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。 2) 如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。</li><li>保持令牌的有效期限短并经常轮换 ：很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</li></ul><p>对于修改密码后 token 还有效问题的解决还是比较容易的，说一种我觉得比较好的方式：使用用户的密码的哈希值对 token 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</p><p>2.token 的续签问题</p><p>token 有效期一般都建议设置的不太长，那么 token 过期后如何认证，如何实现动态刷新 token，避免用户经常需要重新登录？</p><ol><li>类似于 Session 认证中的做法：这种方案满足于大部分场景。假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。</li><li>每次请求都返回新 token :这种方案的的思路很简单，但是，很明显，开销会比较大。</li><li>token 有效期设置到半夜 ：这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</li><li>用户登录返回两个 token ：第一个是 accessToken ，它的过期时间 token 本身的过期时间比如半个小时，另外一个是 refreshToken 它的过期时间更长一点比如为1天。客户端登录后，将 accessToken和refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可。该方案的不足是：1) 需要客户端来配合；2) 用户注销的时候需要同时保证两个 token 都无效；3) 重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提前去通过 refreshToken 获取新的accessToken）。</li></ol><p>JWT 最适合的场景是不需要服务端保存用户状态的场景，如果考虑到 token 注销和 token 续签的场景话，没有特别好的解决方案，大部分解决方案都给 token 加上了状态，这就有点类似 Session 认证了。</p><h4 id="SSO-单点登录"><a href="#SSO-单点登录" class="headerlink" title="SSO 单点登录"></a>SSO 单点登录</h4><p>SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><h5 id="单点登录系统的好处"><a href="#单点登录系统的好处" class="headerlink" title="单点登录系统的好处"></a>单点登录系统的好处</h5><ul><li><strong>用户角度</strong> :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。</li><li><strong>系统管理员角度</strong> : 管理员只需维护好一个统一的账号中心就可以了，方便。</li><li><strong>新系统开发角度</strong>: 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。</li></ul><h5 id="SSO设计与实现"><a href="#SSO设计与实现" class="headerlink" title="SSO设计与实现"></a>SSO设计与实现</h5><p><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/sso.png"></p><p><strong>跨域登录、登出</strong>：</p><p>前面提到过，核心思路是客户端存储AuthToken，服务器端通过Redis存储登录信息。由于客户端是将AuthToken存储在Cookie中的。所以跨域要解决的问题，就是如何解决Cookie的跨域读写问题。</p><p>解决跨域的核心思路就是：</p><ul><li><p>登录完成之后通过回调的方式，将AuthToken传递给主域名之外的站点，该站点自行将AuthToken保存在当前域下的Cookie中。</p></li><li><p>登出完成之后通过回调的方式，调用非主域名站点的登出页面，完成设置Cookie中的AuthToken过期的操作。</p></li><li><p>跨域登录（主域名已登录）<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E8%B7%A8%E5%9F%9F%E7%99%BB%E5%BD%95.png"></p></li><li><p>跨域登录（主域名未登录）<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E8%B7%A8%E5%9F%9F%E7%99%BB%E5%BD%95-1.png"></p></li></ul><p>这次设计方案更多是提供实现思路。如果涉及到APP用户登录等情况，在访问SSO服务时，增加对APP的签名验证就好了。当然，如果有无线网关，验证签名不是问题。</p><h3 id="敏感词过滤"><a href="#敏感词过滤" class="headerlink" title="敏感词过滤"></a>敏感词过滤</h3><p>系统需要对用户输入的文本进行敏感词过滤如色情、政治、暴力相关的词汇。敏感词过滤用的使用比较多的 Trie 树算法 和 DFA 算法。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><h5 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h5><p>Trie 树 也称为字典树、单词查找树，哈系树的一种变种，通常被用于字符串匹配，用来解决在一组字符串集合中快速查找某个字符串的问题。像浏览器搜索的关键词提示一般就是基于 Trie 树来做的。</p><p>假如我们的敏感词库中有以下敏感词：</p><ul><li>高清有码</li><li>高清 AV</li><li>东京冷</li><li>东京热</li></ul><p>我们构造出来的敏感词 Trie 树就是下面这样的：<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/Trie.png"></p><p>当我们要查找对应的字符串“东京热”的话，我们会把这个字符串切割成单个的字符“东”、“京”、“热”，然后我们从 Trie 树的根节点开始匹配。可以看出， Trie 树的核心原理其实很简单，就是<strong>通过公共前缀来提高字符串匹配效率</strong>。<br>Apache Commons Collecions这个库中就有 Trie 树实现。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Trie&lt;String, String&gt; trie = <span class="keyword">new</span> PatriciaTrie&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">trie.put(<span class="string">&quot;Abigail&quot;</span>, <span class="string">&quot;student&quot;</span>);</span><br><span class="line">trie.put(<span class="string">&quot;Abi&quot;</span>, <span class="string">&quot;doctor&quot;</span>);</span><br><span class="line">trie.put(<span class="string">&quot;Annabel&quot;</span>, <span class="string">&quot;teacher&quot;</span>);</span><br><span class="line">trie.put(<span class="string">&quot;Christina&quot;</span>, <span class="string">&quot;student&quot;</span>);</span><br><span class="line">trie.put(<span class="string">&quot;Chris&quot;</span>,<span class="string">&quot;doctor&quot;</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Assertions</span>.</span></span><span class="keyword">assert</span><span class="constructor">True(<span class="params">trie</span>.<span class="params">containsKey</span>(<span class="string">&quot;Abigail&quot;</span>)</span>);</span><br><span class="line"><span class="keyword">assert</span><span class="constructor">Equals(<span class="string">&quot;&#123;Abi=doctor, Abigail=student&#125;&quot;</span>,<span class="params">trie</span>.<span class="params">prefixMap</span>(<span class="string">&quot;Abi&quot;</span>)</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line"><span class="keyword">assert</span><span class="constructor">Equals(<span class="string">&quot;&#123;Chris=doctor,Christina=student&#125;&quot;</span>,<span class="params">trie</span>.<span class="params">prefixMap</span>(<span class="string">&quot;Chr&quot;</span>)</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br></pre></td></tr></table></figure><p>Aho-Corasick（AC）自动机是一种建立在 Trie 树上的一种改进算法，是一种多模式匹配算法，由贝尔实验室的研究人员 Alfred V. Aho 和 Margaret J.Corasick 发明。AC 自动机算法使用 Trie 树来存放模式串的前缀，通过失败匹配指针（失配指针）来处理匹配失败的跳转。</p><h5 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h5><p>DFA（Deterministic Finite Automata)即确定有穷自动机，与之对应的是 NFA（Non-Deterministic Finite Automata，有穷自动机)。<br>Hutool提供了 DFA 算法的实现。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WordTree wordTree = <span class="keyword">new</span> <span class="constructor">WordTree()</span>;</span><br><span class="line">wordTree.add<span class="constructor">Word(<span class="string">&quot;大&quot;</span>)</span>;</span><br><span class="line">wordTree.add<span class="constructor">Word(<span class="string">&quot;大憨憨&quot;</span>)</span>;</span><br><span class="line">wordTree.add<span class="constructor">Word(<span class="string">&quot;憨憨&quot;</span>)</span>;String text = <span class="string">&quot;那人真是个大憨憨！&quot;</span>;</span><br><span class="line"><span class="comment">// 获得第一个匹配的关键字</span></span><br><span class="line">String matchStr = wordTree.<span class="keyword">match</span>(text);<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(matchStr);</span><br><span class="line"><span class="comment">// 标准匹配，匹配到最短关键词，并跳过已经匹配的关键词</span></span><br><span class="line">List&lt;String&gt; matchStrList = wordTree.<span class="keyword">match</span><span class="constructor">All(<span class="params">text</span>, -1, <span class="params">false</span>, <span class="params">false</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(matchStrList);</span><br><span class="line"><span class="comment">//匹配到最长关键词，跳过已经匹配的关键词</span></span><br><span class="line">List&lt;String&gt; matchStrList2 = wordTree.<span class="keyword">match</span><span class="constructor">All(<span class="params">text</span>, -1, <span class="params">false</span>, <span class="params">true</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(matchStrList2);</span><br></pre></td></tr></table></figure><h4 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h4><ul><li><strong><a href="https://github.com/toolgood/ToolGood.Words">ToolGood.Words</a></strong> ：一款高性能敏感词(非法词/脏字)检测过滤组件，附带繁体简体互换，支持全角半角互换，汉字转拼音，模糊搜索等功能。</li><li><a href="https://github.com/hooj0/sensitive-words-filter"><strong>sensitive-words-filter</strong></a> ：敏感词过滤项目，提供 TTMP、DFA、DAT、hash bucket、Tire 算法支持过滤。可以支持文本的高亮、过滤、判词、替换的接口支持。</li></ul><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="单机定时任务技术选型"><a href="#单机定时任务技术选型" class="headerlink" title="单机定时任务技术选型"></a>单机定时任务技术选型</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>java.util.Timer是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。Timer 内部使用一个叫做 TaskQueue 的类存放定时任务，它是一个基于最小堆实现的优先级队列。TaskQueue 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！</p><p>Timer 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码：TimerTask task = new TimerTask() &#123;</span></span><br><span class="line">    public void run<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;当前时间: &quot;</span> + <span class="keyword">new</span> <span class="constructor">Date()</span> + <span class="string">&quot;n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;线程名称: &quot;</span> + <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">    &#125;&#125;;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;当前时间: &quot;</span> + <span class="keyword">new</span> <span class="constructor">Date()</span> + <span class="string">&quot;n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;线程名称: &quot;</span> + <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>);Timer timer = <span class="keyword">new</span> <span class="constructor">Timer(<span class="string">&quot;Timer&quot;</span>)</span>;long delay = <span class="number">1000L</span>;</span><br><span class="line">timer.schedule(task, delay);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">当前时间: Fri May <span class="number">28</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">47</span> CST <span class="number">2021n</span>线程名称: main</span><br><span class="line">当前时间: Fri May <span class="number">28</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">48</span> CST <span class="number">2021n</span>线程名称: Timer</span><br></pre></td></tr></table></figure><p>不过其缺陷较多，比如一个 Timer 一个线程，这就导致 Timer 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（Timer 只捕获了 InterruptedException ）。</p><h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h4><p>ScheduledExecutorService 是一个接口，有多个实现类，比较常用的是 ScheduledThreadPoolExecutor 。<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/ScheduledExecutorService.png"></p><p>ScheduledThreadPoolExecutor 本身就是一个线程池，支持任务并发执行。并且，其内部使用 DelayQueue 作为任务队列。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码：TimerTask repeatedTask = new TimerTask() &#123;</span></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public void run<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;当前时间: &quot;</span> + <span class="keyword">new</span> <span class="constructor">Date()</span> + <span class="string">&quot;n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;线程名称: &quot;</span> + <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">    &#125;&#125;;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;当前时间: &quot;</span> + <span class="keyword">new</span> <span class="constructor">Date()</span> + <span class="string">&quot;n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;线程名称: &quot;</span> + <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>);ScheduledExecutorService executor = <span class="module-access"><span class="module"><span class="identifier">Executors</span>.</span></span><span class="keyword">new</span><span class="constructor">ScheduledThreadPool(3)</span>;long delay  = <span class="number">1000L</span>;long period = <span class="number">1000L</span>;</span><br><span class="line">executor.schedule<span class="constructor">AtFixedRate(<span class="params">repeatedTask</span>, <span class="params">delay</span>, <span class="params">period</span>, TimeUnit.MILLISECONDS)</span>;<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(delay + period<span class="operator"> * </span><span class="number">5</span>);</span><br><span class="line">executor.shutdown<span class="literal">()</span>;<span class="comment">//输出：</span></span><br><span class="line">当前时间: Fri May <span class="number">28</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">46</span> CST <span class="number">2021n</span>线程名称: main</span><br><span class="line">当前时间: Fri May <span class="number">28</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">47</span> CST <span class="number">2021n</span>线程名称: pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">当前时间: Fri May <span class="number">28</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">48</span> CST <span class="number">2021n</span>线程名称: pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">当前时间: Fri May <span class="number">28</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">49</span> CST <span class="number">2021n</span>线程名称: pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">当前时间: Fri May <span class="number">28</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">50</span> CST <span class="number">2021n</span>线程名称: pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">当前时间: Fri May <span class="number">28</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">51</span> CST <span class="number">2021n</span>线程名称: pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">当前时间: Fri May <span class="number">28</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">52</span> CST <span class="number">2021n</span>线程名称: pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br></pre></td></tr></table></figure><p>不论是使用 Timer 还是 ScheduledExecutorService 都无法使用 Cron 表达式指定任务执行的具体时间。</p><h4 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h4><p>我们直接通过 Spring 提供的 @Scheduled 注解即可定义定时任务，非常方便！</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cron：使用Cron表达式。　每分钟的1，2秒运行</span></span><br><span class="line"><span class="comment"> */</span>@Scheduled(cron = &quot;1-2 * * * * ? &quot;)<span class="built_in">public</span> <span class="type">void</span> reportCurrentTimeWithCronExpression() &#123;</span><br><span class="line">  <span class="keyword">log</span>.<span class="keyword">info</span>(&quot;Cron Expression: The time is now &#123;&#125;&quot;, dateFormat.format(<span class="built_in">new</span> <span class="type">Date</span>()));&#125;</span><br></pre></td></tr></table></figure><p>Spring Task 还是支持 Cron 表达式 的。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 Cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。咱们要学习定时任务的话，Cron 表达式是一定是要重点关注的。</p><p>但是，Spring 自带的定时调度只支持<strong>单机</strong>，并且提供的功能比较单一.<br>Spring Task 底层是基于 JDK 的 ScheduledThreadPoolExecutor 线程池来实现的。</p><h4 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h4><p>Kafka、Dubbo、ZooKeeper、Netty 、Caffeine 、Akka 中都有对时间轮的实现。</p><p>时间轮简单来说就是一个环形的队列（底层一般基于数组实现），队列中的每一个元素（时间格）都可以存放一个定时任务列表。时间轮中的每个时间格代表了时间轮的基本时间跨度或者说时间精度，加入时间一秒走一个时间格的话，那么这个时间轮的最高精度就是 1 秒（也就是说 3 s 和 3.9s 会在同一个时间格中）。</p><p>下图是一个有 12 个时间格的时间轮，转完一圈需要 12 s。当我们需要新建一个 3s 后执行的定时任务，只需要将定时任务放在下标为 3 的时间格中即可。当我们需要新建一个 9s 后执行的定时任务，只需要将定时任务放在下标为 9 的时间格中即可。<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E6%97%B6%E9%97%B4%E8%BD%AE.png"></p><p>那当我们需要创建一个 13s 后执行的定时任务怎么办呢？这个时候可以引入一叫做 圈数/轮数 的概念，也就是说这个任务还是放在下标为 3 的时间格中， 不过它的圈数为 2 。除了增加圈数这种方法之外，还有一种 多层次时间轮 （类似手表），Kafka 采用的就是这种方案。<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/%E6%97%B6%E9%97%B4%E8%BD%AE-1.png"></p><p>上图的时间轮，第 1 层的时间精度为 1 ，第 2 层的时间精度为 20 ，第 3 层的时间精度为 400。假如我们需要添加一个 350s 后执行的任务 A 的话（当前时间是 0s），这个任务会被放在第 2 层（因为第二层的时间跨度为 20 * 20=400&gt;350）的第 350/20=17 个时间格子。当第一层转了 17 圈之后，时间过去了 340s ，第 2 层的指针此时来到第 17 个时间格子。此时，第 2 层第 17 个格子的任务会被移动到第 1 层。任务 A 当前是 10s 之后执行，因此它会被移动到第 1 层的第 10 个时间格子。这里在层与层之间的移动也叫做时间轮的升降级。参考手表来理解就好！</p><p>时间轮比较适合任务数量比较多的定时任务场景，它的任务写入和执行的时间复杂度都是 0（1）。</p><h3 id="分布式定时任务技术选型"><a href="#分布式定时任务技术选型" class="headerlink" title="分布式定时任务技术选型"></a>分布式定时任务技术选型</h3><p>如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。通常情况下，一个定时任务的执行往往涉及到下面这些角色：</p><ul><li>任务 ： 首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。</li><li>调度器 ：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。</li><li>执行器 ： 最后就是执行器，执行器接收调度器分派的任务并执行。</li></ul><h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>使用 Quartz 可以很方便地与 Spring 集成，并且支持动态添加任务和集群。但是，Quartz 使用起来也比较麻烦，API 繁琐,并且，Quzrtz 并没有内置 UI 管理控制台，不过你可以使用 quartzui 这个开源项目来解决这个问题。另外，Quartz 虽然也支持分布式任务。但是，它是在数据库层面，通过数据库的锁机制做的，有非常多的弊端比如系统侵入性严重、节点负载不均衡。有点伪分布式的味道。</p><p>优缺点总结：</p><ul><li>优点： 可以与 Spring 集成，并且支持动态添加任务和集群。</li><li>缺点 ：分布式支持不友好，没有内置 UI 管理控制台、使用麻烦（相比于其他同类型框架来说）</li></ul><h4 id="Elastic-Job"><a href="#Elastic-Job" class="headerlink" title="Elastic-Job"></a>Elastic-Job</h4><p>Elastic-Job 是当当网开源的一个基于Quartz和ZooKeeper的分布式调度解决方案，由两个相互独立的子项目 Elastic-Job-Lite 和 Elastic-Job-Cloud 组成，一般我们只要使用 Elastic-Job-Lite 就好。</p><p>ElasticJob 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能。<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/Elastic-Job.png"></p><p>ElasticJob-Lite 的架构设计如下图所示：<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/ElasticJob-Lite.png"></p><p>从上图可以看出，Elastic-Job 没有调度中心这一概念，而是使用 ZooKeeper 作为注册中心，注册中心负责协调分配任务到不同的节点上。</p><p>Elastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span><span class="variable">@ElasticJobConf</span>(name = <span class="string">&quot;dayJob&quot;</span>, cron = <span class="string">&quot;0/10 * * * * ?&quot;</span>, shardingTotalCount = <span class="number">2</span>,</span><br><span class="line">        shardingItemParameters = <span class="string">&quot;0=AAAA,1=BBBB&quot;</span>, description = <span class="string">&quot;简单任务&quot;</span>, failover = true)public class TestJob implements SimpleJob &#123;</span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void <span class="built_in">execute</span>(ShardingContext shardingContext) &#123;</span><br><span class="line">        <span class="selector-tag">log</span><span class="selector-class">.info</span>(<span class="string">&quot;TestJob任务名：【&#123;&#125;】, 片数：【&#123;&#125;】, param=【&#123;&#125;】&quot;</span>, shardingContext.<span class="built_in">getJobName</span>(), shardingContext.<span class="built_in">getShardingTotalCount</span>(),</span><br><span class="line">                shardingContext.<span class="built_in">getShardingParameter</span>());</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>优缺点总结：</p><ul><li>优点 ：可以与 Spring 集成、支持分布式、支持集群、性能不错</li><li>缺点 ：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）</li></ul><h4 id="XXL-JOB"><a href="#XXL-JOB" class="headerlink" title="XXL-JOB"></a>XXL-JOB</h4><p>XXL-JOB 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能.<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/XXL-JOB%E7%89%B9%E6%80%A7.png"></p><p>根据 XXL-JOB 官网介绍，其解决了很多 Quartz 的不足<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/XXL-JOB.png"></p><p>XXL-JOB 的架构设计如下图所示：<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/xxl-job%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png"></p><p>从上图可以看出，XXL-JOB 由 调度中心 和 执行器 两大部分组成。调度中心主要负责任务管理、执行器管理以及日志管理。执行器主要是接收调度信号并处理。另外，调度中心进行任务调度时，是通过自研 RPC 来实现的。</p><p>和 Quzrtz 类似 XXL-JOB 也是基于数据库锁调度任务，存在性能瓶颈。不过，一般在任务量不是特别大的情况下，没有什么影响的，可以满足绝大部分公司的要求。</p><p>不要被 XXL-JOB 的架构图给吓着了，实际上，我们要用 XXL-JOB 的话，只需要重写 IJobHandler 自定义任务执行逻辑就可以了，非常易用！</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JobHandler</span>(value=<span class="string">&quot;myApiJobHandler&quot;</span>)<span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApiJobHandler</span> <span class="keyword">extends</span> <span class="title">IJobHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">ReturnT</span>&lt;<span class="type">String</span>&gt; execute(<span class="type">String</span> param) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">ReturnT</span>.<span class="type">SUCCESS</span>;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>还可以直接基于注解定义任务。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">XxlJob</span>(<span class="string">&quot;myAnnotationJobHandler&quot;</span>)<span class="function"><span class="keyword">public</span> ReturnT&lt;<span class="type">String</span>&gt; <span class="title">myAnnotationJobHandler</span><span class="params">(<span class="type">String</span> param)</span> throws Exception </span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  <span class="keyword">return</span> ReturnT.SUCCESS;&#125;</span><br></pre></td></tr></table></figure><p>优缺点总结：</p><ul><li>优点：开箱即用（学习成本比较低）、与 Spring 集成、支持分布式、支持集群、内置了 UI 管理控制台。</li><li>缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见：xxl-job issue277）。</li></ul><h4 id="PowerJob"><a href="#PowerJob" class="headerlink" title="PowerJob"></a>PowerJob</h4><p>由于 SchedulerX 属于人民币产品，我这里就不过多介绍。PowerJob 官方也对比过其和 QuartZ、XXL-JOB 以及 SchedulerX。<br><img src="/2023/01/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/PowerJob.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;系统设计基础&quot;&gt;&lt;a href=&quot;#系统设计基础&quot; class=&quot;headerlink&quot; title=&quot;系统设计基础&quot;&gt;&lt;/a&gt;系统设计基础&lt;/h1&gt;&lt;h2 id=&quot;系统设计必备基础&quot;&gt;&lt;a href=&quot;#系统设计必备基础&quot; class=&quot;headerlink&quot; title=&quot;系统设计必备基础&quot;&gt;&lt;/a&gt;系统设计必备基础&lt;/h2&gt;&lt;h3 id=&quot;RESTful-API&quot;&gt;&lt;a href=&quot;#RESTful-API&quot; class=&quot;headerlink&quot; title=&quot;RESTful API&quot;&gt;&lt;/a&gt;RESTful API&lt;/h3&gt;&lt;p&gt;我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API 。RESTful API 是一种基于 REST 构建的 API，它是一种被设计的更好使用的 API。&lt;/p&gt;
&lt;p&gt;API（Application Programming Interface） 翻译过来是应用程序编程接口的意思。&lt;br&gt;但是， API 不仅仅代表后端系统暴露的接口，像框架中提供的方法也属于 API 的范畴。&lt;/p&gt;</summary>
    
    
    
    <category term="系统设计" scheme="https://shenhongwei33.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统设计基础" scheme="https://shenhongwei33.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="https://shenhongwei33.github.io/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://shenhongwei33.github.io/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2023-01-22T13:51:27.000Z</published>
    <updated>2023-01-24T02:25:24.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI-和-TCP-IP-网络分层模型详解（基础）"><a href="#OSI-和-TCP-IP-网络分层模型详解（基础）" class="headerlink" title="OSI 和 TCP/IP 网络分层模型详解（基础）"></a>OSI 和 TCP/IP 网络分层模型详解（基础）</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OSI.png"></p><p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。<br>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OSI-1.png"></p><p>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？<br>主要有下面几方面原因：</p><ol><li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li><li>OSI 的协议实现起来过分复杂，而且运行效率很低</li><li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）</li><li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li></ol><p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OSI-%E6%80%BB%E7%BB%93.png"></p><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><p>TCP/IP 四层模型 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/TCP-IP.png"></p><h4 id="应用层（Application-layer）"><a href="#应用层（Application-layer）" class="headerlink" title="应用层（Application layer）"></a>应用层（Application layer）</h4><p>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。 我们把应用层交互的数据单元称为报文。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BA%94%E7%94%A8%E5%B1%82.png"></p><p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE.png"></p><h4 id="传输层（Transport-layer）"><a href="#传输层（Transport-layer）" class="headerlink" title="传输层（Transport layer）"></a>传输层（Transport layer）</h4><p>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。<br>运输层主要使用以下两种协议：</p><ol><li>传输控制协议 TCP（Transmisson Control Protocol）–提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ol><h4 id="网络层（Network-layer）"><a href="#网络层（Network-layer）" class="headerlink" title="网络层（Network layer）"></a>网络层（Network layer）</h4><p>网络层负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。<br>⚠️<strong>注意 ：不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混。</strong></p><p>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。<br>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。<br>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP 层。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82.png"></p><h4 id="网络接口层（Network-interface-layer）"><a href="#网络接口层（Network-interface-layer）" class="headerlink" title="网络接口层（Network interface layer）"></a>网络接口层（Network interface layer）</h4><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><ul><li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</li><li>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</li></ul><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3.png"></p><h3 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h3><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）。复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</p><p>主要有以下三方面的原因：</p><ol><li>各层之间相互独立：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。这个和我们对开发时系统进行分层是一个道理。</li><li>提高了整体灵活性 ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</li><li>大问题化小 ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</li></ol><h2 id="HTTP-vs-HTTPS（应用层）"><a href="#HTTP-vs-HTTPS（应用层）" class="headerlink" title="HTTP vs HTTPS（应用层）"></a>HTTP vs HTTPS（应用层）</h2><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消，具体来说，主要是来规范浏览器和服务器端的行为的。<br>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p><h4 id="HTTP-协议通信过程"><a href="#HTTP-协议通信过程" class="headerlink" title="HTTP 协议通信过程"></a>HTTP 协议通信过程</h4><p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p><ol><li>服务器在 80 端口等待客户的请求。</li><li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li><li>服务器接收来自浏览器的 TCP 连接。</li><li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li><li>关闭 TCP 连接。</li></ol><h4 id="HTTP-协议优点"><a href="#HTTP-协议优点" class="headerlink" title="HTTP 协议优点"></a>HTTP 协议优点</h4><p>扩展性强、速度快、跨平台支持性好。</p><h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.<br>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p><h4 id="HTTPS-协议优点"><a href="#HTTPS-协议优点" class="headerlink" title="HTTPS 协议优点"></a>HTTPS 协议优点</h4><p>保密性好、信任度高。</p><h4 id="HTTPS-的核心—SSL-TLS协议"><a href="#HTTPS-的核心—SSL-TLS协议" class="headerlink" title="HTTPS 的核心—SSL/TLS协议"></a>HTTPS 的核心—SSL/TLS协议</h4><p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。</p><h5 id="SSL-和-TLS-的区别？"><a href="#SSL-和-TLS-的区别？" class="headerlink" title="SSL 和 TLS 的区别？"></a>SSL 和 TLS 的区别？</h5><p>SSL 和 TLS 没有太大的区别。<br>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，新版本被命名为 TLS 1.0。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL/TLS。</p><h5 id="SSL-TLS-的工作原理"><a href="#SSL-TLS-的工作原理" class="headerlink" title="SSL/TLS 的工作原理"></a>SSL/TLS 的工作原理</h5><p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/SSL.png"></p><p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p><blockquote><p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p></blockquote><p>在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。</p><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p><blockquote><p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p></blockquote><p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p><h5 id="公钥传输的信赖性"><a href="#公钥传输的信赖性" class="headerlink" title="公钥传输的信赖性"></a>公钥传输的信赖性</h5><p>SSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：</p><blockquote><p>客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p><ol><li>任何人都可以捕获通信包</li><li>通信包的保密性由发送者设计</li><li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li></ol><p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p></blockquote><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AC%E9%92%A5%E4%BC%A0%E8%BE%93.png"></p><p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的电子签名（见下节）。</p><p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 靠数字签名技术 。<br>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p><blockquote><p>CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p></blockquote><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></p><p>总结来说，带有证书的公钥传输机制如下：</p><ol><li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li><li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li><li>S 获得 CA 颁发的证书，将该证书传递给 C。</li><li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li><li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li></ol><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AC%E9%92%A5%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6.png"></p><p>对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看<a href="https://www.bilibili.com/video/BV18N411X7ty/">数字签名及数字证书原理</a>这个视频，这是我看过最清晰的讲解。<br>![](计算机基础/数字签名 [2].png)</p><h2 id="HTTP-1-0-vs-HTTP-1-1（应用层）"><a href="#HTTP-1-0-vs-HTTP-1-1（应用层）" class="headerlink" title="HTTP 1.0 vs HTTP 1.1（应用层）"></a>HTTP 1.0 vs HTTP 1.1（应用层）</h2><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>HTTP/1.0仅定义了16种状态码。HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，100 (Continue)——在请求大资源前的预热请求，206 (Partial Content)——范围请求的标识码，409 (Conflict)——请求与当前资源的规定冲突，410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。</p><h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><p>缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。</p><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h4><p>HTTP/1.0提供的缓存机制非常简单。服务器端使用Expires标签来标志（时间）一个响应体，在Expires标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个Last-Modified标签，该标签标记了被请求资源在服务器端的最后一次修改。在请求头中，使用If-Modified-Since标签，该标签标志一个时间，意为客户端向服务器进行问询：“该时间之后，我要请求的资源是否有被修改过？”通常情况下，请求头中的If-Modified-Since的值即为上一次获得该资源时，响应体中的Last-Modified的值。如果服务器接收到了请求头，并判断If-Modified-Since时间后，资源确实没有修改过，则返回给客户端一个304 not modified响应头，表示”缓冲可用，你从浏览器里拿吧！”。如果服务器判断If-Modified-Since时间后，资源被修改过，则返回给客户端一个200 OK的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。</p><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1的缓存机制在HTTP/1.0的基础上，大大增加了灵活性和扩展性。基本工作原理和HTTP/1.0保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是Cache-Control，详见MDN Web文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>。</p><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>HTTP/1.0 默认使用短连接 ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个TCP连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽。</p><p><strong>为了解决 HTTP/1.0 存在的资源浪费的问题</strong>， HTTP/1.1 优化为默认长连接模式 。 采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该TCP连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。</p><p>有必要说明的是，HTTP/1.0仍提供了长连接选项，即在请求头中加入Connection: Keep-alive。同样的，在HTTP/1.1中，如果不希望使用长连接选项，也可以在请求头中加入Connection: close，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。<br><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。实现长连接需要客户端和服务端都支持长连接。</strong></p><h3 id="Host头处理"><a href="#Host头处理" class="headerlink" title="Host头处理"></a>Host头处理</h3><p>域名系统（DNS）允许多个主机名绑定到同一个IP地址上，但是HTTP/1.0并没有考虑这个问题，假设我们有一个资源URL是<a href="http://example1.org/home.html%EF%BC%8CHTTP/1.0%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E4%B8%AD%EF%BC%8C%E5%B0%86%E4%BC%9A%E8%AF%B7%E6%B1%82%E7%9A%84%E6%98%AFGET">http://example1.org/home.html，HTTP/1.0的请求报文中，将会请求的是GET</a> /home.html HTTP/1.0.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。因此，HTTP/1.1在请求头中加入了<strong>Host</strong>字段。加入Host字段的报文头部将会是:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/home.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example1.org</span><br></pre></td></tr></table></figure><p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p><h3 id="带宽优化"><a href="#带宽优化" class="headerlink" title="带宽优化"></a>带宽优化</h3><h4 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h4><p>HTTP/1.1引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1可以在请求中加入Range头部，以请求（并只能请求字节型数据）数据的一部分。服务器端可以忽略Range头部，也可以返回若干Range响应。如果一个响应包含部分数据的话，那么将带有206 (Partial Content)状态码。该状态码的意义在于避免了HTTP/1.0代理缓存错误地把该响应认为是一个完整的数据响应，从而把他当作为一个请求的响应缓存。在范围响应中，Content-Range头部标志指示出了该数据块的偏移量和数据块的长度。</p><h4 id="状态码100"><a href="#状态码100" class="headerlink" title="状态码100"></a>状态码100</h4><p>HTTP/1.1中新加入了状态码100。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码100可以作为指示请求是否会被正常响应，过程如下图：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%8A%B6%E6%80%81%E7%A0%81100.png"><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%8A%B6%E6%80%81%E7%A0%81100-1.png"></p><p>然而在HTTP/1.0中，并没有100 (Continue)状态码，要想触发这一机制，可以发送一个Expect头部，其中包含一个100-continue的值。</p><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>许多格式的数据在传输时都会做预压缩处理。数据的压缩可以大幅优化带宽的利用。然而，HTTP/1.0对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩。</p><p>HTTP/1.1则对内容编码（content-codings）和传输编码（transfer-codings）做了区分。内容编码总是端到端的，传输编码总是逐跳的。<br>HTTP/1.0包含了Content-Encoding头部，对消息进行端到端编码。HTTP/1.1加入了Transfer-Encoding头部，可以对消息进行逐跳传输编码。HTTP/1.1还加入了Accept-Encoding头部，是客户端用来指示他能处理什么样的内容编码。</p><h2 id="计算机网络常见知识点-amp-面试题"><a href="#计算机网络常见知识点-amp-面试题" class="headerlink" title="计算机网络常见知识点&amp;面试题"></a>计算机网络常见知识点&amp;面试题</h2><h3 id="应用层有哪些常见的协议？"><a href="#应用层有哪些常见的协议？" class="headerlink" title="应用层有哪些常见的协议？"></a>应用层有哪些常见的协议？</h3><h4 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP:超文本传输协议"></a>HTTP:超文本传输协议</h4><p>超文本传输协议（HTTP，HyperText Transfer Protocol) 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP.png"></p><p>HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p><h4 id="SMTP-简单邮件传输-发送-协议"><a href="#SMTP-简单邮件传输-发送-协议" class="headerlink" title="SMTP:简单邮件传输(发送)协议"></a>SMTP:简单邮件传输(发送)协议</h4><p>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol） 基于 <strong>TCP 协议</strong>，用来<strong>发送电子邮件</strong>。<br><strong>注意⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p><h5 id="电子邮件的发送过程？"><a href="#电子邮件的发送过程？" class="headerlink" title="电子邮件的发送过程？"></a>电子邮件的发送过程？</h5><p>比如我的邮箱是“<a href="mailto:&#100;&#x61;&#x62;&#x61;&#x69;&#x40;&#99;&#115;&#122;&#x68;&#105;&#x6e;&#97;&#x6e;&#x2e;&#x63;&#x6f;&#109;">&#100;&#x61;&#x62;&#x61;&#x69;&#x40;&#99;&#115;&#122;&#x68;&#105;&#x6e;&#97;&#x6e;&#x2e;&#x63;&#x6f;&#109;</a>”，我要向“<a href="mailto:&#120;&#105;&#97;&#111;&#x6d;&#x61;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;">&#120;&#105;&#97;&#111;&#x6d;&#x61;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;</a>”发送邮件，整个过程可以简单分为下面几步：</p><ol><li>通过 SMTP 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li><li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li><li>qq邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:&#120;&#105;&#x61;&#x6f;&#109;&#x61;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#109;">&#120;&#105;&#x61;&#x6f;&#109;&#x61;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#109;</a>”的用户来收邮件，然后用户就通过 POP3/IMAP 协议将邮件取出。</li></ol><h5 id="如何判断邮箱是真正存在的？"><a href="#如何判断邮箱是真正存在的？" class="headerlink" title="如何判断邮箱是真正存在的？"></a>如何判断邮箱是真正存在的？</h5><p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p><ol><li>查找邮箱域名对应的 SMTP 服务器地址</li><li>尝试与服务器建立连接</li><li>连接成功后尝试向需要验证的邮箱发送邮件</li><li>根据返回结果判定邮箱地址的真实性</li></ol><p>推荐几个在线邮箱是否有效检测工具：</p><ul><li><a href="https://verify-email.org/">https://verify-email.org/</a></li><li><a href="http://tool.chacuo.net/mailverify">http://tool.chacuo.net/mailverify</a></li><li><a href="https://www.emailcamel.com/">https://www.emailcamel.com/</a></li></ul><h4 id="POP3-IMAP-邮件接收的协议"><a href="#POP3-IMAP-邮件接收的协议" class="headerlink" title="POP3/IMAP:邮件接收的协议"></a>POP3/IMAP:邮件接收的协议</h4><p>这两个协议没必要多做阐述，只需要了解 POP3 和 IMAP 两者都是<strong>负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP</strong>。</p><p>IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。</p><h4 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP:文件传输协议"></a>FTP:文件传输协议</h4><p>FTP 协议 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p><p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p><blockquote><p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p><ol><li>控制连接：用于传送控制信息（命令和响应）</li><li>数据连接：用于数据传送；</li></ol><p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p></blockquote><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/FTP.png"></p><h4 id="Telnet-远程登陆协议"><a href="#Telnet-远程登陆协议" class="headerlink" title="Telnet:远程登陆协议"></a>Telnet:远程登陆协议</h4><p>Telnet 协议 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p><h4 id="SSH-安全的网络传输协议"><a href="#SSH-安全的网络传输协议" class="headerlink" title="SSH:安全的网络传输协议"></a>SSH:安全的网络传输协议</h4><p>SSH（ Secure Shell） 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。<br><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p><h3 id="TCP-三次握手和四次挥手-面试常客"><a href="#TCP-三次握手和四次挥手-面试常客" class="headerlink" title="TCP 三次握手和四次挥手(面试常客)"></a>TCP 三次握手和四次挥手(面试常客)</h3><p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p><h4 id="TCP-三次握手漫画图解"><a href="#TCP-三次握手漫画图解" class="headerlink" title="TCP 三次握手漫画图解"></a>TCP 三次握手漫画图解</h4><p>如下图所示，下面的两个机器人通过 3 次握手确定了对方能正确接收和发送消息(图片来源：《图解 HTTP》)。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><p>简单示意图：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><h4 id="详细示意图"><a href="#详细示意图" class="headerlink" title="详细示意图"></a>详细示意图</h4><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%AF%A6%E7%BB%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><p><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双方收发功能都正常，缺一不可。</p><h4 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h4><p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”</p><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ol><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li></ol><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><h3 id="TCP-UDP-协议的区别"><a href="#TCP-UDP-协议的区别" class="headerlink" title="TCP, UDP 协议的区别"></a>TCP, UDP 协议的区别</h3><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/TCP-UDP%E5%8C%BA%E5%88%AB.png"></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制</strong>： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制</strong>： 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ 协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong>： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h4 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h4><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p><h5 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="停止等待 ARQ 协议"></a>停止等待 ARQ 协议</h5><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>优缺点：</strong></p><ul><li>优点： 简单</li><li>缺点： 信道利用率低，等待时间长</li></ul><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为<strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong>可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li></ul><h5 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h5><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优缺点：</strong></p><ul><li>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li></ul><h4 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个<strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。<br>TCP 的拥塞控制采用了四种算法，即<strong>慢开始</strong> 、<strong>拥塞避免</strong> 、<strong>快重传</strong>和<strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始</strong>： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li><li><strong>拥塞避免</strong>： 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li><li><strong>快重传与快恢复</strong>： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h3 id="在浏览器中输入-url-地址-gt-gt-显示主页的过程-面试常客"><a href="#在浏览器中输入-url-地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程(面试常客)"></a>在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程(面试常客)</h3><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E8%BF%87%E7%A8%8B.png"></p><p>上图有一个错误，请注意，是 <strong>OSPF</strong> 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%8A%B6%E6%80%81%E7%A0%81.png"></p><h3 id="各种协议与-HTTP-协议之间的关系"><a href="#各种协议与-HTTP-协议之间的关系" class="headerlink" title="各种协议与 HTTP 协议之间的关系"></a>各种协议与 HTTP 协议之间的关系</h3><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP.png"></p><h3 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><h3 id="Cookie-的作用是什么-和-Session-有什么区别？"><a href="#Cookie-的作用是什么-和-Session-有什么区别？" class="headerlink" title="Cookie 的作用是什么? 和 Session 有什么区别？"></a>Cookie 的作用是什么? 和 Session 有什么区别？</h3><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p>Cookie 一般用来保存用户信息 比如 ① 我们在 Cookie 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你把登录的一些基本信息给填了；② 一般的网站都会有保持登录，也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态</strong>。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。<br>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密，然后使用到的时候再去服务器端解密。</p><h3 id="URI-和-URL-的区别是什么"><a href="#URI-和-URL-的区别是什么" class="headerlink" title="URI 和 URL 的区别是什么?"></a>URI 和 URL 的区别是什么?</h3><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h2><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><ul><li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</li><li>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</li><li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ul><p><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png"></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li><li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><p>说了用户态和系统态之后，那么什么是系统调用呢？我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p><p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。这些系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ol><li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h3 id="线程间的同步的方式"><a href="#线程间的同步的方式" class="headerlink" title="线程间的同步的方式"></a>线程间的同步的方式</h3><ol><li><strong>互斥量(Mutex)</strong> ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ol><h2 id="操作系统内存管理基础"><a href="#操作系统内存管理基础" class="headerlink" title="操作系统内存管理基础"></a>操作系统内存管理基础</h2><h3 id="内存管理介绍"><a href="#内存管理介绍" class="headerlink" title="内存管理介绍"></a>内存管理介绍</h3><p>操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p><h3 id="常见的几种内存管理机制"><a href="#常见的几种内存管理机制" class="headerlink" title="常见的几种内存管理机制"></a>常见的几种内存管理机制</h3><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如<strong>块式管理</strong>。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong>和<strong>段式管理</strong>。</p><ol><li><strong>块式管理</strong>： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li></ol><p>简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。</p><p><strong>段页式管理机制</strong>结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。</p><h3 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h3><p>在分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快。</li><li>解决虚拟地址空间大，页表也会很大的问题。</li></ol><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>为了提高虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><p>使用快表之后的地址转换流程是这样的：</p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章-<a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">多级页表如何节约内存</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。</p><h3 id="分页机制和分段机制的共同点和区别"><a href="#分页机制和分段机制的共同点和区别" class="headerlink" title="分页机制和分段机制的共同点和区别"></a>分页机制和分段机制的共同点和区别</h3><p>共同点：</p><ul><li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul><p>不同点：</p><ul><li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li></ul><h3 id="逻辑-虚拟-地址和物理地址"><a href="#逻辑-虚拟-地址和物理地址" class="headerlink" title="逻辑(虚拟)地址和物理地址"></a>逻辑(虚拟)地址和物理地址</h3><p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p><h3 id="CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>CPU 寻址了解吗?为什么需要虚拟地址空间?</h3><p>现代处理器使用的是一种称为<strong>虚拟寻址</strong>(Virtual Addressing) 的寻址方式。使用虚拟寻址，<strong>CPU需要将虚拟地址翻译成物理地址</strong>，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为<strong>内存管理单元</strong>（Memory Management Unit, MMU） 的硬件。如下图所示：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80.png"></p><p><strong>为什么要有虚拟地址空间呢？</strong></p><p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存 。但是这样有什么问题呢？</p><ol><li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li><li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li></ol><p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p><p>通过虚拟地址访问内存有以下优势：</p><ul><li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li><li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li><li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="什么是虚拟内存-Virtual-Memory"><a href="#什么是虚拟内存-Virtual-Memory" class="headerlink" title="什么是虚拟内存(Virtual Memory)?"></a>什么是虚拟内存(Virtual Memory)?</h3><p>这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。为什么可以这样呢？ 正是因为 虚拟内存 的存在，通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。<br>虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。推荐阅读：<a href="https://juejin.cn/post/6844903507594575886">《虚拟内存的那点事儿》</a></p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p><p>早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。<br>局部性原理表现在以下两个方面：</p><ol><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ol><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——<strong>虚拟存储器</strong>。<br>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p><h3 id="虚拟内存的技术实现"><a href="#虚拟内存的技术实现" class="headerlink" title="虚拟内存的技术实现"></a>虚拟内存的技术实现</h3><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上</strong>。 虚拟内存的实现有以下三种方式：</p><ol><li>请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li>请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li>请求段页式存储管理</li></ol><p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong><br>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p><p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。不管是上面那种实现方式，我们一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li>缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</li><li>虚拟地址空间 ：逻辑地址到物理地址的变换。</li></ol><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p><ul><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li><li><strong>FIFO（First In First Out） 页面置换算法</strong>（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组（Array） 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。<br>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。数组的特点是：提供随机访问 并且容量有限。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假如数组的长度为 n。</span><br><span class="line">访问：O（<span class="number">1</span>）<span class="regexp">//</span>访问特定位置的元素</span><br><span class="line">插入：O（n ）<span class="regexp">//</span>最坏的情况发生在插入发生在数组的首部并需要移动所有元素时</span><br><span class="line">删除：O（n）<span class="regexp">//</span>最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表（LinkedList） 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。<br>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。<br>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p><h4 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h4><p>常见链表分类：</p><ol><li>单链表</li><li>双向链表</li><li>循环链表</li><li>双向循环链表<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假如链表中有n个元素。</span><br><span class="line">访问：O（n）<span class="regexp">//</span>访问特定位置的元素</span><br><span class="line">插入删除：O（<span class="number">1</span>）<span class="regexp">//</span>必须要要知道插入元素的位置</span><br></pre></td></tr></table></figure></li></ol><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><p>单链表 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8D%95%E9%93%BE%E8%A1%A8.png"></p><h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>循环链表 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png"></p><h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>双向链表 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p><h5 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h5><p>双向循环链表 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png"></p><h4 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h4><ul><li>数组支持随机访问，而链表不支持。</li><li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li><li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈 (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 后进先出（LIFO, Last In First Out） 的原理运作。在栈中，push 和 pop 的操作都发生在栈顶。</p><p>栈常用一维数组或链表来实现，用数组实现的栈叫作 顺序栈 ，用链表实现的栈叫作 链式栈 。</p><h4 id="栈的常见应用常见应用场景"><a href="#栈的常见应用常见应用场景" class="headerlink" title="栈的常见应用常见应用场景"></a>栈的常见应用常见应用场景</h4><p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 后进先出（LIFO, Last In First Out） 的特性时，我们就可以使用栈这个数据结构。</p><h5 id="实现浏览器的回退和前进功能"><a href="#实现浏览器的回退和前进功能" class="headerlink" title="实现浏览器的回退和前进功能"></a>实现浏览器的回退和前进功能</h5><p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%A0%88.png"></p><h5 id="检查符号是否成对出现"><a href="#检查符号是否成对出现" class="headerlink" title="检查符号是否成对出现"></a>检查符号是否成对出现</h5><ul><li>首先我们将括号间的对应规则存放在 Map 中，这一点应该毋容置疑；</li><li>创建一个栈。遍历字符串，如果字符是左括号就直接加入stack中，否则将stack 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果stack为空，返回 true。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title">isValid</span><span class="params">(<span class="type">String</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 括号之间的对应规则</span></span><br><span class="line">    HashMap&lt;Character, Character&gt; mappings = <span class="keyword">new</span> <span class="built_in">HashMap</span>&lt;Character, Character&gt;();</span><br><span class="line">    mappings.<span class="built_in">put</span>(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    mappings.<span class="built_in">put</span>(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    mappings.<span class="built_in">put</span>(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;Character&gt;();</span><br><span class="line">    <span class="type">char</span>[] chars = s.<span class="built_in">toCharArray</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappings.<span class="built_in">containsKey</span>(chars[i])) &#123;</span><br><span class="line">            <span class="type">char</span> topElement = stack.<span class="built_in">empty</span>() ? <span class="string">&#x27;#&#x27;</span> : stack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (topElement != mappings.<span class="built_in">get</span>(chars[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="built_in">isEmpty</span>();&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h5><p>将字符串中的每个字符先入栈再出栈就可以了。</p><h5 id="维护函数调用"><a href="#维护函数调用" class="headerlink" title="维护函数调用"></a>维护函数调用</h5><p>最后一个被调用的函数必须先完成执行，符合栈的 后进先出（LIFO, Last In First Out） 特性。</p><h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。<br>下面我们使用数组来实现一个栈，并且这个栈具有push()、pop()（返回栈顶元素并出栈）、peek() （返回栈顶元素不出栈）、isEmpty()、size()这些基本的方法。</p><blockquote><p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用Arrays.copyOf()进行扩容；</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] storage;<span class="comment">//存放栈中元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> capacity;<span class="comment">//栈的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count;<span class="comment">//栈中元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="built_in">int</span> GROW_FACTOR = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不带初始容量的构造方法。默认容量为8</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">this</span>.storage=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带初始容量的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span>(<span class="params"><span class="built_in">int</span> initialCapacity</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Capacity too small.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.capacity = initialCapacity;</span><br><span class="line">        <span class="keyword">this</span>.storage = <span class="keyword">new</span> <span class="built_in">int</span>[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            ensureCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        storage[count++] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保容量大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> newCapacity = capacity * GROW_FACTOR;</span><br><span class="line">        storage = Arrays.copyOf(storage, newCapacity);</span><br><span class="line">        capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素并出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">pop</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> storage[count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素不出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">peek</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storage[count<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">isEmpty</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">size</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列 是 先进先出( FIFO，First In, First Out) 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 顺序队列 ，用链表实现的队列叫作 链式队列 。队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue。<br>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设队列中有n个元素。</span><br><span class="line">访问：O（n）<span class="regexp">//</span>最坏情况</span><br><span class="line">插入删除：O（<span class="number">1</span>）<span class="regexp">//</span>后端插入前端删除元素</span><br></pre></td></tr></table></figure><h4 id="队列分类"><a href="#队列分类" class="headerlink" title="队列分类"></a>队列分类</h4><h5 id="单队列"><a href="#单队列" class="headerlink" title="单队列"></a>单队列</h5><p>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</p><p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 ”假溢出“ 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。</p><blockquote><p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8D%95%E9%98%9F%E5%88%97.png"></p></blockquote><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。<br>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png"></p><p>顺序队列中，我们说 front==rear 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p><ol><li>可以设置一个标志变量 flag,当 front==rear 并且 flag=0 的时候队列为空，当front==rear 并且 flag=1 的时候队列为满。</li><li>队列为空的时候就是 front==rear ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： (rear+1) % QueueSize= front 。</li></ol><h4 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h4><p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p><ul><li>阻塞队列： 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li><li>线程池中的请求/任务队列： 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：FixedThreadPool 使用无界队列 LinkedBlockingQueue。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出java.util.concurrent.RejectedExecutionException 异常。</li><li>Linux 内核进程队列（按优先级排队）</li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图形结构的元素之间的关系是任意的。图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：G(V,E)，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><h4 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h4><p>图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）对应到好友关系图，每一个用户就代表一个顶点。</p><h4 id="边"><a href="#边" class="headerlink" title="边"></a>边</h4><p>顶点之间的关系用边表示。对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。</p><h4 id="度"><a href="#度" class="headerlink" title="度"></a>度</h4><p>度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。对应到好友关系图，度就代表了某个人的好友数量。</p><h4 id="无向图和有向图"><a href="#无向图和有向图" class="headerlink" title="无向图和有向图"></a>无向图和有向图</h4><p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。</p><h4 id="无权图和带权图"><a href="#无权图和带权图" class="headerlink" title="无权图和带权图"></a>无权图和带权图</h4><p>对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B8%A6%E6%9D%83%E5%9B%BE.png"></p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵存储"><a href="#邻接矩阵存储" class="headerlink" title="邻接矩阵存储"></a>邻接矩阵存储</h4><p>邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 A[i][j]=n 。在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，A[i][j]=1，当顶点i和顶点j没有关系时，A[i][j]=0。如下图所示：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8.png"></p><p>值得注意的是：<strong>无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8-1.png"></p><p>邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，</p><h4 id="邻接表存储"><a href="#邻接表存储" class="headerlink" title="邻接表存储"></a>邻接表存储</h4><p>针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—邻接表 。邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 邻接表。如下图所示：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8.png"><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8-1.png"></p><p>大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：</p><ul><li>在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。</li><li>在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。</li></ul><h3 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h3><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.png"><br>广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列 。具体过程如下图所示：<br><strong>第1步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-1.png"><br><strong>第2步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-2.png"><br><strong>第3步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-3.png"><br><strong>第4步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-4.png"><br><strong>第5步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-5.png"><br><strong>第6步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-6.png"></p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.png"></p><p>和广度优先搜索类似，<strong>深度优先搜索的具体实现用到了另一种线性数据结构——栈</strong> 。具体过程如下图所示：<br><strong>第1步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-1.png"><br><strong>第2步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-2.png"><br><strong>第3步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-3.png"><br><strong>第4步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-4.png"><br><strong>第5步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-5.png"><br><strong>第6步：</strong><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-6.png"></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆是一种满足以下条件的树：堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p><blockquote><p>大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。</p></blockquote><p><strong>特别提示：</strong></p><ul><li>很多博客说堆是完全二叉树，其实并非如此，堆不一定是完全二叉树，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。</li><li>（二叉）堆是一个数组，它可以被看成是一个 近似的完全二叉树。——《算法导论》第三版</li></ul><h3 id="堆的用途"><a href="#堆的用途" class="headerlink" title="堆的用途"></a>堆的用途</h3><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p><p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 O(nlog(n))，查找最大值或者最小值时间复杂度都是 O(1)，但是，涉及到更新（插入或删除）数据时，时间复杂度为 O(n)，即使是使用复杂度为 O(log(n)) 的二分法找到要插入或者删除的数据，在移动数据时也需要 O(n) 的时间复杂度。<br>相对于有序数组而言，堆的主要优势在于更新数据效率较高。 堆的初始化时间复杂度为 O(nlog(n))，堆可以做到O(1)时间复杂度取出最大值或者最小值，O(log(n))时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。</p><h3 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h3><p>堆分为 最大堆 和 最小堆。二者的区别在于节点的排序方式。</p><ul><li>最大堆 ：堆中的每一个节点的值都大于等于子树中所有节点的值</li><li>最小堆 ：堆中的每一个节点的值都小于等于子树中所有节点的值</li></ul><h3 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h3><p>之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 2<em>i，右子节点序号为 2</em>i+1）。为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E5%A0%86.png"></p><h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><p>堆的更新操作主要包括两种 : 插入元素 和 删除堆顶元素。操作过程需要着重掌握和理解。</p><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>1.将要插入的元素放到最后<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E5%A0%86-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0.png"></p><p>2.从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%8F%92%E5%85%A5-%E4%BB%8E%E5%BA%95%E5%90%91%E4%B8%8A.png"><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%8F%92%E5%85%A5-%E4%BB%8E%E5%BA%95%E5%90%91%E4%B8%8A-1.png"></p><h4 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h4><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p><p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为”堆化”，堆化的方法分为两种：</p><ul><li>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li><li>另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。</li></ul><h5 id="自底向上堆化"><a href="#自底向上堆化" class="headerlink" title="自底向上堆化"></a>自底向上堆化</h5><p>首先删除堆顶元素，使得数组中下标为1的位置空出。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6-1.png"></p><p>比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6-2.png"></p><p>一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6-3.png"></p><p>这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到<strong>数组中出现了“气泡”</strong>，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。</p><h5 id="自顶向下堆化"><a href="#自顶向下堆化" class="headerlink" title="自顶向下堆化"></a>自顶向下堆化</h5><p>自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%A0%86%E5%8C%96-1.png"></p><p>然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%A0%86%E5%8C%96-2.png"><br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%A0%86%E5%8C%96-3.png"></p><h4 id="堆的操作总结"><a href="#堆的操作总结" class="headerlink" title="堆的操作总结"></a>堆的操作总结</h4><ul><li>插入元素 ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li><li>删除堆顶元素 ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的过程分为两步：</p><ul><li>第一步是建堆，将一个无序的数组建立为一个堆</li><li>第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li></ul><h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><p>如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对<strong>n/2到1</strong>的节点进行自顶向下（沉底）堆化。</p><p>具体过程如下图：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BB%BA%E5%A0%86-1.png"></p><p>将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，<strong>顺序是从后往前堆化</strong>，从3号节点开始，一直到1号节点。 3号节点堆化结果：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BB%BA%E5%A0%86-2.png"><br>2号节点堆化结果：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BB%BA%E5%A0%86-3.png"><br>1号节点堆化结果：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BB%BA%E5%A0%86-4.png"><br>至此，数组所对应的树已经成为了一个最大堆，建堆完成！</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p><p>现在思考两个问题：</p><ul><li>删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？</li><li>取出的堆顶元素存在哪，新建一个数组存？</li></ul><p>先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p><p>机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。详细过程如下图所示：取出第一个元素并堆化：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F-1.png"><br>取出第二个元素并堆化<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F-2.png"><br>取出第三个元素并堆化：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F-3.png"><br>取出第四个元素并堆化：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F-4.png"><br>取出第五个元素并堆化：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F-5.png"><br>取出第六个元素并堆化：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F-6.png"><br>堆排序完成！</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。<br>一棵树具有以下特点：</p><ol><li>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</li><li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</li><li>一棵树不包含回路。</li></ol><p>下图就是一颗树，并且是一颗二叉树。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%A0%91.png"><br>如上图所示，通过上面这张图说明一下树中的常用概念：</p><ul><li>节点 ：树中的每个元素都可以统称为节点。</li><li>根节点 ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。</li><li>父节点 ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。</li><li>子节点 ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。</li><li>兄弟节点 ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</li><li>叶子节点 ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。</li><li>节点的高度 ：该节点到叶子节点的最长路径所包含的边数。</li><li>节点的深度 ：根节点到该节点的路径所包含的边数</li><li>节点的层数 ：节点的深度+1。</li><li>树的高度 ：根节点的高度。</li></ul><h3 id="二叉树的分类"><a href="#二叉树的分类" class="headerlink" title="二叉树的分类"></a>二叉树的分类</h3><p>二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p><p>二叉树 的分支通常被称作“左子树”或“右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒。<br>二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^k-1 个节点</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 满二叉树。</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 完全二叉树 。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><p>完全二叉树有一个很好的性质：<strong>父结点和子节点的序号有着对应关系</strong>。<br>当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树 是一棵二叉排序树，且具有以下性质：</p><ol><li>可以是一棵空树</li><li>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li></ol><p>平衡二叉树的常用实现方法有 红黑树、AVL 树、替罪羊树、加权平衡树、伸展树 等。<br>在给大家展示平衡二叉树之前，先给大家看一棵树：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%96%9C%E6%A0%91.png"><br>这棵树已经退化为一个链表了，我们管它叫 斜树。<br>二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得我们在树中对数据进行搜索和修改时，相对于链表更加快捷便利。但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，我们希望每个做 “家长”（父结点) 的，都 一碗水端平，分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层。</p><h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h5><p>特性：</p><ol><li>左子树上所有结点的值均小于或等于它的根结点的值。</li><li>右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉排序树。</li></ol><p>这种方式正是二分查找的思想，查找所需的最大次数等于二叉查找树的高度。在插入节点的时候也是一层一层比较大小，找到新节点适合插入的位置。<br>但是二叉查找树是有缺陷的，<br>假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12，接下来我们依次插入如下五个节点：7,6,5,4,3。依照二叉查找树的特性会变成<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png"><br>导致查找的性能几乎变成了线性，而红黑树就解决了这个问题。</p><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>红黑树特点 :</p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><strong>红黑树的应用</strong> ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。</p><p>为什么要用红黑树？ 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><p>当插入或删除节点时，红黑树的规则可能会被打破，调整的方法有两种，变色和旋转，而旋转又分为左旋转和右旋转。</p><p>变色：为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。</p><p>区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BA%A2%E9%BB%91%E6%A0%91.png"><br>左旋：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B7%A6%E6%97%8B.gif"><br>右旋：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8F%B3%E6%97%8B.gif"></p><h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><p>二叉树的存储主要分为 链式存储 和 顺序存储 两种：</p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。<br>每个节点包括三个属性：</p><ul><li>数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</li><li>左节点指针 left</li><li>右节点指针 right。</li></ul><p>可是 JAVA 没有指针啊！那就直接引用对象呗（别问我对象哪里找）<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png"></p><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2 * i 的位置，它的右子节点存储在下标为 2 * i+1 的位置。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png"></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="built_in">preOrder</span>(TreeNode root)&#123;</span><br><span class="line">    <span class="built_in">if</span>(root == null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    system<span class="selector-class">.out</span><span class="selector-class">.println</span>(root.data);</span><br><span class="line">    <span class="built_in">preOrder</span>(root.left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root.right);&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树，大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="built_in">inOrder</span>(TreeNode root)&#123;</span><br><span class="line">    <span class="built_in">if</span>(root == null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inOrder</span>(root.left);</span><br><span class="line">    system<span class="selector-class">.out</span><span class="selector-class">.println</span>(root.data);</span><br><span class="line">    <span class="built_in">inOrder</span>(root.right);&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="built_in">postOrder</span>(TreeNode root)&#123;</span><br><span class="line">    <span class="built_in">if</span>(root == null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">postOrder</span>(root.left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root.right);</span><br><span class="line">    system<span class="selector-class">.out</span><span class="selector-class">.println</span>(root.data);&#125;</span><br></pre></td></tr></table></figure><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。<br><img src="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p><p>位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。</p><p>总结：一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</p><h3 id="布隆过滤器的原理介绍"><a href="#布隆过滤器的原理介绍" class="headerlink" title="布隆过滤器的原理介绍"></a>布隆过滤器的原理介绍</h3><p>当一个元素加入布隆过滤器中的时候，会进行如下操作：</p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>综上，我们可以得出：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</p><h3 id="布隆过滤器使用场景"><a href="#布隆过滤器使用场景" class="headerlink" title="布隆过滤器使用场景"></a>布隆过滤器使用场景</h3><ol><li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li><li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li></ol><h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><h4 id="通过-Java-编程手动实现布隆过滤器"><a href="#通过-Java-编程手动实现布隆过滤器" class="headerlink" title="通过 Java 编程手动实现布隆过滤器"></a>通过 Java 编程手动实现布隆过滤器</h4><p>如果你想要手动实现一个的话，你需要：</p><ol><li>一个合适大小的位数组保存数据</li><li>几个不同的哈希函数</li><li>添加元素到位数组（布隆过滤器）的方法实现</li><li>判断给定元素是否存在于位数组（布隆过滤器）的方法实现。</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBloomFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> DEFAULT_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过这个数组可以创建 6 个不同的哈希函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span>[] SEEDS = <span class="keyword">new</span> <span class="type">int</span>[]&#123;<span class="number">3</span>, <span class="number">13</span>, <span class="number">46</span>, <span class="number">71</span>, <span class="number">91</span>, <span class="number">134</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位数组。数组中的元素只能是 0 或者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BitSet bits = <span class="keyword">new</span> <span class="built_in">BitSet</span>(DEFAULT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放包含 hash 函数的类的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SimpleHash[] func = <span class="keyword">new</span> SimpleHash[SEEDS.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBloomFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化多个不同的 Hash 函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEEDS.length; i++) &#123;</span><br><span class="line">            func[i] = <span class="keyword">new</span> <span class="built_in">SimpleHash</span>(DEFAULT_SIZE, SEEDS[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">add</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            bits.<span class="built_in">set</span>(f.<span class="built_in">hash</span>(value), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断指定元素是否存在于位数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="type">boolean</span> ret = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            ret = ret &amp;&amp; bits.<span class="built_in">get</span>(f.<span class="built_in">hash</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类。用于 hash 操作！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">SimpleHash</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> seed;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleHash</span><span class="params">(<span class="type">int</span> cap, <span class="type">int</span> seed)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cap = cap;</span><br><span class="line">            <span class="keyword">this</span>.seed = seed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算 hash 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> h;</span><br><span class="line">            <span class="keyword">return</span> (value == null) ? <span class="number">0</span> : Math.<span class="built_in">abs</span>(seed * (cap - <span class="number">1</span>) &amp; ((h = value.<span class="built_in">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="利用-Google-开源的-Guava-中自带的布隆过滤器"><a href="#利用-Google-开源的-Guava-中自带的布隆过滤器" class="headerlink" title="利用 Google 开源的 Guava 中自带的布隆过滤器"></a>利用 Google 开源的 Guava 中自带的布隆过滤器</h4><p>自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。</p><p>首先我们需要在项目中引入 Guava 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建布隆过滤器对象</span><br><span class="line">BloomFilter&lt;<span class="type">Integer</span>&gt; <span class="keyword">filter</span> = BloomFilter.<span class="keyword">create</span>(</span><br><span class="line">    Funnels.integerFunnel(),</span><br><span class="line">    <span class="number">1500</span>,</span><br><span class="line">    <span class="number">0.01</span>);// 判断指定元素是否存在</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">filter</span>.mightContain(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">filter</span>.mightContain(<span class="number">2</span>));// 将元素添加进布隆过滤器</span><br><span class="line"><span class="keyword">filter</span>.put(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">filter</span>.put(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">filter</span>.mightContain(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">filter</span>.mightContain(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>在我们的示例中，当 mightContain() 方法返回 true 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 false 时，我们可以 100％确定该元素不存在于过滤器中。<br>Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。</p><h4 id="Redis-中的布隆过滤器"><a href="#Redis-中的布隆过滤器" class="headerlink" title="Redis 中的布隆过滤器"></a>Redis 中的布隆过滤器</h4><p>Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。详情可以查看 Redis 官方对 Redis Modules 的介绍 ：<a href="https://redis.io/modules">https://redis.io/modules</a></p><p>另外，官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：<a href="https://github.com/RedisBloom/RedisBloom">https://github.com/RedisBloom/RedisBloom</a> 其他还有：</p><p>RedisBloom 提供了多种语言的客户端支持，包括：Python、Java、JavaScript 和 PHP。<br>使用 Docker 安装</p><p>如果我们需要体验 Redis 中的布隆过滤器非常简单，通过 Docker 就可以了！我们直接在 Google 搜索 docker redis bloomfilter 然后在排除广告的第一条搜素结果就找到了我们想要的答案（这是我平常解决问题的一种方式，分享一下），具体地址：<a href="https://hub.docker.com/r/redislabs/rebloom/">https://hub.docker.com/r/redislabs/rebloom/</a> （介绍的很详细 ）。</p><h5 id="常用命令一览"><a href="#常用命令一览" class="headerlink" title="常用命令一览"></a>常用命令一览</h5><blockquote><p>注意： key : 布隆过滤器的名称，item : 添加的元素。</p></blockquote><ol><li><strong>BF.ADD</strong>：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：BF.ADD {key} {item}。</li><li><strong>BF.MADD</strong> : 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式BF.ADD与之相同，只不过它允许多个输入并返回多个值。格式：BF.MADD {key} {item} [item …] 。</li><li><strong>BF.EXISTS</strong> : 确定元素是否在布隆过滤器中存在。格式：BF.EXISTS {key} {item}。</li><li><strong>BF.MEXISTS</strong> ： 确定一个或者多个元素是否在布隆过滤器中存在格式：BF.MEXISTS {key} {item} [item …]。</li></ol><p>另外， BF. RESERVE 命令需要单独介绍一下，这个命令的格式如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">BF. RESERVE </span><span class="template-variable">&#123;key&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;error_rate&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;capacity&#125;</span><span class="language-xml"> [EXPANSION expansion]</span></span><br></pre></td></tr></table></figure><p>下面简单介绍一下每个参数的具体含义：</p><ol><li>key：布隆过滤器的名称</li><li>error_rate : 期望的误报率。该值必须介于 0 到 1 之间。例如，对于期望的误报率 0.1％（1000 中为 1），error_rate 应该设置为 0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的 CPU 使用率越高。</li><li>capacity: 过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。</li></ol><p>可选参数：</p><ul><li>expansion：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以expansion。默认扩展值为 2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。<br>实际使用：<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; BF.ADD myFilter java</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; BF.ADD myFilter javaguide</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; BF.EXISTS myFilter java</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; BF.EXISTS myFilter javaguide</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; BF.EXISTS myFilter github</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;h2 id=&quot;OSI-和-TCP-IP-网络分层模型详解（基础）&quot;&gt;&lt;a href=&quot;#OSI-和-TCP-IP-网络分层模型详解（基础）&quot; class=&quot;headerlink&quot; title=&quot;OSI 和 TCP/IP 网络分层模型详解（基础）&quot;&gt;&lt;/a&gt;OSI 和 TCP/IP 网络分层模型详解（基础）&lt;/h2&gt;&lt;h3 id=&quot;OSI-七层模型&quot;&gt;&lt;a href=&quot;#OSI-七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 七层模型&quot;&gt;&lt;/a&gt;OSI 七层模型&lt;/h3&gt;&lt;p&gt;OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：&lt;br&gt;&lt;img src=&quot;/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OSI.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。&lt;br&gt;OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。&lt;br&gt;&lt;img src=&quot;/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OSI-1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://shenhongwei33.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://shenhongwei33.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统</title>
    <link href="https://shenhongwei33.github.io/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>https://shenhongwei33.github.io/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-01-22T10:35:11.000Z</published>
    <updated>2023-01-22T11:43:36.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理论-amp-算法"><a href="#理论-amp-算法" class="headerlink" title="理论&amp;算法"></a>理论&amp;算法</h1><h2 id="分布式基础"><a href="#分布式基础" class="headerlink" title="分布式基础"></a>分布式基础</h2><h3 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式?"></a>什么是分布式?</h3><p>分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。</p><h3 id="为什么要分布式"><a href="#为什么要分布式" class="headerlink" title="为什么要分布式?"></a>为什么要分布式?</h3><p>从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。<br>另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。你想一想嘛？把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？</p><h2 id="CAP-amp-BASE理论"><a href="#CAP-amp-BASE理论" class="headerlink" title="CAP &amp; BASE理论"></a>CAP &amp; BASE理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP 理论/定理 (opens new window)起源于 2000年，由加州大学伯克利分校的Eric Brewer教授在分布式计算原理研讨会（PODC）上提出，因此 CAP定理又被称作 布鲁尔定理（Brewer’s theorem）。</p><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/CAP.png"></p><p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 Consistency、Availability、Partition Tolerance 三个单词的明确定义。</p><p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p><ul><li>一致性（Consistency） : 所有节点访问同一份最新的数据副本</li><li>可用性（Availability）: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li><li>分区容错性（Partition tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><blockquote><p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p></blockquote><h4 id="不是所谓的“3-选-2”"><a href="#不是所谓的“3-选-2”" class="headerlink" title="不是所谓的“3 选 2”"></a>不是所谓的“3 选 2”</h4><p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p><blockquote><p><strong>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</strong></p></blockquote><p>因此，分布式系统理论上不可能选择 CA 架构，<strong>只能选择 CP 或者 AP 架构</strong>。 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p><p>为啥不可能选择 CA 架构呢？ 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p><p>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</p><p>另外，需要补充说明的一点是： <strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等在系统发生“分区”的情况下，CAP 理论只能满足 CP 或者 AP。要注意的是，这里的<strong>前提是系统发生了“分区”</strong><br>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。</p><p><strong>总结：如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><h4 id="BASE-理论的核心思想"><a href="#BASE-理论的核心思想" class="headerlink" title="BASE 理论的核心思想"></a>BASE 理论的核心思想</h4><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><blockquote><p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p></blockquote><p><strong>BASE 理论本质上是对 CAP 的延伸和补充</strong>，更具体地说，<strong>是对 CAP 中 AP 方案的一个补充。</strong></p><blockquote><p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</p></blockquote><p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p><h4 id="BASE-理论三要素"><a href="#BASE-理论三要素" class="headerlink" title="BASE 理论三要素"></a>BASE 理论三要素</h4><p><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/BASE.png"></p><h5 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h5><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p><p>什么叫允许损失部分可用性呢？</p><ul><li>响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li>系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><h5 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h5><p>软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h5 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h5><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><blockquote><p>分布式一致性的 3 种级别：</p><ul><li><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。</li><li><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li><li><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li></ul><p>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</p></blockquote><p>实现最终一致性的具体方式：</p><ul><li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点 的副本数据不一致，系统就自动修复数据。</li><li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li><li>异步修复 : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li></ul><p>比较推荐 写时修复，这种方式对性能消耗比较低。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p><h2 id="Paxos-算法和-Raft-算法"><a href="#Paxos-算法和-Raft-算法" class="headerlink" title="Paxos 算法和 Raft 算法"></a>Paxos 算法和 Raft 算法</h2><p>Paxos 算法诞生于 1990 年，这是一种解决分布式系统一致性的经典算法 。但是，由于 Paxos 算法非常难以理解和实现，不断有人尝试简化这一算法。到了2013 年才诞生了一个比 Paxos 算法更易理解和实现的分布式一致性算法—Raft 算法。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC 让调用远程服务调用像调用本地方法那样简单。</p><h3 id="Dubbo知识点-amp-面试题总结"><a href="#Dubbo知识点-amp-面试题总结" class="headerlink" title="Dubbo知识点&amp;面试题总结"></a>Dubbo知识点&amp;面试题总结</h3><h4 id="RPC基础"><a href="#RPC基础" class="headerlink" title="RPC基础"></a>RPC基础</h4><p>RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p><p><strong>为什么要 RPC ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。</p><p>RPC 能帮助我们做什么呢？ 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。</p><p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。<br>一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单</strong>。</p><h5 id="RPC-的原理"><a href="#RPC-的原理" class="headerlink" title="RPC 的原理"></a>RPC 的原理</h5><p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC的 核心功能看作是下面5个部分实现的：</p><ol><li>客户端（服务消费端） ：调用远程方法的一端。</li><li>客户端 Stub（桩） ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li><li>网络传输 ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。</li><li>服务端 Stub（桩） ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li><li>服务端（服务提供端） ：提供远程方法的一端。</li></ol><p>具体原理图如下，<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/RPC%E5%8E%9F%E7%90%86.png"></p><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: RpcRequest；</li><li>服务端 Stub（桩）根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:RpcResponse ，这样也就得到了最终结果。over!</li></ol><h5 id="常见的-RPC-框架总结"><a href="#常见的-RPC-框架总结" class="headerlink" title="常见的 RPC 框架总结"></a>常见的 RPC 框架总结</h5><ul><li>RMI（JDK自带）： JDK自带的RPC，有很多局限性，不推荐使用。</li><li>Dubbo: Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</li><li>gRPC ：gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</li><li>Hessian： Hessian是一个轻量级的remoting on http工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</li><li>Thrift： Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</li></ul><h4 id="既有-HTTP-为啥用-RPC-进行服务调用"><a href="#既有-HTTP-为啥用-RPC-进行服务调用" class="headerlink" title="既有 HTTP ,为啥用 RPC 进行服务调用?"></a>既有 HTTP ,为啥用 RPC 进行服务调用?</h4><p>RPC 只是一种概念、一种设计，就是为了解决 不同服务之间的调用问题, 它一般会包含有 传输协议 和 序列化协议 这两个。但是，HTTP 是一种协议，RPC框架可以使用 HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。</p><p>成熟的 RPC框架还提供好了“服务自动注册与发现”、”智能负载均衡”、“可视化的服务治理和运维”、“运行期流量调度”等等功能，这些也算是选择 RPC 进行服务注册和发现的一方面原因吧！</p><h4 id="Dubbo基础"><a href="#Dubbo基础" class="headerlink" title="Dubbo基础"></a>Dubbo基础</h4><p>Dubbo 是一款国产的 RPC 框架，由阿里开源。<br>Apache Dubbo 是一款高性能、轻量级的开源 Java RPC 框架。</p><p>根据 Dubbo 官方文档的介绍，Dubbo 提供了六大核心能力面向接口代理的高性能RPC调用。智能容错和负载均衡。服务自动注册和发现。高度可扩展能力。运行期流量调度，可视化的服务治理与运维。</p><h5 id="为什么要用-Dubbo"><a href="#为什么要用-Dubbo" class="headerlink" title="为什么要用 Dubbo?"></a>为什么要用 Dubbo?</h5><p>Dubbo 帮助我们解决的问题：</p><ol><li><strong>负载均衡</strong> ： 同一个服务部署在不同的机器时该调用哪一台机器上的服务。</li><li><strong>服务调用链路生成</strong> ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li><li><strong>服务访问压力以及时长统计、资源调度和治理</strong> ：基于访问压力实时管理集群容量，提高集群利用率。</li></ol><p><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86.png"></p><h5 id="Dubbo-架构"><a href="#Dubbo-架构" class="headerlink" title="Dubbo 架构"></a>Dubbo 架构</h5><p><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo%E6%9E%B6%E6%9E%84.png"></p><p>上述节点简单介绍以及他们之间的关系：</p><ul><li>Container： 服务运行容器，负责加载、运行服务提供者。必须。</li><li>Provider： 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。</li><li>Consumer： 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。</li><li>Registry： 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。</li><li>Monitor： 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。</li></ul><h5 id="Dubbo-中的-Invoker-概念"><a href="#Dubbo-中的-Invoker-概念" class="headerlink" title="Dubbo 中的 Invoker 概念"></a>Dubbo 中的 Invoker 概念</h5><p>Invoker 是 Dubbo 领域模型中非常重要的一个概念，你如果阅读过 Dubbo 源码的话，你会无数次看到这玩意。就比如下面我要说的负载均衡这块的源码中就有大量 Invoker 的身影。</p><p>简单来说，Invoker 就是 Dubbo 对远程调用的抽象。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo-invoker.png"></p><p>按照 Dubbo 官方的话来说，Invoker 分为</p><ul><li>服务提供 Invoker</li><li>服务消费 Invoker</li></ul><p>假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节吧！我们屏蔽掉的这些细节就依赖对应的 Invoker 实现， Invoker 实现了真正的远程服务调用。</p><h5 id="Dubbo-的工作原理"><a href="#Dubbo-的工作原理" class="headerlink" title="Dubbo 的工作原理"></a>Dubbo 的工作原理</h5><p>下图是 Dubbo 的整体设计，从下至上分为十层，各层均为单向依赖。</p><p>左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><ul><li><strong>config 配置层</strong>：Dubbo相关的配置。支持代码配置，同时也支持基于 Spring 来做配置，以 ServiceConfig, ReferenceConfig 为中心</li><li><strong>proxy 服务代理层</strong>：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 ServiceProxy 为中心。</li><li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现。</li><li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心。</li><li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心。</li><li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 Invocation, Result 为中心。</li><li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 Request, Response 为中心。</li><li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心。</li><li><strong>serialize 数据序列化层</strong> ：对需要在网络传输的数据进行序列化。</li></ul><h5 id="Dubbo-的-SPI-机制了解么？-如何扩展-Dubbo-中的默认实现？"><a href="#Dubbo-的-SPI-机制了解么？-如何扩展-Dubbo-中的默认实现？" class="headerlink" title="Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？"></a>Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？</h5><p>SPI（Service Provider Interface） 机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能（比如负载均衡策略）的实现。</p><p>SPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。<br>Java 本身就提供了 SPI 机制的实现。不过，Dubbo 没有直接用，而是对 Java原生的 SPI机制进行了增强，以便更好满足自己的需求。</p><p><strong>那我们如何扩展 Dubbo 中的默认实现呢？</strong></p><p>比如说我们想要实现自己的负载均衡策略，我们创建对应的实现类 XxxLoadBalance 实现 LoadBalance 接口或者 AbstractLoadBalance 类。</p><h5 id="Dubbo-的微内核架构了解吗？"><a href="#Dubbo-的微内核架构了解吗？" class="headerlink" title="Dubbo 的微内核架构了解吗？"></a>Dubbo 的微内核架构了解吗？</h5><p>Dubbo 采用 微内核（Microkernel） + 插件（Plugin） 模式，简单来说就是微内核架构。微内核只负责组装插件。</p><blockquote><p>微内核架构模式（有时被称为插件架构模式）是实现基于产品应用程序的一种自然模式。基于产品的应用程序是已经打包好并且拥有不同版本，可作为第三方插件下载的。然后，很多公司也在开发、发布自己内部商业应用像有版本号、说明及可加载插件式的应用软件（这也是这种模式的特征）。微内核系统可让用户添加额外的应用如插件，到核心应用，继而提供了可扩展性和功能分离的用法。</p></blockquote><p>微内核架构包含两类组件：<strong>核心系统（core system）</strong> 和 <strong>插件模块（plug-in modules）</strong>。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo-%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84.png"></p><p>核心系统提供系统所需核心能力，插件模块可以扩展系统的功能。因此， 基于微内核架构的系统，非常易于扩展功能。</p><p>我们常见的一些IDE，都可以看作是基于微内核架构设计的。绝大多数 IDE比如IDEA、VSCode都提供了插件来丰富自己的功能。</p><p>正是因为Dubbo基于微内核架构，才使得我们可以随心所欲替换Dubbo的功能点。比如你觉得Dubbo 的序列化模块实现的不满足自己要求，没关系啊！你自己实现一个序列化模块就好了啊！通常情况下，微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。Dubbo 不想依赖 Spring 等 IoC 容器，也不想自己造一个小的 IoC 容器（过度设计），因此采用了一种最简单的 Factory 方式管理插件 ：JDK 标准的 SPI 扩展机制 （java.util.ServiceLoader）。</p><p>关于Dubbo架构的一些小说明：</p><ol><li><p>服务提供者宕机后，注册中心会做什么？<br>会注册中心会立即推送事件通知消费者。</p></li><li><p>注册中心和监控中心都宕机的话，服务都会挂掉吗？<br>不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</p></li></ol><h5 id="Dubbo-的负载均衡策略"><a href="#Dubbo-的负载均衡策略" class="headerlink" title="Dubbo 的负载均衡策略"></a>Dubbo 的负载均衡策略</h5><blockquote><p>负载均衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件。</p></blockquote><p><strong>Dubbo 提供的负载均衡策略有哪些？</strong></p><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 random 随机调用。我们还可以自行扩展负载均衡策略（参考Dubbo SPI机制）。</p><p>在 Dubbo 中，所有负载均衡实现类均继承自 AbstractLoadBalance，该类实现了 LoadBalance 接口，并封装了一些公共的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateWarmupWeight</span><span class="params">(<span class="type">int</span> uptime, <span class="type">int</span> warmup, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h6 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h6><p>根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。</p><p>RandomLoadBalance 具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。我们把这些权重值分布在坐标区间会得到：S1-&gt;[0, 7) ，S2-&gt;[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo-RandomLoadBalance.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;random&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> invokers.size();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameWeight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[length]; </span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 下面这个for循环的主要作用就是计算所有该服务的提供者的权重之和 totalWeight（），</span></span><br><span class="line">        <span class="comment">// 除此之外，还会检测每个服务提供者的权重是否相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> getWeight(invokers.get(i), invocation);</span><br><span class="line">            totalWeight += weight;</span><br><span class="line">            weights[i] = totalWeight;</span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; totalWeight != weight * (i + <span class="number">1</span>)) &#123;</span><br><span class="line">                sameWeight = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 随机生成一个 [0, totalWeight) 区间内的数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 判断会落在哪个服务提供者的区间</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; weights[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h6><p>LeastActiveLoadBalance 直译过来就是最小活跃数负载均衡。</p><p>初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。</p><p>因此，Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。</p><p>如果有多个服务提供者的活跃数相等怎么办？</p><p>很简单，那就再走一遍 RandomLoadBalance 。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> LeastActiveLoadBalance extends AbstractLoadBalance &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static final String <span class="type">NAME</span> = &quot;leastactive&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected &lt;T&gt; <span class="keyword">Invoker</span>&lt;T&gt; doSelect(List&lt;<span class="keyword">Invoker</span>&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        <span class="type">int</span> length = invokers.size();</span><br><span class="line">        <span class="type">int</span> leastActive = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] leastIndexes = <span class="built_in">new</span> <span class="type">int</span>[length];</span><br><span class="line">        <span class="type">int</span>[] weights = <span class="built_in">new</span> <span class="type">int</span>[length];</span><br><span class="line">        <span class="type">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        // 这个 <span class="keyword">for</span> 循环的主要作用是遍历 invokers 列表，找出活跃数最小的 <span class="keyword">Invoker</span></span><br><span class="line">        // 如果有多个 <span class="keyword">Invoker</span> 具有相同的最小活跃数，还会记录下这些 <span class="keyword">Invoker</span> 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">Invoker</span>&lt;T&gt; <span class="keyword">invoker</span> = invokers.<span class="keyword">get</span>(i);</span><br><span class="line">            // 获取 <span class="keyword">invoker</span> 对应的活跃(active)数</span><br><span class="line">            <span class="type">int</span> active = RpcStatus.getStatus(<span class="keyword">invoker</span>.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            <span class="type">int</span> afterWarmup = getWeight(<span class="keyword">invoker</span>, invocation);</span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line">            <span class="keyword">if</span> (leastActive == <span class="number">-1</span> || active &lt; leastActive) &#123;</span><br><span class="line">                leastActive = active;</span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line">                leastIndexes[leastCount++] = i;</span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       // 如果只有一个 <span class="keyword">Invoker</span> 具有最小的活跃数，此时直接返回该 <span class="keyword">Invoker</span> 即可</span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.<span class="keyword">get</span>(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果有多个 <span class="keyword">Invoker</span> 具有相同的最小活跃数，但它们之间的权重不同</span><br><span class="line">        // 这里的处理方式就和  RandomLoadBalance 一致了</span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> offsetWeight = ThreadLocalRandom.<span class="keyword">current</span>().nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="type">int</span> leastIndex = leastIndexes[i];</span><br><span class="line">                offsetWeight -= weights[leastIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.<span class="keyword">get</span>(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invokers.<span class="keyword">get</span>(leastIndexes[ThreadLocalRandom.<span class="keyword">current</span>().nextInt(leastCount)]);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>活跃数是通过 RpcStatus 中的一个 ConcurrentMap 保存的，根据 URL 以及服务提供者被调用的方法的名称，我们便可以获取到对应的活跃数。也就是说服务提供者中的每一个方法的活跃数都是互相独立的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcStatus</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> ConcurrentMap&lt;<span class="type">String</span>, ConcurrentMap&lt;<span class="type">String</span>, RpcStatus&gt;&gt; METHOD_STATISTICS =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="type">String</span>, ConcurrentMap&lt;<span class="type">String</span>, RpcStatus&gt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="type">static</span> RpcStatus <span class="title">getStatus</span><span class="params">(URL url, <span class="type">String</span> methodName)</span> </span>&#123;</span><br><span class="line">        <span class="type">String</span> uri = url.<span class="built_in">toIdentityString</span>();</span><br><span class="line">        ConcurrentMap&lt;<span class="type">String</span>, RpcStatus&gt; map = METHOD_STATISTICS.<span class="built_in">computeIfAbsent</span>(uri, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> map.<span class="built_in">computeIfAbsent</span>(methodName, k -&gt; <span class="keyword">new</span> <span class="built_in">RpcStatus</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">getActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> active.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h6><p>ConsistentHashLoadBalance 小伙伴们应该也不会陌生，在分库分表、各种集群中就经常使用这个负载均衡策略。</p><p>ConsistentHashLoadBalance 即一致性Hash负载均衡策略。 ConsistentHashLoadBalance 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo-ConsistentHashLoadBalance.png"></p><p>另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo-ConsistentHashLoadBalance-1.png"></p><h6 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h6><p>加权轮询负载均衡。</p><p>轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。如果我们有 10 次请求，那么 7 次会被 S1处理，3次被 S2处理。</p><p>Dubbo 中的 RoundRobinLoadBalance 的代码实现被修改重建了好几次，Dubbo-2.6.5 版本的 RoundRobinLoadBalance 为平滑加权轮询算法。</p><h5 id="Dubbo序列化协议"><a href="#Dubbo序列化协议" class="headerlink" title="Dubbo序列化协议"></a>Dubbo序列化协议</h5><p>Dubbo 支持多种序列化方式：JDK自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf等等。Dubbo 默认使用的序列化方式是 hession2。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE.png"></p><h6 id="谈谈你对这些序列化协议了解？"><a href="#谈谈你对这些序列化协议了解？" class="headerlink" title="谈谈你对这些序列化协议了解？"></a>谈谈你对这些序列化协议了解？</h6><p>一般我们不会直接使用 JDK 自带的序列化方式。主要原因有两个：</p><ol><li>不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li>性能差 ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li></ol><p>JSON 序列化由于性能问题，我们一般也不会考虑使用。像 Protostuff，ProtoBuf、hessian2这些都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p><p>Kryo和FST这两种序列化方式是 Dubbo 后来才引入的，性能非常好。不过，这两者都是专门针对 Java 语言的。Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo-kryo.png"><br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Dubbo-kryo-%E5%B9%B3%E5%9D%87%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4.png"></p><h2 id="分布式网关"><a href="#分布式网关" class="headerlink" title="分布式网关"></a>分布式网关</h2><p>网关主要用于请求转发、安全认证、协议转换、容灾。</p><h3 id="何为网关？为什么要网关？"><a href="#何为网关？为什么要网关？" class="headerlink" title="何为网关？为什么要网关？"></a>何为网关？为什么要网关？</h3><p><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E5%85%B3.png"></p><p>微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。<br>综上：<strong>一般情况下，网关都会提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、容灾、日志、监控这些功能</strong>。<br>上面介绍了这么多功能，实际上，网关主要做了一件事情：<strong>请求过滤</strong> 。</p><h3 id="有哪些常见的网关系统？"><a href="#有哪些常见的网关系统？" class="headerlink" title="有哪些常见的网关系统？"></a>有哪些常见的网关系统？</h3><h4 id="Netflix-Zuul"><a href="#Netflix-Zuul" class="headerlink" title="Netflix Zuul"></a>Netflix Zuul</h4><p>Zuul 是 Netflix 开发的一款提供动态路由、监控、弹性、安全的网关服务。<br>Zuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/NetflixZuul.png"></p><p>我们可以自定义过滤器来处理请求，并且，Zuul 生态本身就有很多现成的过滤器供我们使用。就比如限流可以直接用国外朋友写的 spring-cloud-zuul-ratelimit (这里只是举例说明，一般是配合 hystrix 来做限流)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.marcosbarbero.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-zuul-ratelimit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Zuul 1.x 基于同步 IO，性能较差。Zuul 2.x 基于 Netty 实现了异步 IO，性能得到了大幅改进。</p><h4 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h4><p>SpringCloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 ** Zuul ** 。准确点来说，应该是 Zuul 1.x。SpringCloud Gateway 起步要比 Zuul 2.x 更早。</p><p>为了提升网关的性能，SpringCloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现异步 IO。</p><p>Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。<br>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。</p><h4 id="Kong"><a href="#Kong" class="headerlink" title="Kong"></a>Kong</h4><p>Kong 是一款基于 OpenResty 的高性能、云原生、可扩展的网关系统。</p><blockquote><p>OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p></blockquote><p>Kong 提供了插件机制来扩展其功能。比如、在服务上启用 Zipkin 插件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X POST http:<span class="string">//kong</span><span class="function">:8001</span>/services/&#123;service&#125;<span class="string">/plugins</span> \</span><br><span class="line">    <span class="params">--data</span> <span class="string">&quot;name=zipkin&quot;</span>  \</span><br><span class="line">    <span class="params">--data</span> <span class="string">&quot;config.http_endpoint=http://your.zipkin.collector:9411/api/v2/spans&quot;</span> \</span><br><span class="line">    <span class="params">--data</span> <span class="string">&quot;config.sample_ratio=0.001&quot;</span></span><br></pre></td></tr></table></figure><h4 id="APISIX"><a href="#APISIX" class="headerlink" title="APISIX"></a>APISIX</h4><p>APISIX 是一款基于 Nginx 和 etcd 的高性能、云原生、可扩展的网关系统。</p><blockquote><p>etcd是使用 Go 语言开发的一个开源的、高可用的分布式 key-value 存储系统，使用 Raft 协议做分布式共识。</p></blockquote><p>与传统 API 网关相比，APISIX 具有动态路由和插件热加载，特别适合微服务系统下的 API 管理。并且，APISIX 与 SkyWalking（分布式链路追踪系统）、Zipkin（分布式链路追踪系统）、Prometheus（监控系统） 等 DevOps 生态工具对接都十分方便。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/APISIX.png"></p><p>作为 NGINX 和 Kong 的替代项目，APISIX 目前已经是 Apache 顶级开源项目，并且是最快毕业的国产开源项目。国内目前已经有很多知名企业（比如金山、有赞、爱奇艺、腾讯、贝壳）使用 APISIX 处理核心的业务流量。</p><p>根据官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。</p><h4 id="Shenyu"><a href="#Shenyu" class="headerlink" title="Shenyu"></a>Shenyu</h4><p>Shenyu 是一款基于 WebFlux 的可扩展、高性能、响应式网关，Apache 顶级开源项目。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/shenyu.png"></p><p>Shenyu 通过插件扩展功能，插件是 ShenYu 的灵魂，并且插件也是可扩展和热插拔的。不同的插件实现不同的功能。Shenyu 自带了诸如限流、熔断、转发 、重写、重定向、和路由监控等插件。</p><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。比如数据量太大之后，往往需要对数据进行分库分表，分库分表后需要有一个唯一 ID 来标识一条数据或消息，数据库的自增 ID 显然不能满足需求。</p><p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念，主要为不同的数据节点生成全局唯一主键。</p><h3 id="分布式-ID-需要满足的要求"><a href="#分布式-ID-需要满足的要求" class="headerlink" title="分布式 ID 需要满足的要求"></a>分布式 ID 需要满足的要求</h3><p><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8FID%E8%A6%81%E6%B1%82.png"></p><p>分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。一个最基本的分布式 ID 需要满足下面这些要求：</p><ul><li><strong>全局唯一</strong> ：ID 的全局唯一性肯定是首先要满足的！</li><li><strong>高性能</strong> ： 分布式 ID 的生成速度要快，对本地资源消耗要小。</li><li><strong>高可用</strong> ：生成分布式 ID 的服务要保证可用性无限接近于 100%。</li><li><strong>方便易用</strong> ：拿来即用，使用方便，快速接入！</li></ul><p>除了这些之外，一个比较好的分布式 ID 还应保证：</p><ul><li><strong>安全</strong> ：ID 中不包含敏感信息。</li><li><strong>有序递增</strong> ：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li><li><strong>有具体的业务含义</strong> ：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。</li><li><strong>独立部署</strong> ：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。</li></ul><h3 id="分布式-ID-常见解决方案"><a href="#分布式-ID-常见解决方案" class="headerlink" title="分布式 ID 常见解决方案"></a>分布式 ID 常见解决方案</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><h5 id="数据库主键自增"><a href="#数据库主键自增" class="headerlink" title="数据库主键自增"></a>数据库主键自增</h5><p>这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E.png"></p><p>以 MySQL 举例，我们通过下面的方式即可。</p><p>1.创建一个数据库表。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLE <span class="symbol">`sequence_id`</span> ( </span><br><span class="line"><span class="symbol">`id`</span> bigint(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT, </span><br><span class="line"><span class="symbol">`stub`</span> char(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;&#x27;</span>, </span><br><span class="line"><span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`id`</span>), </span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="symbol">`stub`</span> (<span class="symbol">`stub`</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><p>stub 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 stub 字段创建了唯一索引，保证其唯一性。</p><p>2、通过 replace into 来插入数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>; </span><br><span class="line">REPLACE <span class="keyword">INTO</span> sequence_id (stub) <span class="keyword">VALUES</span> (<span class="string">&#x27;stub&#x27;</span>); </span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID(); </span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>插入数据这里，我们没有使用 insert into 而是使用 replace into 来插入数据，具体步骤是这样的：</p><ol><li>尝试把数据插入到表中。</li><li>如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。</li></ol><p>这种方式的优缺点也比较明显：</p><ul><li><strong>优点</strong> ：实现起来比较简单、ID 有序递增、存储消耗空间小</li><li><strong>缺点</strong> ： 支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）</li></ul><h5 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h5><p>数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。<br>如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 基于数据库的号段模式来生成分布式 ID。<br>数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的Tinyid 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。</p><p>以 MySQL 举例，我们通过下面的方式即可。</p><p>1.创建一个数据库表。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sequence_id_generator` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `current_max_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;当前最大id&#x27;</span>,</span><br><span class="line">  `step` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;号段的长度&#x27;</span>,</span><br><span class="line">  `<span class="keyword">version</span>` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;版本号&#x27;</span>,</span><br><span class="line">  `biz_type`    <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;业务类型&#x27;</span>,</span><br><span class="line">   <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE=InnoDB <span class="keyword">DEFAULT</span> CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><p>current_max_id 字段和step字段主要用于获取批量 ID，获取的批量 id 为： current_max_id ~ current_max_id+step。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%B7%E6%AE%B5.png"><br>version 字段主要用于解决并发问题（乐观锁),biz_type 主要用于表示业余类型。</p><p>2.先插入一行数据。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `sequence_id_generator` (`id`, `current_max_id`, `step`, `version`, `biz_type`)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">101</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>3.通过 SELECT 获取指定业务下的批量唯一 ID</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = <span class="number">101</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">id</span>    current_max_id    step    version    biz_type</span><br><span class="line"><span class="attribute">1</span>               <span class="number">0</span>                  <span class="number">100</span>          <span class="number">1</span>            <span class="number">101</span></span><br></pre></td></tr></table></figure><p>4.不够用的话，更新之后重新 SELECT 即可。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE sequence_id_generator SET current_max_id = <span class="number">0</span>+<span class="number">100</span>, version=version+<span class="number">1</span> WHERE version = <span class="number">0</span>  <span class="literal">AND</span> `biz_type` = <span class="number">101</span></span><br><span class="line">SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = <span class="number">101</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">id</span>      current_max_id      step        version     biz_type</span><br><span class="line"><span class="attribute">1</span>                <span class="number">100</span>                 <span class="number">100</span>             <span class="number">1</span>              <span class="number">101</span></span><br></pre></td></tr></table></figure><p>号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。相比于数据库主键自增的方式，数据库的号段模式对于数据库的访问次数更少，数据库压力更小。另外，为了避免单点问题，你可以从使用主从模式来提高可用性。由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。<br><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。</p><p>数据库号段模式的优缺点:</p><ul><li><strong>优点</strong> ：ID 有序递增、存储消耗空间小</li><li><strong>缺点</strong> ：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）</li></ul><h5 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h5><p><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/NoSQL.png"></p><p>一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 incr 命令即可实现对 id 原子顺序递增。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; set sequence_id_biz_type <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; incr sequence_id_biz_type</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; get sequence_id_biz_type</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>为了提高可用性和并发，我们可以使用 Redis Cluser。Redis Cluser 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。除了 Redis Cluser 之外，你也可以使用开源的 Redis 集群方案Codis （大规模集群比如上百个节点的时候比较推荐）。</p><p>除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式：快照（snapshotting，RDB）、只追加文件（append-only file, AOF）。 并且，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。</p><p><strong>Redis 方案的优缺点：</strong></p><ul><li><strong>优点</strong> ： 性能不错并且生成的 ID 是有序递增的</li><li><strong>缺点</strong> ： 和数据库主键自增方案的缺点类似</li></ul><p>除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8FID-mongoDB.png"></p><p>MongoDB ObjectId 一共需要 12 个字节存储：</p><ul><li>0~3：时间戳</li><li>3~6： 代表机器 ID</li><li>7~8：机器进程 ID</li><li>9~11 ：自增值</li></ul><p>MongoDB 方案的优缺点：</p><ul><li><strong>优点</strong> ： 性能不错并且生成的 ID 是有序递增的</li><li><strong>缺点</strong> ： 需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID） 、有安全性问题（ID 生成有规律性）</li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h5 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h5><p>UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">UUID</span>.</span></span>random<span class="constructor">UUID()</span></span><br></pre></td></tr></table></figure><p>RFC 4122 中关于 UUID 的示例是这样的：<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/UUID.png"></p><p>我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。5 种不同的 Version(版本)值分别对应的含义（参考维基百科对于 UUID 的介绍）：</p><ul><li>版本 1 : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；</li><li>版本 2 : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；</li><li>版本 3、版本 5 : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；</li><li>版本 4 : UUID 使用随机性或伪随机性生成。</li></ul><p>从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。</p><p>虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：</p><ul><li>数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。</li><li>UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。</li></ul><p>最后，我们再简单分析一下 UUID 的优缺点 （面试的时候可能会被问到的哦！） :</p><ul><li><strong>优点</strong> ：生成速度比较快、简单易用</li><li><strong>缺点</strong> ： 存储消耗空间大（32 个字符串，128 位） 、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）</li></ul><h5 id="Snowflake-雪花算法"><a href="#Snowflake-雪花算法" class="headerlink" title="Snowflake(雪花算法)"></a>Snowflake(雪花算法)</h5><p>Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：</p><ul><li>第 0 位： 符号位（标识正负），始终为 0，没有用，不用管。</li><li>第 1~41 位 ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</li><li>第 42~52 位 ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。</li><li>第 53~64 位 ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E9%9B%AA%E8%8A%B1.png"></li></ul><p>如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。<br>另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。我们再来看看 Snowflake 算法的优缺点 ：</p><ul><li><strong>优点</strong> ：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）</li><li><strong>缺点</strong> ：需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。</li></ul><h4 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h4><h5 id="UidGenerator-百度"><a href="#UidGenerator-百度" class="headerlink" title="UidGenerator(百度)"></a>UidGenerator(百度)</h5><p>UidGenerator 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。<br>不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E7%99%BE%E5%BA%A6.png"></p><p>可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。UidGenerator 官方文档中的介绍如下：<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/uidgene.png"></p><p>自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 <a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">UidGenerator 的官方介绍</a>。</p><h5 id="Leaf-美团"><a href="#Leaf-美团" class="headerlink" title="Leaf(美团)"></a>Leaf(美团)</h5><p>Leaf 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话： “There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！</p><p>Leaf 提供了 号段模式 和 Snowflake(雪花算法) 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。<br>Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：《Leaf——美团点评分布式 ID 生成系统》）。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/leaf.png"><br>根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。</p><h5 id="Tinyid-滴滴"><a href="#Tinyid-滴滴" class="headerlink" title="Tinyid(滴滴)"></a>Tinyid(滴滴)</h5><p>Tinyid 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。数据库号段模式的原理我们在上面已经介绍过了。Tinyid 有哪些亮点呢？为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:《Tinyid 原理介绍》）<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/tiny.png"></p><p>在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。<br>这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：</p><ul><li>获取新号段的情况下，程序获取唯一 ID 的速度比较慢。</li><li>需要保证 DB 高可用，这个是比较麻烦且耗费资源的。</li></ul><p>除此之外，HTTP 调用也存在网络开销。Tinyid 的原理比较简单，其架构如下图所示：<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/tiny2.png"></p><p>相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：</p><ul><li>双号段缓存 ：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。</li><li>增加多 db 支持 ：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。</li><li>增加 tinyid-client ：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。</li></ul><h3 id="分布式-ID-生成方案总结"><a href="#分布式-ID-生成方案总结" class="headerlink" title="分布式 ID 生成方案总结"></a>分布式 ID 生成方案总结</h3><p>除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一 ID。没有银弹，一定要结合实际项目来选择最适合自己的方案。</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。<br>简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p><h2 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h2><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><h4 id="ZooKeeper-介绍"><a href="#ZooKeeper-介绍" class="headerlink" title="ZooKeeper 介绍"></a>ZooKeeper 介绍</h4><p>ZooKeeper 是一个开源的分布式协调服务，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><blockquote><p><strong>原语</strong>： 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</p></blockquote><p>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。<br>另外，ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。</p><h5 id="ZooKeeper-特点"><a href="#ZooKeeper-特点" class="headerlink" title="ZooKeeper 特点"></a>ZooKeeper 特点</h5><ul><li><strong>顺序一致性</strong>： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li><li><strong>原子性</strong>： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li><li><strong>单一系统映像</strong> ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性</strong>： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li></ul><h5 id="ZooKeeper-典型应用场景"><a href="#ZooKeeper-典型应用场景" class="headerlink" title="ZooKeeper 典型应用场景"></a>ZooKeeper 典型应用场景</h5><p>ZooKeeper 概览中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。下面选 3 个典型的应用场景来专门说说：</p><ol><li>分布式锁 ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。</li><li>命名服务 ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID</li><li>数据发布/订阅 ：通过 Watcher 机制 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。</li></ol><p>实际上，这些功能的实现基本都得益于 ZooKeeper 可以保存数据的功能，但是 ZooKeeper 不适合保存大量数据，这一点需要注意。</p><h4 id="ZooKeeper-重要概念解读"><a href="#ZooKeeper-重要概念解读" class="headerlink" title="ZooKeeper 重要概念解读"></a>ZooKeeper 重要概念解读</h4><h5 id="Data-model（数据模型）"><a href="#Data-model（数据模型）" class="headerlink" title="Data model（数据模型）"></a>Data model（数据模型）</h5><p>ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。</p><p>强调一句：<strong>ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M。</strong></p><p>从下图可以更直观地看出：ZooKeeper 节点路径标识方式和 Unix 文件系统路径非常相似，都是由一系列使用斜杠”/“进行分割的路径表示，开发人员可以向这个节点中写入数据，也可以在节点下面创建子节点。这些操作我们后面都会介绍到。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ZooKeeper%E8%8A%82%E7%82%B9.png"></p><h5 id="znode（数据节点）"><a href="#znode（数据节点）" class="headerlink" title="znode（数据节点）"></a>znode（数据节点）</h5><p>介绍了 ZooKeeper 树形数据模型之后，我们知道每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。你要存放的数据就放在上面，是你使用 ZooKeeper 过程中经常需要接触到的一个概念。</p><h6 id="znode-4-种类型"><a href="#znode-4-种类型" class="headerlink" title="znode 4 种类型"></a>znode 4 种类型</h6><p>我们通常是将 znode 分为 4 大类：</p><ul><li>持久（PERSISTENT）节点 ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li><li>临时（EPHEMERAL）节点 ：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。</li><li>持久顺序（PERSISTENT_SEQUENTIAL）节点 ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001 、/node1/app0000000002 。</li><li>临时顺序（EPHEMERAL_SEQUENTIAL）节点 ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><h6 id="znode-数据结构"><a href="#znode-数据结构" class="headerlink" title="znode 数据结构"></a>znode 数据结构</h6><p>每个 znode 由 2 部分组成:</p><ul><li>stat ：状态信息</li><li>data ： 节点存放的数据的具体内容</li></ul><p>如下所示，我通过 get 命令来获取 根目录下的 dubbo 节点的内容。（get 命令在下面会介绍到）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[zk: 127.0.0.1:2181(CONNECTED) 6] get /dubbo</span></span><br><span class="line"><span class="comment"># 该数据节点关联的数据内容为空</span></span><br><span class="line">null</span><br><span class="line"><span class="comment"># 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出</span></span><br><span class="line">cZxid = 0x2</span><br><span class="line">ctime = Tue Nov 27 11:05:34 CST 2018</span><br><span class="line">mZxid = 0x2</span><br><span class="line">mtime = Tue Nov 27 11:05:34 CST 2018</span><br><span class="line">pZxid = 0x3</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure><p>Stat 类中包含了一个数据节点的所有状态信息的字段，包括事务 ID-cZxid、节点创建时间-ctime 和子节点个数-numChildren 等等。</p><p>下面我们来看一下每个 znode 状态信息究竟代表的是什么吧！</p><table><thead><tr><th>znode 状态信息</th><th>解释</th></tr></thead><tbody><tr><td>cZxid</td><td>create ZXID，即该数据节点被创建时的事务 id</td></tr><tr><td>ctime</td><td>create time，即该节点的创建时间</td></tr><tr><td>mZxid</td><td>modified ZXID，即该节点最终一次更新时的事务 id</td></tr><tr><td>mtime</td><td>modified time，即该节点最后一次的更新时间</td></tr><tr><td>pZxid</td><td>该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新</td></tr><tr><td>cversion</td><td>子节点版本号，当前节点的子节点每次变化时值增加 1</td></tr><tr><td>dataVersion</td><td>数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1</td></tr><tr><td>aclVersion</td><td>节点的 ACL 版本号，表示该节点 ACL 信息变更次数</td></tr><tr><td>ephemeralOwner</td><td>创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner=0</td></tr><tr><td>dataLength</td><td>数据节点内容长度</td></tr><tr><td>numChildren</td><td>当前节点的子节点个数</td></tr></tbody></table><h5 id="版本（version）"><a href="#版本（version）" class="headerlink" title="版本（version）"></a>版本（version）</h5><p>在前面我们已经提到，对应于每个 znode，ZooKeeper 都会为其维护一个叫作 Stat 的数据结构，Stat 中记录了这个 znode 的三个相关的版本：</p><ul><li>dataVersion ：当前 znode 节点的版本号</li><li>cversion ： 当前 znode 子节点的版本</li><li>aclVersion ： 当前 znode 的 ACL 的版本。</li></ul><h5 id="ACL（权限控制）"><a href="#ACL（权限控制）" class="headerlink" title="ACL（权限控制）"></a>ACL（权限控制）</h5><p>ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。<br>zookeeper 的 acl 通过 [scheme:id:permissions] 来构成权限列表。</p><ol><li>scheme：代表采用的某种权限机制，包括 world、auth、digest、ip、super 几种。</li><li>id：代表允许访问的用户。</li><li>permissions：权限组合字符串，由 cdrwa 组成，其中每个字母代表支持不同权限， 创建权限 create(c)、删除权限 delete(d)、读权限 read(r)、写权限 write(w)、管理权限admin(a)。</li></ol><p>对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：</p><ul><li>CREATE : 能创建子节点</li><li>READ ：能获取节点数据和列出其子节点</li><li>WRITE : 能设置/更新节点数据</li><li>DELETE : 能删除子节点</li><li>ADMIN : 能设置节点 ACL 的权限</li></ul><p>其中尤其需要注意的是，CREATE 和 DELETE 这两种权限都是针对 <strong>子节点</strong> 的权限控制。<br>对于身份认证，提供了以下几种方式：</p><ul><li>world ： 默认方式，所有用户都可无条件访问。</li><li>auth :不使用任何 id，代表任何已认证的用户，表示任何经过身份验证的用户。</li><li>digest :用户名:密码认证方式： username:password 。</li><li>ip : 对指定 ip 进行限制，把权限设置给 IP 地址为 192.168.3.7 后，IP 为 192.168.3.38 已经没有访问权限。</li></ul><h5 id="Watcher（事件监听器）"><a href="#Watcher（事件监听器）" class="headerlink" title="Watcher（事件监听器）"></a>Watcher（事件监听器）</h5><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/watcher.png"></p><h5 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h5><p>Session 可以看作是 ZooKeeper 服务器与客户端的之间的一个 TCP 长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。<br>Session 有一个属性叫做：sessionTimeout ，sessionTimeout 代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。<br>另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID是 ZooKeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p><h4 id="ZooKeeper-集群"><a href="#ZooKeeper-集群" class="headerlink" title="ZooKeeper 集群"></a>ZooKeeper 集群</h4><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。ZooKeeper 官方提供的架构图就是一个 ZooKeeper 集群整体对外提供服务。<br>![](分布式系统/ZooKeeper 集群.png)</p><p>上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 ZAB 协议（ZooKeeper Atomic Broadcast）来保持数据的一致性。<br>最典型集群模式： Master/Slave 模式（主备模式）。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p><h5 id="ZooKeeper-集群角色"><a href="#ZooKeeper-集群角色" class="headerlink" title="ZooKeeper 集群角色"></a>ZooKeeper 集群角色</h5><p>但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。如下图所示<br>![](分布式系统/ZooKeeper 集群角色.png)</p><p>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程 来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和 Observer 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Leader</td><td>为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。</td></tr><tr><td>Follower</td><td>为客户端提供读服务，如果是写服务则转发给 Leader。参与选举过程中的投票。</td></tr><tr><td>Observer</td><td>为客户端提供读服务，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。</td></tr></tbody></table><p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。这个过程大致是这样的：</p><ol><li><strong>Leader election</strong>（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li><li><strong>Discovery</strong>（发现阶段） ：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li><li><strong>Synchronization</strong>（同步阶段） :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。</li><li><strong>Broadcast</strong>（广播阶段） :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li></ol><h5 id="ZooKeeper-集群中的服务器状态"><a href="#ZooKeeper-集群中的服务器状态" class="headerlink" title="ZooKeeper 集群中的服务器状态"></a>ZooKeeper 集群中的服务器状态</h5><ul><li>LOOKING ：寻找 Leader。</li><li>LEADING ：Leader 状态，对应的节点为 Leader。</li><li>FOLLOWING ：Follower 状态，对应的节点为 Follower。</li><li>OBSERVING ：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。</li></ul><h5 id="ZooKeeper-集群为啥最好奇数台？"><a href="#ZooKeeper-集群为啥最好奇数台？" class="headerlink" title="ZooKeeper 集群为啥最好奇数台？"></a>ZooKeeper 集群为啥最好奇数台？</h5><p>ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。假如我们的集群中有 n 台 ZooKeeper 服务器，那么也就是剩下的服务数必须大于 n/2。先说一下结论，2n 和 2n-1 的容忍度是一样的，都是 n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。比如假如我们有 3 台，那么最大允许宕掉 1 台 ZooKeeper 服务器，如果我们有 4 台的的时候也同样只允许宕掉 1 台。 假如我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。综上，何必增加那一个不必要的 ZooKeeper 呢？</p><h5 id="ZooKeeper-选举的过半机制防止脑裂"><a href="#ZooKeeper-选举的过半机制防止脑裂" class="headerlink" title="ZooKeeper 选举的过半机制防止脑裂"></a>ZooKeeper 选举的过半机制防止脑裂</h5><h6 id="何为集群脑裂？"><a href="#何为集群脑裂？" class="headerlink" title="何为集群脑裂？"></a>何为集群脑裂？</h6><p>对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。</p><h6 id="过半机制是如何防止脑裂现象产生的？"><a href="#过半机制是如何防止脑裂现象产生的？" class="headerlink" title="过半机制是如何防止脑裂现象产生的？"></a>过半机制是如何防止脑裂现象产生的？</h6><p>ZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。</p><h4 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h4><p>设计一个分布式系统必定会遇到一个问题—— 因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡 。这就是著名的 CAP 定理。</p><h5 id="一致性协议和算法"><a href="#一致性协议和算法" class="headerlink" title="一致性协议和算法"></a>一致性协议和算法</h5><p>而为了解决数据一致性问题，在科学家和程序员的不断探索中，就出现了很多的一致性协议和算法。比如 2PC（两阶段提交），3PC（三阶段提交），Paxos算法等等。</p><p>这时候请你思考一个问题，同学之间如果采用传纸条的方式去传播消息，那么就会出现一个问题——我咋知道我的小纸条有没有传到我想要传递的那个人手中呢？万一被哪个小家伙给劫持篡改了呢，对吧？<br>这个时候就引申出一个概念—— <strong>拜占庭将军问题</strong> 。它意指 在不可靠信道上试图通过消息传递的方式达到一致性是不可能的， 所以所有的一致性算法的 必要前提 就是安全可靠的消息通道。</p><h6 id="2PC（两阶段提交）"><a href="#2PC（两阶段提交）" class="headerlink" title="2PC（两阶段提交）"></a>2PC（两阶段提交）</h6><p>两阶段提交是一种保证分布式系统数据一致性的协议，现在很多数据库都是采用的两阶段提交协议来完成 分布式事务 的处理。<br>所以我们所需要解决的是在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 原子性问题 。在两阶段提交中，主要涉及到两个角色，分别是协调者和参与者。</p><ul><li>第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 prepare 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 prepare 消息后，他们会开始执行事务（但不提交），并将 Undo 和 Redo 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。</li><li>第二阶段：第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。</li></ul><p>比如这个时候 所有的参与者 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 Commit 请求 ，当参与者收到 Commit 请求的时候会执行前面执行的事务的 提交操作 ，提交完毕之后将给协调者发送提交成功的响应。而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 回滚事务的 rollback 请求，参与者收到之后将会 回滚它在第一阶段所做的事务处理 ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png"></p><p>个人觉得 2PC 实现得还是比较鸡肋的，因为事实上它只解决了各个事务的原子性问题，随之也带来了很多的问题：</p><ul><li>单点故障问题，如果协调者挂了那么整个系统都处于不可用的状态了。</li><li>阻塞问题，即当协调者发送 prepare 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。</li><li>数据不一致问题，比如当第二阶段，协调者只发送了一部分的 commit 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。</li></ul><h6 id="3PC（三阶段提交）"><a href="#3PC（三阶段提交）" class="headerlink" title="3PC（三阶段提交）"></a>3PC（三阶段提交）</h6><p>因为2PC存在的一系列问题，比如单点，容错机制缺陷等等，从而产生了 3PC（三阶段提交）。</p><ul><li>CanCommit阶段：协调者向所有参与者发送 CanCommit 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO </li><li>PreCommit阶段：协调者根据参与者返回的响应来决定是否可以进行下面的 PreCommit 操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送 PreCommit 预提交请求，参与者收到预提交请求后，会进行事务的执行操作，并将 Undo 和 Redo 信息写入事务日志中 ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。如果在第一阶段协调者收到了 任何一个 NO 的信息，或者 在一定时间内 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。</li><li>DoCommit阶段：这个阶段其实和 2PC 的第二阶段差不多，如果协调者收到了所有参与者在 PreCommit 阶段的 YES 响应，那么协调者将会给所有参与者发送 DoCommit 请求，参与者收到 DoCommit 请求后则会进行事务的提交工作，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在 PreCommit 阶段 收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应 ，那么就会进行中断请求的发送，参与者收到中断请求后则会 通过上面记录的回滚日志 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png"></li></ul><blockquote><p>这里是 3PC 在成功的环境下的流程图，你可以看到 3PC 在很多地方进行了<strong>超时中断</strong>的处理，比如协调者在指定时间内为收到全部的确认消息则进行事务中断的处理，这样能 减少同步阻塞的时间 。还有需要注意的是，3PC 在 DoCommit 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交。为什么这么做呢？是因为这个时候我们肯定保证了在第一阶段所有的协调者全部返回了可以执行事务的响应，这个时候我们有理由相信其他系统都能进行事务的执行和提交，所以不管协调者有没有发消息给参与者，进入第三阶段参与者都会进行事务的提交操作。</p></blockquote><p>总之，3PC 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如在 PreCommit 阶段，当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，这就会出现数据不一致性问题。</p><p>所以，要解决一致性问题还需要靠 Paxos 算法</p><h6 id="Paxos-算法"><a href="#Paxos-算法" class="headerlink" title="Paxos 算法"></a>Paxos 算法</h6><p>Paxos 算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一，其解决的问题就是在分布式系统中如何就某个值（决议）达成一致 。<br>在 Paxos 中主要有三个角色，分别为 Proposer提案者、Acceptor表决者、Learner学习者，<br>在具体的实现中，一个进程可能同时充当多种角色。比如一个进程可能既是Proposer又是Acceptor又是Learner。Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？</p><ul><li>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</li><li>Acceptor：只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了。</li><li>Learner：Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。</li></ul><blockquote><p>Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p></blockquote><p>假设不同角色之间可以通过发送消息来进行通信，那么：</p><ul><li>每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个value被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值。</li><li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li></ul><p><strong>推导过程</strong>：</p><p><strong>1.最简单的方案——只有一个Acceptor</strong></p><p>假设只有一个Acceptor（可以有多个Proposer），只要Acceptor接受它收到的第一个提案，则该提案被选定，该提案里的value就是被选定的value。这样就保证只有一个value会被选定。但是，如果这个唯一的Acceptor宕机了，那么整个系统就无法工作了！因此，必须要有多个Acceptor！</p><p><strong>2.多个Acceptor</strong></p><p>那么，如何保证在多个Proposer和多个Acceptor的情况下选定一个value呢？</p><p>如果我们希望即使只有一个Proposer提出了一个value，该value也最终被选定。那么，就得到下面的约束：</p><blockquote><p>P1：一个Acceptor必须接受它收到的第一个提案。</p></blockquote><p>但是，这又会引出另一个问题：如果每个Proposer分别提出不同的value，发给不同的Acceptor。根据P1，Acceptor分别接受自己收到的value，就导致不同的value被选定。出现了不一致。<br>刚刚是因为『一个提案只要被一个Acceptor接受，则该提案的value就被选定了』才导致了出现上面不一致的问题。因此，我们需要加一个规定：</p><blockquote><p>规定：一个提案被选定需要被半数以上的Acceptor接受</p></blockquote><p>这个规定又暗示了：『一个Acceptor必须能够接受不止一个提案！』不然可能导致最终没有value被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个Acceptor的接受。<br>最开始讲的『提案=value』已经不能满足需求了，于是重新设计提案，给每个提案加上一个提案编号，表示提案被提出的顺序。令『提案=提案编号+value』。虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则又会出现不一致。于是有了下面的约束：</p><blockquote><p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p></blockquote><p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p><blockquote><p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p></blockquote><p>只要满足了P2a，就能满足P2。<br>但是，考虑如下的情况：假设总的有5个Acceptor。Proposer2提出[M1,V1]的提案，Acceptor2-5（半数以上）均接受了该提案，于是对于Acceptor2-5和Proposer2来讲，它们都认为V1被选定。Acceptor1刚刚从宕机状态恢复过来（之前Acceptor1没有收到过任何提案），此时Proposer1向Acceptor1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于Acceptor1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,Acceptor1必须接受该提案！同时Acceptor1认为V2被选定。这就出现了两个问题：</p><ul><li>Acceptor1认为V2被选定，Acceptor2~5和Proposer2认为V1被选定。出现了不一致。</li><li>V1被选定了，但是编号更高的被Acceptor1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li></ul><p>所以我们要对P2a约束进行强化！P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p><blockquote><p>P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p></blockquote><p>由P2b可以推出P2a进而推出P2。那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？只要满足P2c即可：</p><blockquote><p>P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：<br>1、S中每个Acceptor都没有接受过编号小于N的提案。<br>2、S中Acceptor接受过的最大编号的提案的value为V。</p></blockquote><p><strong>Proposer生成提案</strong></p><p>为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去『学习』已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个『Prepare请求』实现的。<br>于是我们得到了如下的提案生成算法：</p><ul><li>Proposer选择一个新的提案编号N，然后向某个Acceptor集合（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）。<br>(a) 向Proposer承诺保证不再接受任何编号小于N的提案。<br>(b) 如果Acceptor已经接受过提案，那么就向Proposer响应已经接受过的编号小于N的最大编号的提案。</li></ul><p>我们将该请求称为编号为N的Prepare请求。</p><ul><li>如果Proposer收到了半数以上的Acceptor的响应，那么它就可以生成编号为N，Value为V的提案[N,V]。这里的V是所有的响应中编号最大的提案的Value。如果所有的响应中都没有提案，那 么此时V就可以由Proposer自己选择。生成提案后，Proposer将该提案发送给半数以上的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为Accept请求。（注意：此时接受Accept请求的Acceptor集合不一定是之前响应Prepare请求的Acceptor集合）</li></ul><p><strong>Acceptor接受提案</strong></p><p>Acceptor可以忽略任何请求（包括Prepare请求和Accept请求）而不用担心破坏算法的安全性。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。我们对Acceptor接受提案给出如下约束：</p><blockquote><p>P1a：一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么他就可以接受这个编号为N的提案。</p></blockquote><p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。因此，一个Acceptor只需记住：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号。</p><p>经过上面的推导，我们总结下Paxos算法的流程。</p><p><strong>prepare 阶段</strong></p><ul><li>Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。</li><li>如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/prepare.png"></li></ul><p><strong>accept 阶段</strong></p><ul><li>如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。</li><li>如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/accept.png"></li></ul><p><strong>Learner学习被选定的value</strong></p><p>Learner学习（获取）被选定的value有如下三种方案：<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Learner%E5%AD%A6%E4%B9%A0.png"></p><p><strong>如何保证Paxos算法的活性</strong></p><p>比如说，此时提案者 P1 提出一个方案 M1，完成了 Prepare 阶段的工作，这个时候 acceptor 则批准了 M1，但是此时提案者 P2 同时也提出了一个方案 M2，它也完成了 Prepare 阶段的工作。然后 P1 的方案已经不能在第二阶段被批准了（因为 acceptor 已经批准了比 M1 更大的 M2），所以 P1 自增方案变为 M3 重新进入 Prepare 阶段，然后 acceptor ，又批准了新的 M3 方案，它又不能批准 M2 了，这个时候 M2 又自增进入 Prepare 阶段。。。就这样无休无止的永远提案下去，这就是 paxos 算法的死循环问题。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Paxos%E7%AE%97%E6%B3%95%E7%9A%84%E6%B4%BB%E6%80%A7.png"></p><p>通过选取主Proposer，就可以保证Paxos算法的活性。至此，我们得到一个既能保证安全性，又能保证活性的分布式一致性算法——Paxos算法。</p><h4 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h4><p>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在 ZooKeeper 的官方文档中也指出，ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 Zookeeper 设计的崩溃可恢复的原子消息广播算法。</p><h5 id="ZAB-协议介绍"><a href="#ZAB-协议介绍" class="headerlink" title="ZAB 协议介绍"></a>ZAB 协议介绍</h5><p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><h6 id="ZAB-中的三个角色"><a href="#ZAB-中的三个角色" class="headerlink" title="ZAB 中的三个角色"></a>ZAB 中的三个角色</h6><p>和介绍 Paxos 一样，在介绍 ZAB 协议之前，我们首先来了解一下在 ZAB 中三个主要的角色，Leader 领导者、Follower跟随者、Observer观察者 。</p><ul><li>Leader ：集群中 唯一的写请求处理者 ，能够发起投票（投票也是为了进行写请求）。</li><li>Follower：能够接收客户端的请求，如果是读请求则可以自己处理，如果是写请求则要转发给 Leader 。在选举过程中会参与投票，有选举权和被选举权 。</li><li>Observer ：就是没有选举权和被选举权的 Follower 。</li></ul><h5 id="ZAB-协议两种基本的模式：崩溃恢复和消息广播"><a href="#ZAB-协议两种基本的模式：崩溃恢复和消息广播" class="headerlink" title="ZAB 协议两种基本的模式：崩溃恢复和消息广播"></a>ZAB 协议两种基本的模式：崩溃恢复和消息广播</h5><p>ZAB 协议包括两种基本的模式，分别是分别是消息广播和崩溃恢复。</p><h6 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h6><p>说白了就是 ZAB 协议是如何处理写请求的，上面我们不是说只有 Leader 能处理写请求嘛？那么我们的 Follower 和 Observer 是不是也需要 同步更新数据 呢？总不能数据只在 Leader 中更新了，其他角色都没有得到更新吧？</p><p>第一步肯定需要 Leader 将写请求 广播 出去呀，让 Leader 问问 Followers 是否同意更新，如果超过半数以上的同意那么就进行 Follower 和 Observer 的更新（和 Paxos 一样）。<br><img src="/2023/01/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ZAB-%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD.png"></p><p>这两个 Queue 哪冒出来的？答案是 ZAB 需要让 Follower 和 Observer 保证顺序性 。何为顺序性，比如我现在有一个写请求A，此时 Leader 将请求A广播出去，因为只需要半数同意就行，所以可能这个时候有一个 Follower F1因为网络原因没有收到，而 Leader 又广播了一个请求B，因为网络原因，F1竟然先收到了请求B然后才收到了请求A，这个时候请求处理的顺序不同就会导致数据的不同，从而 产生数据不一致问题 。所以在 Leader 这端，它为每个其他的 zkServer 准备了一个 队列 ，采用先进先出的方式发送消息。由于协议是 通过TCP来进行网络通信的，保证了消息的发送顺序性，接受顺序性也得到了保证。<br>除此之外，在ZAB中还定义了一个全局单调递增的事务ID ZXID ，它是一个64位long型，其中高32位表示 epoch 年代，低32位表示事务id。epoch 是会根据 Leader 的变化而变化的，当一个 Leader 挂了，新的 Leader 上位的时候，年代（epoch）就变了。而低32位可以简单理解为递增的事务id。<br>定义这个的原因也是为了顺序性，每个 proposal 在 Leader 中生成后需要 通过其 ZXID 来进行排序 ，才能得到处理。</p><p>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。 当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p><h6 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h6><p>说到崩溃恢复我们首先要提到 ZAB 中的 Leader 选举算法，当系统出现崩溃影响最大应该是 Leader 的崩溃，因为我们只有一个 Leader ，所以当 Leader 出现问题的时候我们势必需要重新选举 Leader 。<br>Leader 选举可以分为两个不同的阶段，第一个是我们提到的 Leader 宕机需要重新选举，第二则是当 Zookeeper 启动时需要进行系统的 Leader 初始化选举。下面我先来介绍一下 ZAB 是如何进行初始化选举的。</p><p>假设我们集群中有3台机器，那也就意味着我们需要两台以上同意（超过半数）。比如这个时候我们启动了 server1 ，它会首先 投票给自己 ，投票内容为服务器的 myid 和 ZXID ，因为初始化所以 ZXID 都为0，此时 server1 发出的投票为 (1,0)。但此时 server1 的投票仅为1，所以不能作为 Leader ，此时还在选举阶段所以整个集群处于 Looking 状态。接着 server2 启动了，它首先也会将投票选给自己(2,0)，并将投票信息广播出去（server1也会，只是它那时没有其他的服务器了），server1 在收到 server2 的投票信息后会将投票信息与自己的作比较。首先它会比较 ZXID ，ZXID 大的优先为 Leader，如果相同则比较 myid，myid 大的优先作为 Leader。所以此时server1 发现 server2 更适合做 Leader，它就会将自己的投票信息更改为(2,0)然后再广播出去，之后server2 收到之后发现和自己的一样无需做更改，并且自己的 投票已经超过半数 ，则 确定 server2 为 Leader，server1 也会将自己服务器设置为 Following 变为 Follower。整个服务器就从 Looking 变为了正常状态。当 server3 启动发现集群没有处于 Looking 状态时，它会直接以 Follower 的身份加入集群。</p><p>还是前面三个 server 的例子，如果在整个集群运行的过程中 server2 挂了，那么整个集群会如何重新选举 Leader 呢？其实和初始化选举差不多。首先毫无疑问的是剩下的两个 Follower 会将自己的状态 从 Following 变为 Looking 状态 ，然后每个 server 会向初始化投票一样首先给自己投票（这不过这里的 zxid 可能不是0了，这里为了方便随便取个数字）。<br>假设 server1 给自己投票为(1,99)，然后广播给其他 server，server3 首先也会给自己投票(3,95)，然后也广播给其他 server。server1 和 server3 此时会收到彼此的投票信息，和一开始选举一样，他们也会比较自己的投票和收到的投票（zxid 大的优先，如果相同那么就 myid 大的优先）。这个时候 server1 收到了 server3 的投票发现没自己的合适故不变，server3 收到 server1 的投票结果后发现比自己的合适于是更改投票为(1,99)然后广播出去，最后 server1 收到了发现自己的投票已经超过半数就把自己设为 Leader，server3 也随之变为 Follower。</p><blockquote><p>请注意 ZooKeeper 为什么要设置奇数个结点？比如这里我们是三个，挂了一个我们还能正常工作，挂了两个我们就不能正常工作了（已经没有超过半数的节点数了，所以无法进行投票等操作了）。而假设我们现在有四个，挂了一个也能工作，但是挂了两个也不能正常工作了，这是和三个一样的，而三个比四个还少一个，带来的效益是一样的，所以 Zookeeper 推荐奇数个 server 。</p></blockquote><p>崩溃恢复主要就是当集群中有机器挂了，我们整个集群如何保证数据一致性？<br>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ol><li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li><li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li><li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 znode 中存储的数据量较小的进一步原因）。</li><li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地明显，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li><li>ZooKeeper 有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 znode 被创建了，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 ZooKeeper 上。</li><li>ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;理论-amp-算法&quot;&gt;&lt;a href=&quot;#理论-amp-算法&quot; class=&quot;headerlink&quot; title=&quot;理论&amp;amp;算法&quot;&gt;&lt;/a&gt;理论&amp;amp;算法&lt;/h1&gt;&lt;h2 id=&quot;分布式基础&quot;&gt;&lt;a href=&quot;#分布式基础&quot; class=&quot;headerlink&quot; title=&quot;分布式基础&quot;&gt;&lt;/a&gt;分布式基础&lt;/h2&gt;&lt;h3 id=&quot;什么是分布式&quot;&gt;&lt;a href=&quot;#什么是分布式&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式?&quot;&gt;&lt;/a&gt;什么是分布式?&lt;/h3&gt;&lt;p&gt;分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。&lt;/p&gt;
&lt;h3 id=&quot;为什么要分布式&quot;&gt;&lt;a href=&quot;#为什么要分布式&quot; class=&quot;headerlink&quot; title=&quot;为什么要分布式?&quot;&gt;&lt;/a&gt;为什么要分布式?&lt;/h3&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://shenhongwei33.github.io/categories/JAVA/"/>
    
    
    <category term="分布式系统" scheme="https://shenhongwei33.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础</title>
    <link href="https://shenhongwei33.github.io/2023/01/19/JAVA/"/>
    <id>https://shenhongwei33.github.io/2023/01/19/JAVA/</id>
    <published>2023-01-19T13:48:02.000Z</published>
    <updated>2023-01-24T14:36:55.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h2><h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p><h3 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。<br><img src="/2023/01/19/JAVA/Image.png"></p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。<strong>这也解释了我们为什么经常会说 Java 是编译与解释共存的语言</strong> 。</p><blockquote><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote><h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h3><ol><li><p>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</p></li><li><p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</p></li><li><p>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</p></li><li><p>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</p></li></ol><h3 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++的区别"></a>Java 和 C++的区别</h3><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h3><ul><li><p>形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</p></li><li><p>含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</p></li><li><p>占内存大小 ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节)</p></li></ul><p><img src="/2023/01/19/JAVA/%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F.png"></p><h3 id="continue、break、和-return-的区别"><a href="#continue、break、和-return-的区别" class="headerlink" title="continue、break、和 return 的区别"></a>continue、break、和 return 的区别</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ul><li><p>continue ：指跳出当前的这一次循环，继续下一次循环。</p></li><li><p>break ：指跳出整个循环体，继续执行循环下面的语句。</p></li></ul><p>return 用于跳出所在方法，结束该方法的运行。</p><h3 id="Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符"><a href="#Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符" class="headerlink" title="Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符"></a>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符</h3><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。<br>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p><p>常用的通配符为： T，E，K，V，？</p><ul><li><p>？ 表示不确定的 java 类型</p></li><li><p>T (type) 表示具体的一个 java 类型</p></li><li><p>K V (key value) 分别代表 java 键值中的 Key Value</p></li><li><p>E (element) 代表 Element</p></li></ul><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="==和 equals 的区别"></a>==和 equals 的区别</h3><p>对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</p><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p><p>equals() 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。</p><p>equals() 方法存在两种使用情况：类没有覆盖 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。类覆盖了 equals()方法 ：一般我们都覆盖 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</p><h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode()与 equals()"></a>hashCode()与 equals()</h3><p>面试官可能会问你：“你重写过 hashcode 和 equals么，为什么重写 equals 时必须重写 hashCode 方法？”</p><p>1)hashCode()介绍:<br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p>2)为什么要有 hashCode？<br>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>3)为什么重写 equals 时必须重写 hashCode 方法？<br>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><p>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？<br>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode。我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"><a href="#Java-中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？" class="headerlink" title="Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"></a>Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</h3><p>Java 中有 8 种基本数据类型，分别为：</p><ol><li>6 种数字类型 ：byte、short、int、long、float、double</li><li>1 种字符类型：char</li><li>1 种布尔型：boolean</li></ol><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>int</td><td>32</td><td>4</td><td>0</td></tr><tr><td>short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>char</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>float</td><td>32</td><td>4</td><td>0f</td></tr><tr><td>double</td><td>64</td><td>8</td><td>0d</td></tr><tr><td>boolean</td><td>1</td><td></td><td>false</td></tr></tbody></table><p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。包装类型不赋值就是 Null ，而基本类型有默认值且不是 Null。</p><p>另外，这个问题建议还可以先从 JVM 层面来分析。基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</p><p>《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>从字节码中，我们发现装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。因此，</p><ul><li>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</li><li>int n = i 等价于 int n = i.intValue();</li></ul><p>注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p><p>为什么说是几乎所有对象实例呢？ 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p><h3 id="8-种基本类型的包装类和常量池"><a href="#8-种基本类型的包装类和常量池" class="headerlink" title="8 种基本类型的包装类和常量池"></a>8 种基本类型的包装类和常量池</h3><p>Java 基本类型的包装类的大部分都实现了常量池技术（缓存技术）。Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。</p><p>Integer 缓存源码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** *此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。 */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) </span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)]; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Integer</span>(i);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123; </span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> low = <span class="number">-128</span>; </span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> high; </span><br><span class="line">    <span class="type">static</span> <span class="keyword">final</span> Integer cache[]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</strong><br><img src="/2023/01/19/JAVA/equels.png"></p><h3 id="浮点数运算的时候会有精度丢失的风险"><a href="#浮点数运算的时候会有精度丢失的风险" class="headerlink" title="浮点数运算的时候会有精度丢失的风险"></a>浮点数运算的时候会有精度丢失的风险</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">float</span> a = <span class="number">2</span>.<span class="number">0</span>f - <span class="number">1</span>.<span class="number">9</span>f;</span><br><span class="line"><span class="attribute">float</span> b = <span class="number">1</span>.<span class="number">8</span>f - <span class="number">1</span>.<span class="number">7</span>f;</span><br><span class="line"><span class="attribute">System</span>.out.println(a);// <span class="number">0</span>.<span class="number">100000024</span></span><br><span class="line"><span class="attribute">System</span>.out.println(b);// <span class="number">0</span>.<span class="number">099999905</span></span><br><span class="line"><span class="attribute">System</span>.out.println(a == b);// false</span><br></pre></td></tr></table></figure><p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><p>BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。</p><h2 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h2><h3 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h3><p>example 2</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    System.<span class="keyword">out</span>.println(arr[<span class="number">0</span>]); </span><br><span class="line">    change(arr); </span><br><span class="line">    System.<span class="keyword">out</span>.println(arr[<span class="number">0</span>]); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span>(<span class="params"><span class="built_in">int</span>[] array</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0 </span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>解析：</strong><br><img src="/2023/01/19/JAVA/3825204.jpg"></p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</p><p>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p><p>example 3</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-<span class="keyword">generated</span> <span class="keyword">method</span> stub</span><br><span class="line">        Student s1 = <span class="built_in">new</span> Student(&quot;小张&quot;);</span><br><span class="line">        Student s2 = <span class="built_in">new</span> Student(&quot;小李&quot;);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;s1:&quot; + s1.getName());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;s2:&quot; + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> swap(Student x, Student y) &#123;</span><br><span class="line">        Student <span class="keyword">temp</span> = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = <span class="keyword">temp</span>;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;x:&quot; + x.getName());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;y:&quot; + y.getName());</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">x:</span>小李</span><br><span class="line"><span class="symbol">y:</span>小张</span><br><span class="line"><span class="symbol">s1:</span>小张</span><br><span class="line"><span class="symbol">s2:</span>小李</span><br></pre></td></tr></table></figure><p>解析：交换之前：<br><img src="/2023/01/19/JAVA/88729818.jpg"></p><p>交换之后：<br><img src="/2023/01/19/JAVA/34384414.jpg"></p><p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p><p>总结</p><p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。下面再总结一下 Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理<br>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法<br><img src="/2023/01/19/JAVA/desktopjava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg"></p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ul><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写<br>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</li></ul><p><strong>关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</strong></p><h3 id="深拷贝-vs-浅拷贝"><a href="#深拷贝-vs-浅拷贝" class="headerlink" title="深拷贝 vs 浅拷贝"></a>深拷贝 vs 浅拷贝</h3><ul><li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p><img src="/2023/01/19/JAVA/%E6%8B%B7%E8%B4%9D.png"></p><h2 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h2><ul><li>面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</li><li>面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。</li></ul><p><strong>面向过程 ：面向过程性能比面向对象高？</strong><br>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p><h3 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h3><ul><li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3><p>构造方法主要作用是完成对类对象的初始化工作。如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p><h3 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h3><p><strong>特点：</strong></p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h3 id="String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h3><p><strong>可变性</strong></p><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。</p><p><strong>补充：</strong>在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串 private final byte[] value</p><p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是AbstractStringBuilder 实现的，大家可以自行查阅源码。</p><p><strong>线程安全性</strong><br>String 中的对象是不可变的，也就可以理解为常量，线程安全AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h4 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder"></a>字符串拼接用“+” 还是 StringBuilder</h4><p>字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。<br>不过，<strong>在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。</strong></p><h4 id="String-类型的变量和常量做“-”运算"><a href="#String-类型的变量和常量做“-”运算" class="headerlink" title="String 类型的变量和常量做“+”运算"></a>String 类型的变量和常量做“+”运算</h4><p>先来看字符串不加 final 关键字拼接的情况（JDK1.8）：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="built_in">String</span> str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="built_in">String</span> str4 = str1 + str2;</span><br><span class="line"><span class="built_in">String</span> str5 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(str3 == str4);//<span class="literal">false</span></span><br><span class="line">System.<span class="keyword">out</span>.println(str3 == str5);//<span class="literal">true</span></span><br><span class="line">System.<span class="keyword">out</span>.println(str4 == str5);//<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</p><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：<br><img src="/2023/01/19/JAVA/String.png"></p><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。对于 String str3 = “str” + “ing”; 编译器会给你优化成 String str3 = “string”; 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。</li><li>final 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><h3 id="Object-类的常见方法总结"><a href="#Object-类的常见方法总结" class="headerlink" title="Object 类的常见方法总结"></a>Object 类的常见方法总结</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul><li>优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li>缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制，这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。另外，像 Java 中的一大利器 注解 的实现也用到了反射。</p><h3 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h3><p>1.知道具体类的情况下可以使用：<br>通过此方式获取 Class 对象不会进行初始化</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass <span class="operator">=</span> TargetObject.class<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>2.通过 Class.forName()传入类的路径获取：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass1 <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>3.通过对象实例instance.getClass()获取：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TargetObject o <span class="operator">=</span> new TargetObject()<span class="comment">;</span></span><br><span class="line">Class alunbarClass2 <span class="operator">=</span> o.getClass()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>4.通过类加载器xxxClassLoader.loadClass()传入类路径获取:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz <span class="operator">=</span> ClassLoader.loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，<strong>静态块和静态对象不会得到执行</strong></p><h2 id="Java-代理模式详解"><a href="#Java-代理模式详解" class="headerlink" title="Java 代理模式详解"></a>Java 代理模式详解</h2><p>代理模式是一种比较好理解的设计模式。简单来说就是我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</p><p>代理模式有静态代理和动态代理两种实现方式。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类）。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口；</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。<br><strong>从JVM角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的</strong>。说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p><p>就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。</p><h4 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h4><p>在 Java 动态代理机制中InvocationHandler接口和Proxy类是核心。Proxy类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。</p><h4 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h4><p>JDK动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p><p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的AOP模块中：如果目标对象实现了接口，则默认采用JDK动态代理，否则采用CGLIB动态代理。</p><p>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。<br>你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">MethodInterceptor</span> <span class="symbol">extends</span> <span class="symbol">Callback</span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="built_in">int</span>ercept(Object obj, java.lang.<span class="built_in">ref</span>lect.Method method, Object[] args,MethodProxy proxy) throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>obj : 动态生成的代理对象</li><li>method : 被拦截的方法（需要增强的方法）</li><li>args : 方法入参</li><li>proxy : 用于调用原始方法</li></ol><p>你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。</p><p><strong>JDK 动态代理和 CGLIB 动态代理对比</strong>：</p><ol><li>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Annontation （注解） 是Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。</p><p>注解本质是一个继承了Annotation 的特殊接口：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">public <span class="variable">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Override extends Annotation&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。</li></ul><p>JDK 提供了很多内置的注解（比如 @Override 、@Deprecated），同时，我们还可以自定义注解。</p><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><h3 id="何为-SPI"><a href="#何为-SPI" class="headerlink" title="何为 SPI"></a>何为 SPI</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。<br><img src="/2023/01/19/JAVA/Spi.png"></p><h3 id="SPI和API的区别"><a href="#SPI和API的区别" class="headerlink" title="SPI和API的区别"></a>SPI和API的区别</h3><p>一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。<br>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根绝这个规则对这个接口进行实现，从而提供服务。</p><h3 id="SPI-的优缺点"><a href="#SPI-的优缺点" class="headerlink" title="SPI 的优缺点"></a>SPI 的优缺点</h3><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p><ul><li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li><li>当多个 ServiceLoader 同时 load 时，会有并发问题。</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Java 异常类层次结构图</p><p><img src="/2023/01/19/JAVA/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p><img src="/2023/01/19/JAVA/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png"></p><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。Exception 能被程序本身处理(try-catch)， Error 是无法处理的(只能尽量避免)。</p><p>Exception 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li>Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li><li>Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p><strong>受检查异常</strong></p><p>Java 代码在编译过程中，如果受检查异常没有被 catch/throw 处理的话，就没办法通过编译 。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException…。</p><p><strong>不受检查异常</strong></p><p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p>RuntimeException 及其子类都统称为非受检查异常，例如：NullPointerException、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。</p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul><li>try块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li><li>catch块： 用于处理 try 捕获到的异常。</li><li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li></ul><p>在以下 3 种特殊情况下，finally 块不会被执行：</p><ol><li>在 try 或 finally块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行</li><li>程序所在的线程死亡</li><li>关闭 CPU</li></ol><p><strong>注意</strong>： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p><h3 id="使用-try-with-resources-来代替try-catch-finally"><a href="#使用-try-with-resources-来代替try-catch-finally" class="headerlink" title="使用 try-with-resources 来代替try-catch-finally"></a>使用 try-with-resources 来代替try-catch-finally</h3><ol><li>适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象</li><li>关闭资源和 finally 块的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ol><p>面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。</p><p>Java 中类似于InputStream、OutputStream 、Scanner 、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.<span class="keyword">println</span>(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 try-with-resources 语句改造上面的代码:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> <span class="constructor">Scanner(<span class="params">new</span> File(<span class="string">&quot;test.txt&quot;</span>)</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.has<span class="constructor">Next()</span>) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(scanner.next<span class="constructor">Line()</span>);</span><br><span class="line">    &#125;&#125; catch (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.print<span class="constructor">StackTrace()</span>;&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果你还是用try-catch-finally可能会带来很多问题。</p><p>通过使用分号分隔，可以在try-with-resources块中声明多个资源。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> (BufferedInputStream bin = <span class="keyword">new</span> <span class="type">BufferedInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">             BufferedOutputStream bout = <span class="keyword">new</span> <span class="type">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">            int b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bin.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h2><h3 id="何为-I-O"><a href="#何为-I-O" class="headerlink" title="何为 I/O"></a>何为 I/O</h3><p>我们先从计算机结构的角度来解读一下 I/O。根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。<br><img src="/2023/01/19/JAVA/I0.png"></p><p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p><p>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。我们再先从应用程序的角度来解读一下 I/O。</p><p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间</strong>（User space） 和 <strong>内核空间</strong>（Kernel space ） 。像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。并且，用户空间的程序不能直接访问内核空间。当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起<strong>系统调用请求操作系统帮忙完成</strong>。因此，用户进程想要执行 IO 操作的话，必须通过<strong>系统调用</strong>来间接访问内核空间我们在平常开发过程中接触最多的就是<strong>磁盘 IO</strong>（读写文件） 和 <strong>网络 IO</strong>（网络请求和响应）。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><h3 id="常见的-IO-模型"><a href="#常见的-IO-模型" class="headerlink" title="常见的 IO 模型"></a>常见的 IO 模型</h3><p>UNIX 系统下， IO 模型一共有 5 种： 同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。这也是我们经常提到的 5 种 IO 模型。</p><h3 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h3><h4 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h4><p>BIO 属于同步阻塞 IO 模型 。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<br><img src="/2023/01/19/JAVA/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E.png"></p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h4 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h4><p>Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。<br><img src="/2023/01/19/JAVA/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.png"></p><p>同步非阻塞 IO 模型中，应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的</strong>。<br>这个时候，<strong>I/O 多路复用模型</strong>就上场了。<br><img src="/2023/01/19/JAVA/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p><p>IO 多路复用模型中，线程首先发起select调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起read调用。read调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li>select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li>epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。<br><img src="/2023/01/19/JAVA/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p><h4 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h4><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。<br>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。<br><img src="/2023/01/19/JAVA/AIO.png"></p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><h3 id="什么是序列化-什么是反序列化"><a href="#什么是序列化-什么是反序列化" class="headerlink" title="什么是序列化?什么是反序列化?"></a>什么是序列化?什么是反序列化?</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li>序列化： 将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</li></ul><p>实际开发中有哪些用到序列化和反序列化的场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。</li><li>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li></ul><p><img src="/2023/01/19/JAVA/%E5%BA%8F%E5%88%97%E5%8C%96.png"></p><p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。</p><h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p><p><strong>关于 transient 还有几点注意：</strong></p><ul><li>transient 只能修饰变量，不能修饰类和方法。</li><li>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。</li><li>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li></ul><h3 id="常见序列化协议对比"><a href="#常见序列化协议对比" class="headerlink" title="常见序列化协议对比"></a>常见序列化协议对比</h3><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 hessian、kyro、protostuff。下面提到的都是基于二进制的序列化协议，像 JSON 和 XML 这种属于文本类序列化方式。虽然 JSON 和 XML 可读性比较好，但是性能较差，一般不会选择。</p><h4 id="JDK-自带的序列化方式"><a href="#JDK-自带的序列化方式" class="headerlink" title="JDK 自带的序列化方式"></a>JDK 自带的序列化方式</h4><p>JDK 自带的序列化，只需实现 java.io.Serializable接口即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final long serialVersionUID = 1905122041950251207L;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> requestId;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> interfaceName;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> methodName;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Object</span>[] parameters;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Class</span>&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">RpcMessageTypeEnum</span> rpcMessageTypeEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候 serialVersionUID 也会被写入二级制序列，当反序列化时会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的序列化号</p></blockquote><p>我们很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：</p><ul><li>不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li>性能差 ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li></ul><h4 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h4><p>Kryo是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。另外，Kryo已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。</p><p>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。guide-rpc-frameworkopen in new window 就是使用的 kyro 进行序列化，序列化和反序列化相关的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月13日 19:29:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// Object-&gt;byte:将对象序列化为byte数组</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Serialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">             <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// byte-&gt;Object:从byte数组中反序列化出对对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Deserialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><p>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p><blockquote><p>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言</p></blockquote><h4 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h4><p>由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。Github 地址：<a href="https://github.com/protostuff/protostuffopen">https://github.com/protostuff/protostuffopen</a> in new window</p><h4 id="hessian"><a href="#hessian" class="headerlink" title="hessian"></a>hessian</h4><p>hessian 是一个轻量级的,自定义描述的二进制 RPC 协议。hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。<br><img src="/2023/01/19/JAVA/hessian.png"></p><p>dubbo RPC 默认启用的序列化方式是 hessian2 ,但是，Dubbo 对 hessian2 进行了修改，不过大体结构还是差不多。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。<br><img src="/2023/01/19/JAVA/%E6%80%BB%E7%BB%93.png"></p><p>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。</p><h3 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h3><p>方法 1：通过 Scanner</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="built_in">new</span> Scanner(<span class="keyword">System</span>.<span class="keyword">in</span>);</span><br><span class="line">String s  = <span class="keyword">input</span>.nextLine();</span><br><span class="line"><span class="keyword">input</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure><p>方法 2：通过 BufferedReader</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">InputStreamReader</span>(System.<span class="keyword">in</span>));</span><br><span class="line"><span class="keyword">String</span> s = input.readLine();</span><br></pre></td></tr></table></figure><h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：<br><img src="/2023/01/19/JAVA/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png"><br>按操作对象分类结构图：<br><img src="/2023/01/19/JAVA/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png"></p><h1 id="Java易错点"><a href="#Java易错点" class="headerlink" title="Java易错点"></a>Java易错点</h1><h2 id="正确使用-equals-方法"><a href="#正确使用-equals-方法" class="headerlink" title="正确使用 equals 方法"></a>正确使用 equals 方法</h2><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。<br><strong>注意：</strong></p><ul><li>每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。</li><li>可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中null == null将返回true。</li><li>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul><h2 id="整型包装类值的比较"><a href="#整型包装类值的比较" class="headerlink" title="整型包装类值的比较"></a>整型包装类值的比较</h2><p>所有整型包装类对象值的比较必须使用equals方法。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 <span class="operator">=</span> <span class="number">40</span><span class="comment">;</span></span><br><span class="line">Integer i2 <span class="operator">=</span> new Integer(<span class="number">40</span>)<span class="comment">;</span></span><br><span class="line">System.out.println(i1<span class="operator">=</span><span class="operator">=</span>i2)<span class="comment">;//false</span></span><br></pre></td></tr></table></figure><p>Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。因此，i1 直接使用的是常量池中的对象。而Integer i1 = new Integer(40) 会直接创建新的对象。因此，输出 false 。<br><img src="/2023/01/19/JAVA/%E6%95%B4%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E6%AF%94%E8%BE%83.png"></p><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><h3 id="BigDecimal-的用处"><a href="#BigDecimal-的用处" class="headerlink" title="BigDecimal 的用处"></a>BigDecimal 的用处</h3><p>《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">float</span> a = <span class="number">1</span>.<span class="number">0</span>f - <span class="number">0</span>.<span class="number">9</span>f;</span><br><span class="line"><span class="attribute">float</span> b = <span class="number">0</span>.<span class="number">9</span>f - <span class="number">0</span>.<span class="number">8</span>f;</span><br><span class="line"><span class="attribute">System</span>.out.println(a);// <span class="number">0</span>.<span class="number">100000024</span></span><br><span class="line"><span class="attribute">System</span>.out.println(b);// <span class="number">0</span>.<span class="number">099999964</span></span><br><span class="line"><span class="attribute">System</span>.out.println(a == b);// false</span><br></pre></td></tr></table></figure><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（精度丢失），我们如何解决这个问题呢？一种很常用的方法是：使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> <span class="constructor">BigDecimal(<span class="string">&quot;1.0&quot;</span>)</span>;</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> <span class="constructor">BigDecimal(<span class="string">&quot;0.9&quot;</span>)</span>;</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> <span class="constructor">BigDecimal(<span class="string">&quot;0.8&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b); </span><br><span class="line">BigDecimal y = b.subtract(c); </span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure><h3 id="BigDecimal-的大小比较"><a href="#BigDecimal-的大小比较" class="headerlink" title="BigDecimal 的大小比较"></a>BigDecimal 的大小比较</h3><p>a.compareTo(b) : 返回 -1 表示 a 小于 b，0 表示 a 等于 b ， 1表示 a 大于 b。</p><h3 id="BigDecimal-保留几位小数"><a href="#BigDecimal-保留几位小数" class="headerlink" title="BigDecimal 保留几位小数"></a>BigDecimal 保留几位小数</h3><p>通过 setScale方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p><h3 id="BigDecimal-的使用注意事项"><a href="#BigDecimal-的使用注意事项" class="headerlink" title="BigDecimal 的使用注意事项"></a>BigDecimal 的使用注意事项</h3><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 BigDecimal(String) 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。<br><img src="/2023/01/19/JAVA/BigDecimal.png"></p><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念。</p><h3 id="BigDecimal-工具类分享"><a href="#BigDecimal-工具类分享" class="headerlink" title="BigDecimal 工具类分享"></a>BigDecimal 工具类分享</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简化BigDecimal计算的小工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认除法运算精度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEF_DIV_SCALE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BigDecimalUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的加法运算。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被加数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 加数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.add(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的减法运算。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被减数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 减数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">subtract</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.subtract(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的乘法运算。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被乘数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 乘数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的积</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">multiply</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.multiply(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到</span></span><br><span class="line"><span class="comment">     * 小数点以后10位，以后的数字四舍五入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的商</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> divide(v1, v2, DEF_DIV_SCALE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指</span></span><br><span class="line"><span class="comment">     * 定精度，以后的数字四舍五入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    被除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scale 表示表示需要精确到小数点以后几位。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的商</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2, <span class="type">int</span> scale)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (scale &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;The scale must be a positive integer or zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的小数位四舍五入处理。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v     需要四舍五入的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scale 小数点后保留几位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 四舍五入后的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> v, <span class="type">int</span> scale)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (scale &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;The scale must be a positive integer or zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> BigDecimal.valueOf(v);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的类型转换(Float)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 需要被转换的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回转换结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">convertToFloat</span><span class="params">(<span class="type">double</span> v)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v);</span><br><span class="line">        <span class="keyword">return</span> b.floatValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的类型转换(Int)不进行四舍五入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 需要被转换的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回转换结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">convertsToInt</span><span class="params">(<span class="type">double</span> v)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v);</span><br><span class="line">        <span class="keyword">return</span> b.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的类型转换(Long)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 需要被转换的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回转换结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">convertsToLong</span><span class="params">(<span class="type">double</span> v)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v);</span><br><span class="line">        <span class="keyword">return</span> b.longValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两个数中大的一个值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 需要被对比的第一个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 需要被对比的第二个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回两个数中大的一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">returnMax</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.max(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两个数中小的一个值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 需要被对比的第一个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 需要被对比的第二个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回两个数中小的一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">returnMin</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.min(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精确对比两个数字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 需要被对比的第一个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 需要被对比的第二个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.compareTo(b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。不过，Java 提供了BigDecimal 来操作浮点数。BigDecimal 的实现利用到了 BigInteger （用来操作大整数）, 所不同的是 BigDecimal 加入了小数位的概念。</p><h2 id="基本数据类型与包装数据类型的使用标准"><a href="#基本数据类型与包装数据类型的使用标准" class="headerlink" title="基本数据类型与包装数据类型的使用标准"></a>基本数据类型与包装数据类型的使用标准</h2><ul><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><h2 id="Java-魔法类-Unsafe-详解"><a href="#Java-魔法类-Unsafe-详解" class="headerlink" title="Java 魔法类 Unsafe 详解"></a>Java 魔法类 Unsafe 详解</h2><h3 id="Unsafe-介绍"><a href="#Unsafe-介绍" class="headerlink" title="Unsafe 介绍"></a>Unsafe 介绍</h3><p>Unsafe 是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。</p><p>另外，Unsafe 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用native关键字修饰，Java 代码中只是声明方法头，具体的实现则交给<strong>本地代码</strong>。</p><p><strong>为什么要使用本地方法呢？</strong></p><ol><li>需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。</li><li>对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。</li><li>程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。</li></ol><p>在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了Java运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举在很多时候会和常量拿来对比，可能因为本身我们大量实际使用枚举的地方就是为了替代常量。那么这种方式由什么优势呢？<br><strong>以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong></p><h3 id="使用-比较枚举类型"><a href="#使用-比较枚举类型" class="headerlink" title="使用 == 比较枚举类型"></a>使用 == 比较枚举类型</h3><p>由于枚举类型确保JVM中仅存在一个常量实例，因此我们可以安全地使用 == 运算符比较两个变量，如上例所示；此外，== 运算符可提供编译时和运行时的安全性。</p><p>首先，让我们看一下以下代码段中的运行时安全性，其中 == 运算符用于比较状态，并且如果两个值均为null 都不会引发 NullPointerException。相反，如果使用equals方法，将抛出 NullPointerException：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pizza.PizzaStatus pizza = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(pizza.equals(Pizza.PizzaStatus.DELIVERED));//空指针异常<span class="keyword">System</span>.<span class="keyword">out</span>.println(pizza == Pizza.PizzaStatus.DELIVERED);//正常运行</span><br></pre></td></tr></table></figure><p>对于编译时安全性，我们看另一个示例，两个不同枚举类型进行比较：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED.equals(TestColor.GREEN)); <span class="regexp">//</span> 编译正常<span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED == TestColor.GREEN);    <span class="regexp">//</span> 编译失败，类型不匹配</span><br></pre></td></tr></table></figure><h3 id="在-switch-语句中使用枚举类型"><a href="#在-switch-语句中使用枚举类型" class="headerlink" title="在 switch 语句中使用枚举类型"></a>在 switch 语句中使用枚举类型</h3><h3 id="枚举类型的属性-方法和构造函数"><a href="#枚举类型的属性-方法和构造函数" class="headerlink" title="枚举类型的属性,方法和构造函数"></a>枚举类型的属性,方法和构造函数</h3><p>你可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。<br>下面，让我们扩展上面的示例，实现从比萨的一个阶段到另一个阶段的过渡，并了解如何摆脱之前使用的if语句和switch语句：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">PizzaStatus</span> status;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PizzaStatus</span> &#123;</span><br><span class="line">        <span class="variable constant_">ORDERED</span> (<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">isOrdered</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="variable constant_">READY</span> (<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">isReady</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="variable constant_">DELIVERED</span> (<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">isDelivered</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> int timeToDelivery;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">isOrdered</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">isReady</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">isDelivered</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> int <span class="title function_">getTimeToDelivery</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> timeToDelivery;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="title class_">PizzaStatus</span> (int timeToDelivery) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">timeToDelivery</span> = timeToDelivery;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">isDeliverable</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">status</span>.<span class="title function_">isReady</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">printTimeToDeliver</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Time to delivery is &quot;</span> + </span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">getStatus</span>().<span class="title function_">getTimeToDelivery</span>());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Methods that set and get the status variable.&#125;</span></span><br></pre></td></tr></table></figure><p>下面这段代码展示它是如何 work 的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Testpublic void given<span class="constructor">PizaOrder_whenReady_thenDeliverable()</span> &#123;</span><br><span class="line">    Pizza testPz = <span class="keyword">new</span> <span class="constructor">Pizza()</span>;</span><br><span class="line">    testPz.set<span class="constructor">Status(Pizza.PizzaStatus.READY)</span>;</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">True(<span class="params">testPz</span>.<span class="params">isDeliverable</span>()</span>);&#125;</span><br></pre></td></tr></table></figure><h3 id="EnumSet-and-EnumMap"><a href="#EnumSet-and-EnumMap" class="headerlink" title="EnumSet and EnumMap"></a>EnumSet and EnumMap</h3><p>EnumSet</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式有静态代理和动态代理两种实现方式</p><h3 id="静态代理-1"><a href="#静态代理-1" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。<h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3></li></ol><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。</p><p>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p><p>就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。</p><h4 id="JDK-动态代理机制-1"><a href="#JDK-动态代理机制-1" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h4><p>在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。</p><p>Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> interface InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">public</span> <span class="keyword">Object</span> invoke(<span class="keyword">Object</span> proxy, <span class="keyword">Method</span> <span class="keyword">method</span>, <span class="keyword">Object</span>[] args)</span><br><span class="line">        throws Throwable;&#125;</span><br></pre></td></tr></table></figure><p>invoke() 方法有下面三个参数：</p><ol><li>proxy :动态生成的代理类</li><li>method : 与代理类对象调用的方法相对应</li><li>args : 当前 method 方法的参数</li></ol><p>也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h4 id="CGLIB-动态代理机制-1"><a href="#CGLIB-动态代理机制-1" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p><p>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p><p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</p><p>你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">MethodInterceptor</span> <span class="symbol">extends</span> <span class="symbol">Callback</span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="built_in">int</span>ercept(Object obj, java.lang.<span class="built_in">ref</span>lect.Method method, Object[] args,MethodProxy proxy) throws Throwable;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>obj :被代理的对象（需要增强的对象）</li><li>method :被拦截的方法（需要增强的方法）</li><li>args :方法入参</li><li>proxy :用于调用原始方法</li></ol><p>你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。</p><p>CGLIB 动态代理类使用步骤：</p><ol><li>定义一个类；</li><li>自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；</li><li>通过 Enhancer 类的 create()创建代理类；</li></ol><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h4><ol><li>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h2 id="Java集合框架基础知识"><a href="#Java集合框架基础知识" class="headerlink" title="Java集合框架基础知识"></a>Java集合框架基础知识</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><h4 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h4><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collecton接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。<br><img src="/2023/01/19/JAVA/java%E9%9B%86%E5%90%88.png"></p><h4 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h4><p>先来看一下 Collection 接口下面的集合。</p><ul><li>List</li></ul><ol><li>Arraylist： Object[] 数组</li><li>Vector：Object[] 数组</li><li>LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ol><ul><li>Set</li></ul><ol><li>HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的</li><li>TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ol><ul><li>Queue</li></ul><ol><li>PriorityQueue: Object[] 数组来实现二叉堆</li><li>ArrayQueue: Object[] 数组 + 双指针</li></ol><ul><li>Map</li></ul><ol><li>HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》</li><li>Hashtable： 数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ol><h4 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h4><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 TreeMap,不需要排序时就选择 HashMap,需要保证线程安全就选用 ConcurrentHashMap。<br>当我们只需要存放元素值时，就选择实现Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。</p><h4 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h4><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p><h3 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h3><h4 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别"></a>Arraylist 和 Vector 的区别</h4><ul><li>ArrayList 是 List 的主要实现类，底层使用 Object[ ]存储，适用于频繁的查找工作，线程不安全 ；</li><li>Vector 是 List 的古老实现类，底层使用Object[ ] 存储，线程安全的。</li></ul><h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h4><ol><li><p><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； </p></li><li><p><strong>底层数据结构</strong>： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p></li><li><p><strong>插入和删除是否受元素位置的影响</strong>：<br>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</p></li><li><p><strong>是否支持快速随机访问</strong>： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</p></li><li><p><strong>内存空间占用</strong>： ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ol><h4 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     elementData = c.<span class="built_in">toArray</span>();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.<span class="built_in">getClass</span>() != Object[].<span class="keyword">class</span>)</span><br><span class="line">             elementData = Arrays.<span class="built_in">copyOf</span>(elementData, size, Object[].<span class="keyword">class</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</p><h5 id="先来看-add-方法"><a href="#先来看-add-方法" class="headerlink" title="先来看 add 方法"></a>先来看 add 方法</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     <span class="built_in">ensureCapacityInternal</span>(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：JDK11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法</p><h5 id="再来看看-ensureCapacityInternal-方法"><a href="#再来看看-ensureCapacityInternal-方法" class="headerlink" title="再来看看 ensureCapacityInternal() 方法"></a>再来看看 ensureCapacityInternal() 方法</h5><p>（JDK7）可以看到 add 方法 首先调用了ensureCapacityInternal(size + 1)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="keyword">private</span> void ensure<span class="constructor">CapacityInternal(<span class="params">int</span> <span class="params">minCapacity</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData<span class="operator"> == </span>DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensure<span class="constructor">ExplicitCapacity(<span class="params">minCapacity</span>)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</p><h5 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a>ensureExplicitCapacity() 方法</h5><p>如果调用 ensureCapacityInternal() 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">  private void <span class="built_in">ensureExplicitCapacity</span>(int minCapacity) &#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      if (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">          <span class="built_in">grow</span>(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>分析如下：</p><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为 10。此时，minCapacity - elementData.length &gt; 0成立，所以会进入 grow(minCapacity) 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li><li>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</li></ul><h5 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow() 方法"></a>grow() 方法</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> void grow(int minCapacity) &#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Capacity</span> - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, <span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><h5 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a>hugeCapacity() 方法</h5><p>从上面 grow() 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/19/JAVA/List%E6%89%A9%E5%AE%B9.png"></p><h4 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a>ensureCapacity方法</h4><p>ArrayList 源码中有一个 ensureCapacity 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，<strong>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><br><span class="line"> *</span><br><span class="line"> * @param   <span class="keyword">min</span>Capacity   所需的最小容量</span><br><span class="line"> */</span><br><span class="line">public void ensureCapacity(int <span class="keyword">min</span>Capacity) &#123;</span><br><span class="line">    int <span class="keyword">min</span>Expand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        // <span class="literal">any</span> size if not <span class="keyword">default</span> element <span class="built_in">table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        // larger than <span class="keyword">default</span> <span class="keyword">for</span> <span class="keyword">default</span> empty <span class="built_in">table</span>. It&#x27;s already</span><br><span class="line">        // supposed <span class="keyword">to</span> be at <span class="keyword">default</span> size.</span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    if (<span class="keyword">min</span>Capacity &gt; <span class="keyword">min</span>Expand) &#123;</span><br><span class="line">        ensureExplicitCapacity(<span class="keyword">min</span>Capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList是List接口的实现类，它是支持根据需要而动态增长的数组。java中标准数组是定长的，在数组被创建之后，它们不能被加长或缩短。这就意味着在创建数组时需要知道数组的所需长度，但有时我们需要动态程序中获取数组长度。ArrayList就是为此而生的,但是它不是线程安全的，外ArrayList按照插入的顺序来存放数据<br>①ArrayList扩容发生在add()方法调用的时候， 调用ensureCapacityInternal()来扩容的，<br>通过方法calculateCapacity(elementData, minCapacity)获取需要扩容的长度:<br>②ensureExplicitCapacity方法可以判断是否需要扩容：<br>③ArrayList扩容的关键方法grow():<br>获取到ArrayList中elementData数组的内存空间长度 扩容至原来的1.5倍<br>④调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间<br>从此方法中我们可以清晰的看出其实ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。</p><h3 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h3><h4 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h4><ul><li>comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().</p><h4 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul><li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li></ul><h3 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h3><h4 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h4><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。</p><p>Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><table><thead><tr><th>Queue 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p>Deque 是双端队列，在队列的两端均可以插入或删除元素。<br>Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th>Deque 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。</p><h4 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h4><p>ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li>ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。</li><li>ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。</li><li>ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。</li><li>ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。</p><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li>PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。</li><li>PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</li></ul><p>PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p><h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><h4 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h4><ol><li><strong>线程是否安全</strong>：HashMap 是非线程安全的，Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率</strong>：因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持</strong>：HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同</strong> ： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 <strong>HashMap 总是使用 2 的幂作为哈希表的大小</strong>,后面会介绍到为什么是 2 的幂次方。</li><li>底层数据结构：JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h4 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h4><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了 Map 接口</td><td>实现 Set 接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 put()向 map 中添加元素</td><td>调用 add()方法向 Set 中添加元素</td></tr><tr><td>HashMap 使用键（Key）计算 hashcode</td><td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性</td></tr></tbody></table><h4 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h4><p>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。<br><img src="/2023/01/19/JAVA/MAP.png"></p><p>实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。</p><p>实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p>综上，相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p><h4 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h4><p>当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p><p>在openjdk8中，HashSet的add()方法只是简单的调用了HashMap的put()方法，并且判断了一下返回值以确保是否有重复元素。直接看一下HashSet中的源码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当set中没有包含add的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="built_in">add</span>(E e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>.<span class="property">put</span>(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在HashMap的putVal()方法中也能看到如下说明：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Returns : previous value, or null if none</span></span><br><span class="line"><span class="comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>也就是说，在openjdk8中，实际上无论HashSet中是否已经存在了某元素，HashSet都会直接插入，只是会在add()方法的返回值处告诉我们插入前是否存在相同元素。</p><p><strong>hashCode()与 equals() 的相关规定：</strong></p><ol><li>如果两个对象相等，则 hashcode 一定也是相同的</li><li>两个对象相等,对两个 equals() 方法返回 true</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li><li>综上，equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p><h4 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h4><h5 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h5><p>JDK1.8 之前 HashMap 底层是<strong>数组和链表</strong>结合在一起使用也就是链表散列。HashMap 通过 key 的 hashCode 经过<strong>扰动函数</strong>处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span>(<span class="built_in">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="title function_">return</span> (<span class="built_in">key</span> == <span class="literal">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.<span class="property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。<br><img src="/2023/01/19/JAVA/%E6%8B%89%E9%93%BE%E6%B3%95.png"></p><h5 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h5><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，<br>当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树，只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。<br><img src="/2023/01/19/JAVA/map%E6%89%A9%E5%AE%B9-%E7%BA%A2%E9%BB%91%E6%A0%91.png"></p><p><strong>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</strong></p><h4 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h4><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&amp;(length-1)，hash%length==hash&amp;(length-1)的前提是length是2的n次方；</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</p><h4 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h4><h5 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">HashMap</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt; <span class="symbol">extends</span> <span class="symbol">AbstractMap</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt; <span class="symbol">implements</span> <span class="symbol">Map</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt;, <span class="symbol">Cloneable, <span class="symbol">Serializable</span></span> &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">362498820763181265</span>L;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="built_in">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="built_in">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="built_in">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="built_in">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="built_in">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    transient Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    transient <span class="built_in">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    transient <span class="built_in">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="built_in">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">float</span> loadFactor;&#125;</span><br></pre></td></tr></table></figure><ul><li>loadFactor 加载因子<br>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</li><li><em>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。</em>*<br>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li><li>threshold<br>threshold = capacity * loadFactor，当 Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是<strong>衡量数组是否需要扩增的一个标准</strong>。</li></ul><h5 id="Node-节点类源码"><a href="#Node-节点类源码" class="headerlink" title="Node 节点类源码"></a>Node 节点类源码</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span></span><br><span class="line">       <span class="keyword">final</span> int hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K getKey()        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V getValue()      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String toString() &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> int hashCode() &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> boolean equals(Object o) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="树节点类源码"><a href="#树节点类源码" class="headerlink" title="树节点类源码"></a>树节点类源码</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        boolean red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; root() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line">public <span class="constructor">HashMap()</span> &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> public <span class="constructor">HashMap(Map&lt;? <span class="params">extends</span> K, ? <span class="params">extends</span> V&gt; <span class="params">m</span>)</span> &#123;</span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     put<span class="constructor">MapEntries(<span class="params">m</span>, <span class="params">false</span>)</span>;<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> public <span class="constructor">HashMap(<span class="params">int</span> <span class="params">initialCapacity</span>)</span> &#123;</span><br><span class="line">     this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"> public <span class="constructor">HashMap(<span class="params">int</span> <span class="params">initialCapacity</span>, <span class="params">float</span> <span class="params">loadFactor</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + <span class="params">initialCapacity</span>)</span>;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span><span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">Float</span>.</span></span>is<span class="constructor">NaN(<span class="params">loadFactor</span>)</span>)</span><br><span class="line">         throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + <span class="params">loadFactor</span>)</span>;</span><br><span class="line">     this.loadFactor = loadFactor;</span><br><span class="line">     this.threshold = table<span class="constructor">SizeFor(<span class="params">initialCapacity</span>)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>putMapEntries 方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final void put<span class="constructor">MapEntries(Map&lt;? <span class="params">extends</span> K, ? <span class="params">extends</span> V&gt; <span class="params">m</span>, <span class="params">boolean</span> <span class="params">evict</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> s = m.size<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table<span class="operator"> == </span>null) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="built_in">float</span> ft = ((<span class="built_in">float</span>)s<span class="operator"> / </span>loadFactor) + <span class="number">1.0</span>F;</span><br><span class="line">            <span class="built_in">int</span> t = ((ft &lt; (<span class="built_in">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="built_in">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = table<span class="constructor">SizeFor(<span class="params">t</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entry<span class="constructor">Set()</span>) &#123;</span><br><span class="line">            K key = e.get<span class="constructor">Key()</span>;</span><br><span class="line">            V value = e.get<span class="constructor">Value()</span>;</span><br><span class="line">            put<span class="constructor">Val(<span class="params">hash</span>(<span class="params">key</span>)</span>, key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h5><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p>对 putVal 方法添加元素的分析如下：</p><ol><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。<br><img src="/2023/01/19/JAVA/putVal.png"><br>说明:上图有两个小问题：</li></ol><ul><li>直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行</li><li>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 treeifyBin() 方法<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(<span class="built_in">hash</span>(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int <span class="built_in">hash</span>, K key, V value, <span class="built_in">boolean</span> onlyIfAbsent,</span><br><span class="line">                   <span class="built_in">boolean</span> evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="literal">tab</span>; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="literal">tab</span> = table) == <span class="literal">null</span> || (n = <span class="literal">tab</span>.<span class="built_in">length</span>) == <span class="number">0</span>)</span><br><span class="line">        n = (<span class="literal">tab</span> = <span class="built_in">resize</span>()).<span class="built_in">length</span>;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="literal">tab</span>[i = (n - <span class="number">1</span>) &amp; <span class="built_in">hash</span>]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="literal">tab</span>[i] = newNode(<span class="built_in">hash</span>, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">hash</span> == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.<span class="built_in">equals</span>(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p instanceof TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, <span class="literal">tab</span>, <span class="built_in">hash</span>, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (int binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(<span class="built_in">hash</span>, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(<span class="literal">tab</span>, <span class="built_in">hash</span>);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.<span class="built_in">hash</span> == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.<span class="built_in">equals</span>(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="built_in">resize</span>();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们再来对比一下 JDK1.7 put 方法的代码<br>对于 put 方法的分析如下：</p><ul><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span>(K <span class="built_in">key</span>, V value)</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    <span class="title function_">inflateTable</span>(threshold);&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">putForNullKey</span>(value);</span><br><span class="line">    <span class="type">int</span> hash = <span class="title function_">hash</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="title function_">indexFor</span>(hash, table.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.<span class="property">next</span>) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        <span class="built_in">Object</span> k;</span><br><span class="line">        <span class="keyword">if</span> (e.<span class="property">hash</span> == hash &amp;&amp; ((k = e.<span class="property">key</span>) == <span class="built_in">key</span> || <span class="built_in">key</span>.<span class="property">equals</span>(k))) &#123;</span><br><span class="line">            V oldValue = e.<span class="property">value</span>;</span><br><span class="line">            e.<span class="property">value</span> = value;</span><br><span class="line">            e.<span class="property">recordAccess</span>(<span class="variable">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="title function_">addEntry</span>(hash, <span class="built_in">key</span>, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br></pre></td></tr></table></figure><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(<span class="built_in">hash</span>(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int <span class="built_in">hash</span>, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="literal">tab</span>; Node&lt;K,V&gt; <span class="built_in">first</span>, e; int n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="literal">tab</span> = table) != <span class="literal">null</span> &amp;&amp; (n = <span class="literal">tab</span>.<span class="built_in">length</span>) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (<span class="built_in">first</span> = <span class="literal">tab</span>[(n - <span class="number">1</span>) &amp; <span class="built_in">hash</span>]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">first</span>.<span class="built_in">hash</span> == <span class="built_in">hash</span> &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = <span class="built_in">first</span>.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.<span class="built_in">equals</span>(k))))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">first</span>;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = <span class="built_in">first</span>.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">first</span> instanceof TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)<span class="built_in">first</span>).getTreeNode(<span class="built_in">hash</span>, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.<span class="built_in">hash</span> == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.<span class="built_in">equals</span>(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br></pre></td></tr></table></figure><h5 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h5></li></ul><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : <span class="type">oldTab</span>.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int <span class="keyword">new</span><span class="type">Cap</span>, <span class="keyword">new</span><span class="type">Thr</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">new</span><span class="type">Cap</span> = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="keyword">new</span><span class="type">Thr</span> = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Thr</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        float ft = (float)<span class="keyword">new</span><span class="type">Cap</span> * loadFactor;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (<span class="keyword">new</span><span class="type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : <span class="type">Integer</span>.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = <span class="keyword">new</span><span class="type">Thr</span>;</span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">&quot;rawtypes&quot;</span>,<span class="string">&quot;unchecked&quot;</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] <span class="keyword">new</span><span class="type">Tab</span> = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="type">Node</span>[<span class="keyword">new</span><span class="type">Cap</span>];</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Tab</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Tab</span>[e.hash &amp; (<span class="keyword">new</span><span class="type">Cap</span> - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, <span class="keyword">new</span><span class="type">Tab</span>, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Tab</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h4><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><h4 id="HashMap-有哪几种常见的遍历方式"><a href="#HashMap-有哪几种常见的遍历方式" class="headerlink" title="HashMap 有哪几种常见的遍历方式?"></a>HashMap 有哪几种常见的遍历方式?</h4><p>HashMap 遍历从大的方向来说，可分为以下 4 类：</p><ol><li>迭代器（Iterator）方式遍历；</li><li>For Each 方式遍历；</li><li>Lambda 表达式遍历（JDK 1.8+）;</li><li>Streams API 遍历（JDK 1.8+）。</li></ol><p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><ol><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ol><p>parallelStream 为多线程版本性能一定是最好的,两个 entrySet 的性能相近，并且执行速度最快，接下来是 stream ，然后是两个 keySet，性能最差的是 KeySet 。</p><p>我们不能在遍历中使用集合 map.remove() 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 iterator.remove() 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 removeIf 来提前删除数据，或者是使用 Stream 中的 filter 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 for 循环前删除数据在遍历也是线程安全的。</p><h4 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li>底层数据结构：JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li>实现线程安全的方式（重要）：① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><h4 id="ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h4><h5 id="JDK1-7（上面有示意图）"><a href="#JDK1-7（上面有示意图）" class="headerlink" title="JDK1.7（上面有示意图）"></a>JDK1.7（上面有示意图）</h5><p><img src="/2023/01/19/JAVA/ConcurrentHashMap-1.7.png"></p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Segment&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。</p><p>Java 7 中 ConcurrentHashMap 的存储结构如上图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。<br><img src="/2023/01/19/JAVA/ConcurrentHashMap-1.7-1.png"></p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment"> * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">final</span> <span class="type">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认并发级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>接着看下这个有参构造函数的内部实现逻辑。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span>public <span class="constructor">ConcurrentHashMap(<span class="params">int</span> <span class="params">initialCapacity</span>,<span class="params">float</span> <span class="params">loadFactor</span>, <span class="params">int</span> <span class="params">concurrencyLevel</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>)<span class="operator"> || </span>initialCapacity &lt; <span class="number">0</span><span class="operator"> || </span>concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException()</span>;</span><br><span class="line">    <span class="comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">// 2的多少次方</span></span><br><span class="line">    <span class="built_in">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录段偏移量</span></span><br><span class="line">    this.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// 记录段掩码</span></span><br><span class="line">    this.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span></span><br><span class="line">    <span class="built_in">int</span> c = initialCapacity<span class="operator"> / </span>ssize;</span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> * </span>ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="built_in">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，设置 segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="built_in">int</span>)(cap<span class="operator"> * </span>loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;<span class="literal">[]</span>)<span class="keyword">new</span> HashEntry<span class="literal">[<span class="identifier">cap</span>]</span>);</span><br><span class="line">    Segment&lt;K,V&gt;<span class="literal">[]</span> ss = (Segment&lt;K,V&gt;<span class="literal">[]</span>)<span class="keyword">new</span> Segment<span class="literal">[<span class="identifier">ssize</span>]</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>put<span class="constructor">OrderedObject(<span class="params">ss</span>, SBASE, <span class="params">s0</span>)</span>; <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    this.segments = ss;&#125;</span><br></pre></td></tr></table></figure><p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑：</p><ol><li>必要参数校验。</li><li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造默认值是 16.</li><li>寻找并发级别 concurrencyLevel 之上最近的 2 的幂次方值，作为初始化容量大小，默认是 16。</li><li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。默认是 32 - sshift = 28.</li><li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.</li><li><code>初始化 segments[0]**，默认大小为 2，负载因子 0.75，扩容阀值是 2*0.75=1.5**，插入第二个值时才会进行扩容。</code></li></ol><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>接着上面的初始化参数继续查看 put 方法源码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * @param value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * @throws NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span>public V put(K key, V value) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value<span class="operator"> == </span>null)</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">NullPointerException()</span>;</span><br><span class="line">    <span class="built_in">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="built_in">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)<span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE))<span class="operator"> == </span>null) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensure<span class="constructor">Segment(<span class="params">j</span>)</span>;</span><br><span class="line">    return s.put(key, hash, value, <span class="literal">false</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment"> * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param k the index</span></span><br><span class="line"><span class="comment"> * @return the segment</span></span><br><span class="line"><span class="comment"> */</span>@<span class="constructor">SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span><span class="keyword">private</span> Segment&lt;K,V&gt; ensure<span class="constructor">Segment(<span class="params">int</span> <span class="params">k</span>)</span> &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;<span class="literal">[]</span> ss = this.segments;</span><br><span class="line">    long u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 判断 u 位置的 Segment 是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)<span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>get<span class="constructor">ObjectVolatile(<span class="params">ss</span>, <span class="params">u</span>)</span>)<span class="operator"> == </span>null) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss<span class="literal">[<span class="number">0</span>]</span>; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span></span><br><span class="line">        <span class="built_in">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span></span><br><span class="line">        <span class="built_in">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="comment">// 计算扩容阀值</span></span><br><span class="line">        <span class="built_in">int</span> threshold = (<span class="built_in">int</span>)(cap<span class="operator"> * </span>lf);</span><br><span class="line">        <span class="comment">// 创建一个 cap 容量的 HashEntry 数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;<span class="literal">[]</span> tab = (HashEntry&lt;K,V&gt;<span class="literal">[]</span>)<span class="keyword">new</span> HashEntry<span class="literal">[<span class="identifier">cap</span>]</span>;</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)<span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>get<span class="constructor">ObjectVolatile(<span class="params">ss</span>, <span class="params">u</span>)</span>)<span class="operator"> == </span>null) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 自旋检查 u 位置的 Segment 是否为null</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)<span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>get<span class="constructor">ObjectVolatile(<span class="params">ss</span>, <span class="params">u</span>)</span>)<span class="operator"></span></span><br><span class="line"><span class="operator">                   == </span>null) &#123;</span><br><span class="line">                <span class="comment">// 使用CAS 赋值，只会成功一次</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>compare<span class="constructor">AndSwapObject(<span class="params">ss</span>, <span class="params">u</span>, <span class="params">null</span>, <span class="params">seg</span> = <span class="params">s</span>)</span>)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return seg;&#125;</span><br></pre></td></tr></table></figure><h5 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h5><p><img src="/2023/01/19/JAVA/ConcurrentHashMap-1.8.png"></p><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p><h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p>Collections 工具类常用方法:</p><ol><li>排序</li><li>查找,替换操作</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li></ol><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List list, <span class="type">int</span> i , <span class="type">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List list, <span class="type">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br></pre></td></tr></table></figure><h4 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span>(List list, <span class="built_in">Object</span> <span class="built_in">key</span>)<span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">max</span>(Collection coll)<span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">max</span>(Collection coll, Comparator c)<span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">fill</span>(List list, <span class="built_in">Object</span> obj)<span class="comment">//用指定的元素代替指定list中的所有元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span>(Collection c, <span class="built_in">Object</span> o)<span class="comment">//统计元素出现次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfSubList</span>(List list, List target)<span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span>(List list, <span class="built_in">Object</span> oldVal, <span class="built_in">Object</span> newVal)<span class="comment">//用新元素替换旧元素</span></span><br></pre></td></tr></table></figure><h4 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h4><p>Collections 提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。</p><p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt;  c)</span></span> <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line"><span class="function"><span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span><span class="comment">//返回指定列表支持的同步（线程安全的）List。synchronizedMap(Map&lt;K,V&gt; m) //返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line"><span class="function"><span class="title">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span></span> <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。<br>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java基础知识&quot;&gt;&lt;a href=&quot;#Java基础知识&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识&quot;&gt;&lt;/a&gt;Java基础知识&lt;/h1&gt;&lt;h2 id=&quot;基础概念与常识&quot;&gt;&lt;a href=&quot;#基础概念与常识&quot; class=&quot;headerlink&quot; title=&quot;基础概念与常识&quot;&gt;&lt;/a&gt;基础概念与常识&lt;/h2&gt;&lt;h3 id=&quot;JVM-vs-JDK-vs-JRE&quot;&gt;&lt;a href=&quot;#JVM-vs-JDK-vs-JRE&quot; class=&quot;headerlink&quot; title=&quot;JVM vs JDK vs JRE&quot;&gt;&lt;/a&gt;JVM vs JDK vs JRE&lt;/h3&gt;&lt;p&gt;在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。&lt;/p&gt;
&lt;p&gt;我们需要格外注意的是 .class-&amp;gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://shenhongwei33.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA基础" scheme="https://shenhongwei33.github.io/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
