---
title: python基础
date: 2023-01-25 11:20:17
tags: python基础
categories: python
---

# python
## 安装
保证安装了gcc命令，如果没没有安装gcc命令，可以执行  yum install gcc 
先安装gcc命令

1. 安装可能需要的依赖：yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel
2. 从python官网上下载python3.5.1的tar包：wget 
<u>https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz</u>
3. 将tar包解压到/usr/local目录下： tar -zxvf Python-3.5.1.tgz –C /usr/local/
4. 在/usr/local/Python3.5.1目录下执行./configure命令
5. 接着执行make命令

6. 接着执行make install命令
7. 取代原python2.7的软连接，当在命令行输入python的时候，默认启动python3.5.1 ：
```
rm -rf /usr/bin/python
ln -s /usr/local/bin/Python3.5 /usr/bin/python
```
具体Python3.5到目录下去找，看好首字母是大写还是小写

8. 在命令行输入python 查看是不是启动了python3.5.1
## 语法
### 注释

* 单行注释 以#号开头的后面的就是注释
* python 中多行注释使用三个单引号(''')或三个双引号(""")。

输出中文编码，解决方法为只要在文件开头加入 # -*- coding: UTF-8 -*- 或者 # coding=utf-8 就行了
>注意：# coding=utf-8 的 = 号两边不要空格。
```
#!/usr/bin/python 
# -*- coding: UTF-8 -*- 

print( "你好，世界" )
```
### 基础语法

#### Python2.x 中使用 Python3.x 的 print 函数

如果 Python2.x 版本想使用使用 Python3.x 的 print 函数，可以导入 __ future __ 包，该包禁用 Python2.x 的 print 语句，采用 Python3.x 的 print 函数：
```
>>> list =["a", "b", "c"]>>> print list    # python2.x 的 print 语句
['a', 'b', 'c']
>>> from __future__ import print_function  # 导入 __future__ 包>>> print list     # Python2.x 的 print 语句被禁用，使用报错  
      File "<stdin>", line 1    
         print list             
                 ^
 SyntaxError: invalid syntax
 >>> print (list)   # 使用 Python3.x 的 print 函数
 ['a', 'b', 'c']
 >>>
```
#### Python 标识符

在 Python 里，标识符由字母、数字、下划线组成。

在 Python 中，所有标识符可以包括英文、数字以及下划线(、_、)，但不能以数字开头。Python 中的标识符是区分大小写的。

以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。

以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。
Python 可以同一行显示多条语句，方法是用分号 ; 分开。

#### 多行语句

Python语句中一般以新行作为语句的结束符。但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示：
```
total = item_one + \
        item_two + \
        item_three
```
语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例：
```
days = ['Monday', 'Tuesday', 'Wednesday',
        'Thursday', 'Friday']
```
#### Python 引号
Python 可以使用引号( ' )、双引号( " )、三引号( ''' 或 """ ) 来表示字符串，引号的开始与结束必须是相同类型的。
其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。
```
word = 'word'
sentence = "这是一个句子。"
paragraph = """这是一个段落。
包含了多个语句"""
```

#### Python空行

函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。

空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。记住：空行也是程序代码的一部分。

#### print 输出

print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 ,。

#### 多个语句构成代码组

缩进相同的一组语句构成一个代码块，我们称之代码组。
像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。我们将首行及后面的代码组称为一个子句(clause)。

#### Python 变量类型

##### 变量赋值

Python 中的变量赋值不需要类型声明。
每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。

##### 标准数据类型

Python有五个标准的数据类型：

* Numbers（数字）
* String（字符串）
* List（列表）
* Tuple（元组）
* Dictionary（字典）


###### Python 数字

Python Number 数据类型用于存储数值。
数字数据类型用于存储数值，他们是不可改变的数据类型，这意味着改变数字数据类型会**分配一个新的对象**。当你指定一个值时，Number 对象就会被创建。
```
var1 = 1
var2 = 10
```
您也可以使用del语句删除一些对象的引用。
```
del var
del var_a, var_b
```

Python支持四种不同的数字类型：

* int（有符号整型）
* long（长整型，也可以代表八进制和十六进制）
* float（浮点型）
* complex（复数）

Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。

>long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。


**Python math 模块、cmath 模块**

Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。
Python math 模块提供了许多对浮点数的数学运算函数。
Python cmath 模块包含了一些用于复数运算的函数。

cmath 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数，math 模块运算的是数学运算。

要使用 math 或 cmath 函数必须先导入
```
import math
```

查看 math 查看包中的内容:
```
>>> import math
>>> dir(math)
['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']
```

**Python数学函数**

| 函数            | 返回值                                                       |
| --------------- | ------------------------------------------------------------ |
| abs(x)          | 返回数字的绝对值，如abs(-10) 返回 10                         |
| ceil(x)         | 返回数字的上入整数，如math.ceil(4.1) 返回 5                  |
| cmp(x, y)       | 如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1    |
| exp(x)          | 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045         |
| fabs(x)         | 返回数字的绝对值，如math.fabs(-10) 返回10.0                  |
| floor(x)        | 返回数字的下舍整数，如math.floor(4.9)返回 4                  |
| log(x)          | 如math.log(math.e)返回1.0,math.log(100,10)返回2.0            |
| log10(x)        | 返回以10为基数的x的对数，如math.log10(100)返回 2.0           |
| max(x1, x2,...) | 返回给定参数的最大值，参数可以为序列。                       |
| min(x1, x2,...) | 返回给定参数的最小值，参数可以为序列。                       |
| modf(x)         | 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 |
| pow(x, y)       | x** y 运算后的值。                                           |
| round(x [,n])   | 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 |
| sqrt(x)         | 返回数字x的平方根                                            |

**Python随机数函数**

随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。

| 函数                              | 描述                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| choice(seq)                       | 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 |
| randrange ([start,] stop [,step]) | 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 |
| random()                          | 随机生成下一个实数，它在[0,1)范围内。                        |
| seed([x])                         | 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 |
| shuffle(lst)                      | 将序列的所有元素随机排序                                     |
| uniform(x, y)                     | 随机生成下一个实数，它在[x,y]范围内。                        |

**Python三角函数**

| 函数        | 描述                                              |
| ----------- | ------------------------------------------------- |
| acos(x)     | 返回x的反余弦弧度值。                             |
| asin(x)     | 返回x的反正弦弧度值。                             |
| atan(x)     | 返回x的反正切弧度值。                             |
| atan2(y, x) | 返回给定的 X 及 Y 坐标值的反正切值。              |
| cos(x)      | 返回x的弧度的余弦值。                             |
| hypot(x, y) | 返回欧几里德范数 sqrt(x* x + y* y)。              |
| sin(x)      | 返回的x弧度的正弦值。                             |
| tan(x)      | 返回x弧度的正切值。                               |
| degrees(x)  | 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 |
| radians(x)  | 将角度转换为弧度                                  |

**Python数学常量**

| 常量 | 描述                                  |
| ---- | ------------------------------------- |
| pi   | 数学常量 pi（圆周率，一般以π来表示）  |
| e    | 数学常量 e，e即自然常数（自然常数）。 |

###### Python字符串

python的字串列表有2种取值顺序:

* 从左到右索引默认0开始的，最大范围是字符串长度少1
* 从右到左索引默认-1开始的，最大范围是字符串开头

如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。
```
>>> s = 'abcdef'
>>> s[1:5]
'bcde'
```
当使用以冒号分隔的字符串，python 返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。
```
>>>string = 'abcdef'
>>>print(string[:-1])
abcde
```

加号（+）是字符串连接运算符，星号（* ）是重复操作。
```
>>>string = 'abcdef'
>>>print (string * 2)
>>>print(string + "TEST")
abcdefabcdef
abcdefTEST
```

Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。

**Python 字符串格式化**

Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。
```
>>>print ("My name is %s and weight is %d kg!" % ('Zara', 21) )
My name is Zara and weight is 21 kg!
```
python 字符串格式化符号:

| 符号 | 描述                                 |
| ---- | ------------------------------------ |
| %c   | 格式化字符及其ASCII码                |
| %s   | 格式化字符串                         |
| %d   | 格式化整数                           |
| %u   | 格式化无符号整型                     |
| %o   | 格式化无符号八进制数                 |
| %x   | 格式化无符号十六进制数               |
| %X   | 格式化无符号十六进制数（大写）       |
| %f   | 格式化浮点数字，可指定小数点后的精度 |
| %e   | 用科学计数法格式化浮点数             |
| %E   | 作用同%e，用科学计数法格式化浮点数   |
| %g   | %f和%e的简写                         |
| %G   | %F 和 %E 的简写                      |
| %p   | 用十六进制数格式化变量的地址         |

格式化操作符辅助指令:

| 符号  | 功能                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 定义宽度或者小数点精度                                       |
| -     | 用做左对齐                                                   |
| +     | 在正数前面显示加号( + )                                      |
| <sp>  | 在正数前面显示空格                                           |
| #     | 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X') |
| 0     | 显示的数字前面填充'0'而不是默认的空格                        |
| %     | '%%'输出一个单一的'%'                                        |
| (var) | 映射变量(字典参数)                                           |
| m.n.  | m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)        |

Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。

**Python 三引号**

Python 中三引号可以将复杂的字符串进行赋值。Python 三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。

三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。一个典型的用例是，当你需要一块HTML或者SQL时，这时当用三引号标记，使用传统的转义字符体系将十分费神。

**python的字符串内建函数**

这些方法实现了string模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对Unicode的支持，有一些甚至是专门用于Unicode的。

| 方法                                                | 描述                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| string.capitalize()                                 | 把字符串的第一个字符大写                                     |
| string.count(str, beg=0, end=len(string))           | 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 |
| string.decode(encoding='UTF-8', errors='strict')    | 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 'ignore' 或 者'replace' |
| string.encode(encoding='UTF-8', errors='strict')    | 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace' |
| string.endswith(obj, beg=0, end=len(string))        | 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. |
| string.find(str, beg=0, end=len(string))            | 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 |
| string.format()                                     | 格式化字符串                                                 |
| string.index(str, beg=0, end=len(string))           | 跟find()方法一样，只不过如果str不在 string中会报一个异常.    |
| string.isspace()                                    | 如果 string 中只包含空格，则返回 True，否则返回 False.       |
| string.join(seq)                                    | 以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 |
| string.partition(str)                               | 有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string. |
| string.replace(str1, str2,  num=string.count(str1)) | 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次. |
| string.rfind(str, beg=0,end=len(string) )           | 类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。 |
| string.rstrip()                                     | 删除 string 字符串末尾的空格.                                |
| string.split(str="", num=string.count(str))         | 以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+1 个子字符串 |
| string.strip([obj])                                 | 在 string 上执行 lstrip()和 rstrip()                         |
| string.translate(str, del="")                       | 根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中 |

###### Python列表

List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。
列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。
列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。列表的数据项不需要具有相同的类型。
```
>>>myList = ['a','b','c','d','e']
>>>print(myList[1:4])
['b', 'c', 'd']
```

Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：
```
>>>myList = ['a','b','c','d','e']
>>>print(myList[1:4:2])
['b', 'd']
```
加号 + 是列表连接运算符，星号 * 是重复操作。
```
>>>myList = ['a','b','c','d','e']
>>>tinylist = [123, 'john']
>>>print (tinylist * 2)
>>>print(tinylist + myList)
[123, 'john', 123, 'john']
[123, 'john', 'a', 'b', 'c', 'd', 'e']
```

你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项；
可以使用 del 语句来删除列表的元素；

**Python列表函数&方法**

Python包含以下函数:

| 函数              | 说明               |
| ----------------- | ------------------ |
| cmp(list1, list2) | 比较两个列表的元素 |
| len(list)         | 列表元素个数       |
| max(list)         | 返回列表元素最大值 |
| min(list)         | 返回列表元素最小值 |
| list(seq)         | 将元组转换为列表   |

Python包含以下方法:

| 方法                                         | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| list.append(obj)                             | 在列表末尾添加新的对象                                       |
| list.count(obj)                              | 统计某个元素在列表中出现的次数                               |
| list.extend(seq)                             | 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |
| list.index(obj)                              | 从列表中找出某个值第一个匹配项的索引位置                     |
| list.insert(index, obj)                      | 将对象插入列表                                               |
| list.pop([index=-1])                         | 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |
| list.remove(obj)                             | 移除列表中某个值的第一个匹配项                               |
| list.reverse()                               | 反向列表中元素                                               |
| list.sort(cmp=None, key=None, reverse=False) | 对原列表进行排序                                             |

###### Python 元组

元组是另一个数据类型，类似于 List（列表）。元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于**只读列表**。
```
>>>tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )
>>>tinytuple = (123, 'john')
>>>print (tinytuple * 2)
>>>print(tinytuple + tuple)
(123, 'john', 123, 'john')
(123, 'john', 'runoob', 786, 2.23, 'john', 70.2)
```
元组中只包含一个元素时，需要在元素后面添加逗号，元组与字符串类似，下标索引从0开始，可以进行截取，组合等。
元组中的元素值是不允许修改的，但我们可以对元组进行连接组合
元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组

**元组内置函数**

| 方法                | 描述                   |
| ------------------- | ---------------------- |
| cmp(tuple1, tuple2) | 比较两个元组元素。     |
| len(tuple)          | 计算元组元素个数。     |
| max(tuple)          | 返回元组中元素最大值。 |
| min(tuple)          | 返回元组中元素最小值。 |
| tuple(seq)          | 将列表转换为元组。     |
###### Python 字典

字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用"{ }"标识。字典由索引(key)和它对应的值value组成，键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一，值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。
```
>>>dict = {}
>>>dict['one'] = "This is one"
>>>dict[2] = "This is two"
>>>tinydict = {'name': 'runoob', 'code': 6734, 'dept': 'sales'}
>>>print (dict[2])
>>>print(tinydict.keys())
>>>print(tinydict.values())
This is two
dict_keys(['name', 'code', 'dept'])
dict_values(['runoob', 6734, 'sales'])
```
把相应的键放入熟悉的方括弧，就可以访问字典里的值

能删单一的元素也能清空字典，清空只需一项操作。
```
tinydict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
del tinydict['Name']  # 删除键是'Name'的条目
tinydict.clear()  # 清空字典所有条目
del tinydict  # 删除字典
```
字典值可以没有限制地取任何 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。
两个重要的点需要记住

1. 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住
2. 键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行

**字典内置函数&方法**

Python字典包含了以下内置函数：
| 函数              | 描述                                               |
| ----------------- | -------------------------------------------------- |
| cmp(dict1, dict2) | 比较两个字典元素。                                 |
| len(dict)         | 计算字典元素个数，即键的总数。                     |
| str(dict)         | 输出字典可打印的字符串表示。                       |
| type(variable)    | 返回输入的变量类型，如果变量是字典就返回字典类型。 |

Python字典包含了以下内置方法：

| 方法                               | 描述                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| dict.clear()                       | 删除字典内所有元素                                           |
| dict.copy()                        | 返回一个字典的浅复制                                         |
| dict.fromkeys(seq[, val])          | 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 |
| dict.get(key, default=None)        | 返回指定键的值，如果值不在字典中返回default值                |
| dict.has_key(key)                  | 如果键在字典dict里返回true，否则返回false                    |
| dict.items()                       | 以列表返回可遍历的(键, 值) 元组数组                          |
| dict.keys()                        | 以列表返回一个字典所有的键                                   |
| dict.setdefault(key, default=None) | 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |
| dict.update(dict2)                 | 把字典dict2的键/值对更新到dict里                             |
| dict.values()                      | 以列表返回字典中的所有值                                     |
| pop(key[,default])                 | 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |
| popitem()                          | 返回并删除字典中的最后一对键和值。                           |

###### Python数据类型转换

有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。

| 函数                  | 描述                                                |
| --------------------- | --------------------------------------------------- |
| int(x [,base])        | 将x转换为一个整数                                   |
| long(x [,base] )      | 将x转换为一个长整数                                 |
| float(x)              | 将x转换到一个浮点数                                 |
| complex(real [,imag]) | 创建一个复数                                        |
| str(x)                | 将对象 x 转换为字符串                               |
| repr(x)               | 将对象 x 转换为表达式字符串                         |
| eval(str)             | 用来计算在字符串中的有效Python表达式,并返回一个对象 |
| tuple(s)              | 将序列 s 转换为一个元组                             |
| list(s)               | 将序列 s 转换为一个列表                             |
| set(s)                | 转换为可变集合                                      |
| dict(d)               | 创建一个字典。d 必须是一个序列 (key,value)元组。    |
| frozenset(s)          | 转换为不可变集合                                    |
| chr(x)                | 将一个整数转换为一个字符                            |
| unichr(x)             | 将一个整数转换为Unicode字符                         |
| ord(x)                | 将一个字符转换为它的整数值                          |
| hex(x)                | 将一个整数转换为一个十六进制字符串                  |
| oct(x)                | 将一个整数转换为一个八进制字符串                    |

#### Python 运算符

Python语言支持以下类型的运算符:

* 算术运算符
* 比较（关系）运算符
* 赋值运算符
* 逻辑运算符
* 位运算符
* 成员运算符
* 身份运算符
* 运算符优先级

##### Python算术运算符

| 运算符 | 描述                                                   |
| ------ | ------------------------------------------------------ |
| +      | 加                                                     |
| -      | 减                                                     |
| *      | 乘                                                     |
| /      | 除                                                     |
| %      | 取模 - 返回除法的余数                                  |
| **     | 幂 - 返回x的y次幂，如a** b 为10的20次方                |
| //     | 取整除 - 返回商的整数部分（向下取整），如9//2的结果为4 |

>Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。

python3返回对应的数
```
>>>print (1/2)
>>>print(1.0/2)
0.5
0.5
```

##### Python比较运算符

| 运算符 | 描述                                                  |
| ------ | ----------------------------------------------------- |
| ==     | 等于 - 比较对象是否相等                               |
| !=     | 不等于 - 比较两个对象是否不相等                       |
| <>     | 不等于 - 比较两个对象是否不相等。**python3 已废弃**。 |
| >      | 大于                                                  |
| <      | 小于                                                  |
| >=     | 大于等于                                              |
| <=     | 小于等于                                              |

##### Python赋值运算符

| 运算符 | 描述             |
| ------ | ---------------- |
| =      | 简单的赋值运算符 |
| +=     | 加法赋值运算符   |
| -=     | 减法赋值运算符   |
| * =    | 乘法赋值运算符   |
| /=     | 除法赋值运算符   |
| %=     | 取模赋值运算符   |
| ** =   | 幂赋值运算符     |
| //=    | 取整除赋值运算符 |

##### Python位运算符

按位运算符是把数字看作二进制来进行计算的

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| &      | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 |
| \|     | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 |
| ^      | 按位异或运算符：当两对应的二进位相异时，结果为1              |
| ~      | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 |
| <<     | 左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。 |
| >>     | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数 |

##### Python逻辑运算符

| 运算符 | 逻辑表达式 | 描述                                                         |
| ------ | ---------- | ------------------------------------------------------------ |
| and    | x and y    | 布尔"与" : 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 |
| or     | x or y     | 布尔"或" : 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。 |
| not    | not x      | 布尔"非" : 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 |

##### Python成员运算符

除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。

| 运算符 | 描述                                                    |
| ------ | ------------------------------------------------------- |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False。     |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False。 |
```
a = 10
list = [1, 2, 3, 4, 5 ]
if ( a in list ):    
    print("变量 a 在给定的列表中 list 中")
else:    
    print("变量 a 不在给定的列表中 list 中")

输出：变量 a 不在给定的列表中 list 中
```

##### Python身份运算符

身份运算符用于比较两个对象的存储单元

| 运算符 | 描述                                        |
| ------ | ------------------------------------------- |
| is     | is 是判断两个标识符是不是引用自一个对象     |
| is not | is not 是判断两个标识符是不是引用自不同对象 |

注： id() 函数用于获取对象内存地址。
```
a = 20
b = 20
if a is b:    
    print("a 和 b 有相同的标识")
else:    
    print("a 和 b 没有相同的标识")
print(id(a))

输出：
a 和 b 有相同的标识
1893215680
```
**is 与 == 区别**：is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。

#### Python 条件语句

Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。
Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。
Python 编程中 if 语句用于控制程序的执行，基本形式为：
```
if 判断条件：
    执行语句……
else：
    执行语句……
```
当判断条件为多个值时，可以使用以下形式：
```
if 判断条件1:
    执行语句1……
elif 判断条件2:
    执行语句2……
elif 判断条件3:
    执行语句3……
else:
    执行语句4……
```
由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。
当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于>（大于）、<（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。

#### Python 循环语句

Python 提供了 for 循环和 while 循环（在 Python 中没有 do..while 循环）:

| 循环类型   | 描述                                                   |
| ---------- | ------------------------------------------------------ |
| while 循环 | 在给定的判断条件为 true 时执行循环体，否则退出循环体。 |
| for 循环   | 重复执行语句                                           |
| 嵌套循环   | 你可以在while循环体中嵌套for循环                       |

##### 循环控制语句

循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：

| 控制语句      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| break 语句    | 在语句块执行过程中终止循环，并且跳出整个循环                 |
| continue 语句 | 在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。 |
| pass 语句     | pass是空语句，是为了保持程序结构的完整性。                   |

##### Python While 循环语句

在 python 中，while … else 在循环条件为 false 时执行 else 语句块：
```
count = 0
while count < 3:    
    print(count, " is  less than 3")    
    count = count + 1
else:    
    print(count, " is not less than 3")

输出：
0  is  less than 3
1  is  less than 3
2  is  less than 3
3  is not less than 3
```

##### Python for 循环语句

Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。
for循环的语法格式如下：
```
for iterating_var in sequence:
   statements(s)
```
```
fruits = ['banana', 'apple',  'mango']
for fruit in fruits:    
    print('当前水果: %s' % fruit)
输出：
当前水果: banana
当前水果: apple
当前水果: mango
```
###### 通过序列索引迭代
```
fruits = ['banana', 'apple',  'mango']
for index in range(len(fruits)):   
    print('当前水果 : %s' % fruits[index])
输出：
当前水果 : banana
当前水果 : apple
当前水果 : mango
```
以上实例我们使用了内置函数 len() 和 range(),函数 len() 返回列表的长度，即元素的个数。 range返回一个序列的数。

在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。

#### Python break 语句

Python break语句，就像在C语言中，打破了最小封闭for或while循环。

break语句用来终止循环语句，即循环条件没有False条件或者序列还没被完全递归完，也会停止执行循环语句。break语句用在while和for循环中。如果您使用嵌套循环，break语句将停止执行最深层的循环，并开始执行下一行代码。

#### Python continue 语句

Python continue 语句跳出本次循环，而break跳出整个循环。continue 语句用来告诉Python跳过当前循环的剩余语句，然后继续进行下一轮循环。continue语句用在while和for循环中。

#### Python pass 语句

Python pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。Python 语言 pass 语句语法格式如下。

#### Python 日期和时间

Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。

时间间隔是以秒为单位的浮点小数。每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳, 
```
>>>import time
>>>ticket = time.time()
>>>print(ticket)
1639988201.8350108
```
时间戳单位最适于做日期运算。

##### 什么是时间元组？

很多Python函数用一个元组装起来的9组数字处理时间:

| 序号 | 字段         | 值                                   |
| ---- | ------------ | ------------------------------------ |
| 0    | 4位数年      | 2008                                 |
| 1    | 月           | 1 到 12                              |
| 2    | 日           | 1到31                                |
| 3    | 小时         | 0到23                                |
| 4    | 分钟         | 0到59                                |
| 5    | 秒           | 0到61 (60或61 是闰秒)                |
| 6    | 一周的第几日 | 0到6 (0是周一)                       |
| 7    | 一年的第几日 | 1到366 (儒略历)                      |
| 8    | 夏令时       | -1, 0, 1, -1是决定是否为夏令时的旗帜 |

上述也就是struct_time元组。这种结构具有如下属性：

| 序号 | 属性     | 值                                   |
| ---- | -------- | ------------------------------------ |
| 0    | tm_year  | 2008                                 |
| 1    | tm_mon   | 1 到 12                              |
| 2    | tm_mday  | 1 到 31                              |
| 3    | tm_hour  | 0 到 23                              |
| 4    | tm_min   | 0 到 59                              |
| 5    | tm_sec   | 0 到 61 (60或61 是闰秒)              |
| 6    | tm_wday  | 0到6 (0是周一)                       |
| 7    | tm_yday  | 1 到 366(儒略历)                     |
| 8    | tm_isdst | -1, 0, 1, -1是决定是否为夏令时的旗帜 |

##### 获取当前时间

从返回浮点数的时间戳方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。
```
>>>localtime = time.localtime(time.time())
>>>print(localtime)
time.struct_time(tm_year=2021, tm_mon=12, tm_mday=20, tm_hour=16, tm_min=33, tm_sec=9, tm_wday=0, tm_yday=354, tm_isdst=0)
```
##### 获取格式化的时间

你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime():
```
>>>localtime = time.asctime( time.localtime(time.time()) )
>>>print(localtime)
Mon Dec 20 16:34:32 2021
```

##### 格式化日期

我们可以使用 time 模块的 strftime 方法来格式化日期：
```
time.strftime(format[, t])
```
```
>>>print (time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
2021-12-20 16:40:43
```
python中时间日期格式化符号：

* %y 两位数的年份表示（00-99）
* %Y 四位数的年份表示（000-9999）
* %m 月份（01-12）
* %d 月内中的一天（0-31）
* %H 24小时制小时数（0-23)
* %I 12小时制小时数（01-12）
* %M 分钟数（00-59）
* %S 秒（00-59）
* %a 本地简化星期名称
* %A 本地完整星期名称
* %b 本地简化的月份名称
* %B 本地完整的月份名称
* %c 本地相应的日期表示和时间表示
* %j 年内的一天（001-366）
* %p 本地A.M.或P.M.的等价符
* %U 一年中的星期数（00-53）星期天为星期的开始
* %w 星期（0-6），星期天为星期的开始
* %W 一年中的星期数（00-53）星期一为星期的开始
* %x 本地相应的日期表示
* %X 本地相应的时间表示
* %Z 当前时区的名称
* %% %号本身


##### 日历（Calendar）模块
###### 获取某月日历

Calendar模块有很广泛的方法用来处理年历和月历,例如打印某月的月历：
```
>>>import calendar
>>>cal = calendar.month(2021, 12)
>>>print(cal)
   December 2021
Mo Tu We Th Fr Sa Su
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
```
星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数：

| 函数                                 | 描述                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| calendar.calendar(year,w=2,l=1,c=6)  | 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。 |
| calendar.firstweekday( )             | 返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。 |
| calendar.isleap(year)                | 是闰年返回 True，否则为 False。                              |
| calendar.leapdays(y1,y2)             | 返回在Y1，Y2两年之间的闰年总数。                             |
| calendar.month(year,month,w=2,l=1)   | 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 |
| calendar.monthcalendar(year,month)   | 返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 |
| calendar.monthrange(year,month)      | 返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。 |
| calendar.prcal(year,w=2,l=1,c=6)     | 相当于 print calendar.calendar(year,w=2,l=1,c=6)。           |
| calendar.prmonth(year,month,w=2,l=1) | 相当于 print calendar.month(year,month,w=2,l=1) 。           |
| calendar.setfirstweekday(weekday)    | 设置每周的起始日期码。0（星期一）到6（星期日）。             |
| calendar.timegm(tupletime)           | 和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 |
| calendar.weekday(year,month,day)     | 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 |

##### Time 模块

Time 模块包含了以下内置函数，既有时间处理的，也有转换时间格式的：

| 函数                                          | 描述                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| time.altzone                                  | 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 |
| time.asctime([tupletime])                     | 接受时间元组并返回一个可读的形式为"Tue Dec 11 18:07:14 2008"（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 |
| time.clock( )                                 | 用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 |
| time.ctime([secs])                            | 作用相当于asctime(localtime(secs))，未给参数相当于asctime()  |
| time.gmtime([secs])                           | 接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 |
| time.localtime([secs])                        | 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 |
| time.mktime(tupletime)                        | 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。       |
| time.sleep(secs)                              | 推迟调用线程的运行，secs指秒数。                             |
| time.strftime(fmt[,tupletime])                | 接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 |
| time.strptime(str,fmt='%a %b %d %H:%M:%S %Y') | 根据fmt的格式把一个时间字符串解析为时间元组。                |
| time.time( )                                  | 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。           |
| time.tzset()                                  | 根据环境变量TZ重新初始化时间相关设置。                       |

Time模块包含了以下2个非常重要的属性：

| 属性          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| time.timezone | 属性 time.timezone 是当地时区（未启动夏令时）距离格林威治的偏移秒数（>0，美洲<=0大部分欧洲，亚洲，非洲）。 |
| time.tzname   | 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。 |

#### Python 函数

函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。

##### 定义一个函数

你可以定义一个由自己想要功能的函数，以下是简单的规则：

* 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。
* 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。
* 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
* 函数内容以冒号起始，并且缩进。
* return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。

```
def functionname( parameters ): 
    "函数_文档字符串" 
    function_suite 
    return [expression]
```

##### 参数传递

在 python 中，类型属于对象，变量是没有类型的。
```
a=[1,2,3]
a="Runoob"
```
以上代码中，[1,2,3] 是 List 类型，"Runoob" 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。

###### 可更改(mutable)与不可更改(immutable)对象

在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。

* **不可变类型**：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。
* **可变类型**：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。

python 函数的参数传递：

* **不可变类型**：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。
* **可变类型**：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响

python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。

###### 参数

以下是调用函数时可使用的正式参数类型：

* 必备参数
* 关键字参数
* 默认参数
* 不定长参数

**必备参数**

必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样，不然会出现语法错误。

**关键字参数**

关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。
```
#可写函数说明 
def printinfo( name, age ): 
    "打印任何传入的字符串" 
    print "Name: ", name 
    print "Age ", age 
    return 
 
#调用printinfo函数 
printinfo( age=50, name="miki" )
```

**默认参数**

调用函数时，默认参数的值如果没有传入，则被认为是默认值。

**不定长参数**

你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：
```
def functionname([formal_args,] *var_args_tuple ): 
    "函数_文档字符串" 
    function_suite 
    return [expression]
```

加了星号（* ）的变量名会存放所有未命名的变量参数。不定长参数实例如下：
```
# 可写函数说明 
def printinfo( arg1, *vartuple ): 
    "打印任何传入的参数" 
    print "输出: " 
    print arg1 
    for var in vartuple: 
        print var 
    return 
    
# 调用printinfo 函数 
printinfo( 10 ) 
printinfo( 70, 60, 50 )
```

##### 匿名函数

python 使用 lambda 来创建匿名函数。

* lambda只是一个表达式，函数体比def简单很多。
* lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
* lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。
* 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。

lambda函数的语法只包含一个语句，如下：
```
lambda [arg1 [,arg2,.....argn]]:expression
```
```
# 可写函数说明
sum = lambda arg1, arg2: arg1 + arg2
 
# 调用sum函数
print "相加后的值为 : ", sum( 10, 20 )
print "相加后的值为 : ", sum( 20, 20 )
```

##### return 语句

return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。

##### 变量作用域

一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：

* 全局变量
* 局部变量

定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。
局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。

#### Python 模块

Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。

模块让你能够有逻辑地组织你的 Python 代码段。把相关的代码分配到一个模块里能让你的代码更好用，更易懂。模块能定义函数，类和变量，模块里也能包含可执行的代码。

##### import 语句

模块定义好后，我们可以使用 import 语句来引入模块，语法如下：
```
import module1[, module2[,... moduleN]]
```
比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：
```
模块名.函数名
```
当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端.

一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。

###### from…import 语句

Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：
```
from modname import name1[, name2[, ... nameN]]
```
把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：
```
from modname import *
```
这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。
```
from math import *
```

###### 搜索路径

当你导入一个模块，Python 解析器对模块位置的搜索顺序是：

* 当前目录
* 如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。
* 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。

模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。
作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。
在 UNIX 系统，典型的 PYTHONPATH 如下：
```
set PYTHONPATH=/usr/local/lib/python
```
###### 命名空间和作用域
变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。
Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。因此，如果要给函数内的全局变量赋值，必须使用 global 语句。
global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句前的注释符就能解决这个问题。
```
Money = 2000
def  AddMoney() :    
    # 想改正代码就取消以下注释:    
    global Money    
    Money = Money + 1
    
print(Money)
AddMoney()
print(Money)
```
###### dir()函数

dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有模块，变量和函数。

###### globals() 和 locals() 函数

根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。如果在函数内部调用 globals()，返回的是所有在该函数里能访问的全局名字。两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。

###### reload() 函数

当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。因此，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块。语法如下：
```
reload(module_name)
```

###### Python中的包

包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。简单来说，包就是文件夹，但该文件夹下必须存在 __ init __ .py 文件, 该文件的内容可以为空。__ init __ .py 用于标识当前文件夹是一个包。例如：
```
test.py
package_runoob
|-- __init__.py
|-- runoob1.py
|-- runoob2.py
```
```
# 导入 Phone 包 
from package_runoob.runoob1 import runoob1 
from package_runoob.runoob2 import runoob2 
runoob1() 
runoob2()
```

#### Python 文件I/O

##### 打印到屏幕

最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式。

##### 读取键盘输入

Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下：

* raw_input
* input

###### raw_input函数
raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：
```
str_my = raw_input("请输入：")
print ("你输入的内容是: ", str_my)
```
其中python2才具有该函数，python3仅包含input函数

###### input函数

input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，在python2中 input 可以接收一个Python表达式作为输入，并将运算结果返回，python3中仅仅将输入作为字符串

##### 打开和关闭文件

Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。

###### open 函数

你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写，具体语法：
```
file object = open(file_name [, access_mode][, buffering])
```
各个参数的细节如下：

* file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。
* access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。
* buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。

完整的语法格式为：
```
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```
参数说明:

* file: 必需，文件路径（相对或者绝对路径）。
* mode: 可选，文件打开模式
* buffering: 设置缓冲
* encoding: 一般使用utf8
* errors: 报错级别
* newline: 区分换行符
* closefd: 传入的file参数类型
* opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。

不同模式打开文件的完全列表：

| 模式 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| t    | 文本模式 (默认)。                                            |
| x    | 写模式，新建一个文件，如果该文件已存在则会报错。             |
| b    | 二进制模式。                                                 |
| +    | 打开一个文件进行更新(可读可写)。                             |
| U    | 通用换行模式（不推荐）。                                     |
| r    | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |
| rb   | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 |
| r+   | 打开一个文件用于读写。文件指针将会放在文件的开头。           |
| rb+  | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 |
| w    | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
| wb   | 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 |
| w+   | 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
| wb+  | 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 |
| a    | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| ab   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| a+   | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 |
| ab+  | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |

![](python基础/文件.png)

##### File对象的属性

一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。
以下是和file对象相关的所有属性的列表：

| 属性           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| file.closed    | 返回true如果文件已被关闭，否则返回false。                    |
| file.mode      | 返回被打开文件的访问模式。                                   |
| file.name      | 返回文件的名称。                                             |
| file.softspace | 如果用print输出后，必须跟一个空格符，则返回false。否则返回true。 |

###### close()方法

File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。语法：
```
fileObject.close()
```

###### write()方法

write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。
write()方法不会在字符串的结尾添加换行符('\n')：
```
fileObject.write(string)
```
###### read()方法

read()方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。
```
fileObject.read([count])
```
在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。

###### file对象常用函数

| 序号 | 方法                        | 描述                                                         |
| ---- | --------------------------- | ------------------------------------------------------------ |
| 1    | file.close()                | 关闭文件。关闭后文件不能再进行读写操作。                     |
| 2    | file.flush()                | 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入 |
| 3    | file.fileno()               | 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 |
| 4    | file.isatty()               | 如果文件连接到一个终端设备返回 True，否则返回 False。        |
| 5    | file.next()                 | 返回文件下一行。                                             |
| 6    | file.read([size])           | 从文件读取指定的字节数，如果未给定或为负则读取所有。         |
| 7    | file.readline([size])       | 读取整行，包括 "\n" 字符。                                   |
| 8    | file.readlines([sizeint])   | 读取所有行并返回列表，若给定sizeint>0，则是设置一次读多少字节，这是为了减轻读取压力。 |
| 9    | file.seek(offset[, whence]) | 设置文件当前位置                                             |
| 10   | file.tell()                 | 返回文件当前位置。                                           |
| 11   | file.truncate([size])       | 截取文件，截取的字节通过size指定，默认为当前文件位置。       |
| 12   | file.write(str)             | 将字符串写入文件，返回的是写入的字符长度。                   |
| 13   | file.writelines(sequence)   | 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 |

##### 文件定位

tell()方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。
```

#!/usr/bin/python# -*- coding: UTF-8 -*-
 
# 打开一个文件
fo = open("foo.txt", "r+")
str = fo.read(10)print "读取的字符串是 : ", str
 
# 查找当前位置
position = fo.tell()print "当前文件位置 : ", position
 
# 把指针再次重新定位到文件开头
position = fo.seek(0, 0)
str = fo.read(10)print "重新读取字符串 : ", str
# 关闭打开的文件
fo.close()
```
##### 重命名和删除文件

Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。

###### rename() 方法

rename() 方法需要两个参数，当前的文件名和新文件名。
```
os.rename(current_file_name, new_file_name)
```

###### remove()方法

你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。
```
os.remove(file_name)
```

##### Python里的目录

所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。

###### mkdir()方法

可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。
```
os.mkdir("newdir")
```
###### chdir()方法

可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。
```
os.chdir("newdir")
```
getcwd()方法：getcwd()方法显示当前的工作目录。

###### rmdir()方法

rmdir()方法删除目录，目录名称以参数传递。在删除这个目录之前，它的所有内容应该先被清除。
```
os.rmdir('dirname')
```

#### Python 异常处理

python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误。

* 异常处理
* 断言

异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。异常是Python对象，表示一个错误。当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。

##### 异常处理

捕捉异常可以使用try/except语句。try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。如果你不想在异常发生时结束你的程序，只需在try里捕获它。
```
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
```
try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。

* 如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。
* 如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。
* 如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。

例如：
```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
try:
    fh = open("testfile", "w")    
    fh.write("这是一个测试文件，用于测试异常!!")
except IOError:    
    print "Error: 没有找到文件或读取文件失败"
else:    
    print "内容写入文件成功"    
    fh.close()
```

##### 使用except而带多种异常类型

你可以不带任何异常类型使用except，如下实例：
```
try:
    正常的操作
   ......................
except:
    发生异常，执行这块代码
   ......................
else:
    如果没有异常执行这块代码
```
以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。

##### 使用except而带多种异常类型

你也可以使用相同的except语句来处理多个异常信息，如下所示：
```

try:
    正常的操作
   ......................
except(Exception1[, Exception2[,...ExceptionN]]):
   发生以上多个异常中的一个，执行这块代码
   ......................
else:
    如果没有异常执行这块代码
```
##### try-finally 语句

try-finally 语句无论是否发生异常都将执行最后的代码。
```
try:
<语句>
finally:
<语句>    #退出try时总会执行
```
例如：
```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
try:    
    fh = open("testfile", "w")    
    try:        
        fh.write("这是一个测试文件，用于测试异常!!")    
    finally:        
        print "关闭文件"        
        fh.close()
except IOError:    
    print "Error: 没有找到文件或读取文件失败"
```
当在try块中抛出一个异常，立即执行finally块代码。finally块中的所有语句执行后，异常被再次触发，并执行except块代码。参数的内容不同于异常。

##### 异常的参数

一个异常可以带上参数，可作为输出的异常信息参数。你可以通过except语句来捕获异常的参数，如下所示：
```
try:
    正常的操作
   ......................
except ExceptionType, Argument:
    你可以在这输出 Argument 的值...
```

变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。元组通常包含错误字符串，错误数字，错误位置。

##### 触发异常

我们可以使用raise语句自己触发异常，raise语法格式如下：
```
raise [Exception [, args [, traceback]]]
```

语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。

一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。定义一个异常非常简单，如下所示：
```

def functionName( level ):    
    if level < 1:        
        raise Exception("Invalid level!", level)        
        # 触发异常后，后面的代码就不会再执行
```

>注意：为了能够捕获异常，"except"语句必须有用相同的异常来抛出类对象或者字符串。

例如我们捕获以上异常，"except"语句如下所示：
```
try:
    正常逻辑except Exception,err:
    触发自定义异常    
else:
    其余代码
```

##### 用户自定义异常

通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。
```
class Networkerror(RuntimeError):
    def __init__(self, arg):
        self.args = arg
```

## Python 面向对象

### 面向对象技术简介

* 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
* 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
* 数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。
* 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
* 局部变量：定义在方法中的变量，只作用于当前实例的类。
* 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。
* 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。
* 实例化：创建一个类的实例，类的具体对象。
* 方法：类中定义的函数。
* 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。

### 创建类

使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:
```
class ClassName:
   '类的帮助信息'   #类文档字符串
   class_suite  #类体
```
类的帮助信息可以通过ClassName.__ doc__查看。class_suite 由类成员，方法，数据属性组成。
```

#!/usr/bin/python 
# -*- coding: UTF-8 -*- 
class Employee: 
    '所有员工的基类' 
    empCount = 0 
    def __init__(self, name, salary): 
        self.name = name 
        self.salary = salary 
        Employee.empCount += 1 
    def displayCount(self): 
        print "Total Employee %d" % Employee.empCount 
    def displayEmployee(self): 
        print "Name : ", self.name, ", Salary: ", self.salary
```
说明：

* empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。
* 第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法
* self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。

#### self代表类的实例，而非类

类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。
```

class Test: 
    def prt(self): 
        print(self) 
        print(self.__class__) 
        
t = Test() 
t.prt()
```
以上实例执行结果为：
```
<__main__.Test instance at 0x10d066878>
__main__.Test
```

从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.__ class__ 则指向类。self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:

### 创建实例对象

实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。以下使用类的名称 Employee 来实例化，并通过 __ init__ 方法接收参数。
```
"创建 Employee 类的第一个对象"
emp1 = Employee("Zara", 2000)
"创建 Employee 类的第二个对象"
emp2 = Employee("Manni", 5000)
```

#### 访问属性

您可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量:
```
emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount
```

你可以添加，删除，修改类的属性，如下所示：
```
emp1.age = 7  # 添加一个 'age' 属性
emp1.age = 8  # 修改 'age' 属性
del emp1.age  # 删除 'age' 属性
```

你也可以使用以下函数的方式来访问属性：

* getattr(obj, name[, default]) : 访问对象的属性。
* setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。
* delattr(obj, name) : 删除属性。

```
hasattr(emp1, 'age') # 如果存在 'age' 属性返回 True。 
getattr(emp1, 'age') # 返回 'age' 属性的值 
setattr(emp1, 'age', 8) # 添加属性 'age' 值为 8 
delattr(emp1, 'age') # 删除属性 'age'
```
#### Python内置类属性

* __ dict__ : 类的属性（包含一个字典，由类的数据属性组成）
* __ doc__ :类的文档字符串
* __ name__: 类名
* __ module__: 类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）
* __ bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）


#### python对象销毁(垃圾回收)

Python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 Python 内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是"立即"的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。
垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。

析构函数 __ del__ ，__del__在对象销毁的时候被调用，当对象不再被使用时，__del__方法运行。


### 类的继承

面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。

继承语法：
```
class 派生类名(基类名)
    ...
```

在python中继承中的一些特点：

1、如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看： python 子类继承父类构造函数说明。
子类不重写 __ init__，实例化子类时，会自动调用父类定义的 __ init__。
如果重写了__init__ 时，实例化子类，就不会调用父类已经定义的 __ init__。
如果重写了__init__ 时，要继承父类的构造方法，可以使用 super 关键字：
```
super(子类，self).__init__(参数1，参数2，....)
```

还有一种经典写法：
```
父类名称.__init__(self,参数1，参数2，...)
```
2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数
3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。


如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" 。
派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：
```
class SubClassName (ParentClass1[, ParentClass2, ...]):
    ...
```

你可以使用issubclass()或者isinstance()方法来检测。

* issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup)
* isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。


#### 基础重载方法

下表列出了一些通用的功能，你可以在自己的类重写：

| 序号 | 方法                          | 描述                                                    |
| ---- | ----------------------------- | ------------------------------------------------------- |
| 1    | __ init__ ( self [,args...] ) | 构造函数简单的调用方法: obj = className(args)           |
| 2    | __ del__( self )              | 析构方法, 删除一个对象简单的调用方法 : del obj          |
| 3    | __ repr__( self )             | 转化为供解释器读取的形式简单的调用方法 : repr(obj)      |
| 4    | __ str__( self )              | 用于将值转化为适于人阅读的形式简单的调用方法 : str(obj) |
| 5    | __ cmp__ ( self, x )          | 对象比较简单的调用方法 : cmp(obj, x)                    |

#### 运算符重载

Python同样支持运算符重载，实例如下：
```

#!/usr/bin/python 
class Vector: 
    def __init__(self, a, b): 
        self.a = a 
        self.b = b 
        
    def __str__(self): 
        return 'Vector (%d, %d)' % (self.a, self.b) 
        
    def __add__(self,other): 
        return Vector(self.a + other.a, self.b + other.b) 
        
v1 = Vector(2,10) 
v2 = Vector(5,-2) 
print v1 + v2
```
以上代码执行结果如下所示:
```
Vector(7,8)
```

#### 类属性与方法

##### 类的私有属性

__ private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__ private_attrs。

##### 类的方法

在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数

##### 类的私有方法

__ private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.__ private_methods

Python不允许实例化的类访问私有数据，但你可以使用 object._ className__attrName（ 对象名._ 类名__私有属性名 ）访问属性，参考以下:
```

#!/usr/bin/python# -*- coding: UTF-8 -*-

class Runoob:
    __site = "www.runoob.com"

runoob = Runoob()
print runoob._Runoob__site
```

**单下划线、双下划线、头尾双下划线说明：**

* __ foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。
* _ foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *
* __ foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。


## Python CGI编程

CGI 目前由 NCSA 维护，NCSA 定义 CGI 如下：CGI(Common Gateway Interface)，通用网关接口，它是一段程序，运行在服务器上如：HTTP 服务器，提供同客户端 HTML 页面的接口。


## Python 多线程

Python中使用线程有两种方式：函数或者用类来包装线程对象。

Python3 线程中常用的两个模块为：

* _ thread
* threading(推荐使用)

函数式：调用thread模块中的start_new_thread()函数来产生新线程。语法如下:
```
_thread.start_new_thread ( function, args[, kwargs] )
```
参数说明:

* function - 线程函数。
* args - 传递给线程函数的参数,他必须是个tuple类型。
* kwargs - 可选参数。

线程的结束一般依靠线程函数的自然结束；也可以在线程函数中调用thread.exit()，他抛出SystemExit exception，达到退出线程的目的。

### 线程模块

Python3 通过两个标准库 _ thread 和 threading 提供对线程的支持。_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。threading 模块除了包含 _ thread 模块中的所有方法外，还提供的其他方法：

* threading.currentThread(): 返回当前的线程变量。
* threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
* threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。

除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:

* run(): 用以表示线程活动的方法。
* start():启动线程活动
* join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。
* isAlive(): 返回线程是否活动的。
* getName(): 返回线程名。
* setName(): 设置线程名。

### 使用 threading 模块创建线程

我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：
```
import threading
import time
exitFlag = 0

class myThread (threading.Thread):    

    def __init__(self, threadID, name, delay):                                                      threading.Thread.__init__(self)        
        self.threadID = threadID        
        self.name = name        
        self.delay = delay    
        
    def run(self):        
        print ("开始线程：" + self.name)        
        print_time(self.name, self.delay, 5)        
        print ("退出线程：" + self.name)
        
def print_time(threadName, delay, counter):    
    while counter:        
    if exitFlag:            
        threadName.exit()        
    time.sleep(delay)        
    print ("%s: %s" % (threadName, time.ctime(time.time())))        
    counter -= 1
    
 # 创建新线程
 thread1 = myThread(1, "Thread-1", 1)
 thread2 = myThread(2, "Thread-2", 2)
 # 开启新线程
 thread1.start()
 thread2.start()
 thread1.join()
 thread2.join()
 print ("退出主线程")
```

### 线程同步
如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。考虑这样一种情况：一个列表里所有元素都是0，线程"set"从后向前把所有元素改成1，而线程"print"负责从前往后读取列表并打印。那么，可能线程"set"开始改的时候，线程"print"便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。锁有两种状态——锁定和未锁定。每当一个线程比如"set"要访问共享数据时，必须先获得锁定；如果已经有别的线程比如"print"获得锁定了，那么就让线程"set"暂停，也就是同步阻塞；等到线程"print"访问完毕，释放锁以后，再让线程"set"继续。经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。
```
import threading
import time
exitFlag = 0

class myThread (threading.Thread):    

    def __init__(self, threadID, name, delay):                                                      threading.Thread.__init__(self)        
        self.threadID = threadID        
        self.name = name        
        self.delay = delay    
        
    def run(self):        
        print ("开始线程：" + self.name)        
        # 获取锁，用于线程同步
        threadLock.acquire()
        print_time(self.name, self.delay, 3)
        # 释放锁，开启下一个线程
        threadLock.release()
        
def print_time(threadName, delay, counter):    
    while counter:        
    if exitFlag:            
        threadName.exit()        
    time.sleep(delay)        
    print ("%s: %s" % (threadName, time.ctime(time.time())))        
    counter -= 1
    
 # 创建新线程
 thread1 = myThread(1, "Thread-1", 1)
 thread2 = myThread(2, "Thread-2", 2)

 threadLock = threading.Lock()
 threads = []
 # 开启新线程thread1.start()
 thread2.start()
 # 添加线程到线程列表
 threads.append(thread1)
 threads.append(thread2)
 # 等待所有线程完成
 for t in threads:    
    t.join()
    
 print ("退出主线程")
```

### 线程优先级队列（ Queue）

Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。Queue 模块中的常用方法:

* Queue.qsize() 返回队列的大小
* Queue.empty() 如果队列为空，返回True,反之False
* Queue.full() 如果队列满了，返回True,反之False
* Queue.full 与 maxsize 大小对应
* Queue.get([block[, timeout]])获取队列，timeout等待时间
* Queue.get_nowait() 相当Queue.get(False)
* Queue.put(item) 写入队列，timeout等待时间
* Queue.put_nowait(item) 相当Queue.put(item, False)
* Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号
* Queue.join() 实际上意味着等到队列为空，再执行别的操作
