<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shenhongwei33.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideDownIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第一章 必读学习算法和刷题的框架思维数据结构的存储方式数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。 这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode">
<meta property="og:url" content="https://shenhongwei33.github.io/2023/01/25/LeetCode/index.html">
<meta property="og:site_name" content="拓荒者的博客">
<meta property="og:description" content="第一章 必读学习算法和刷题的框架思维数据结构的存储方式数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。 这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/LeetCode/%E8%B5%B0K%E6%AD%A5.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF-1.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/LeetCode/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/LeetCode/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-1.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/LeetCode/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-2.png">
<meta property="og:image" content="en-resource://database/2933:1">
<meta property="og:image" content="en-resource://database/2935:1">
<meta property="og:image" content="en-resource://database/2937:1">
<meta property="og:image" content="en-resource://database/2939:1">
<meta property="og:image" content="en-resource://database/2941:1">
<meta property="og:image" content="en-resource://database/2943:1">
<meta property="article:published_time" content="2023-01-25T07:29:20.000Z">
<meta property="article:modified_time" content="2023-01-25T10:26:06.829Z">
<meta property="article:author" content="拓荒者">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shenhongwei33.github.io/2023/01/25/LeetCode/%E8%B5%B0K%E6%AD%A5.png">

<link rel="canonical" href="https://shenhongwei33.github.io/2023/01/25/LeetCode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>LeetCode | 拓荒者的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="拓荒者的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拓荒者的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享自己的学习之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/shenhongwei33" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shenhongwei33.github.io/2023/01/25/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="拓荒者">
      <meta itemprop="description" content="欢迎来到程序猿的世界">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拓荒者的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-25 15:29:20" itemprop="dateCreated datePublished" datetime="2023-01-25T15:29:20+08:00">2023-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-25 18:26:06" itemprop="dateModified" datetime="2023-01-25T18:26:06+08:00">2023-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一章-必读"><a href="#第一章-必读" class="headerlink" title="第一章 必读"></a>第一章 必读</h1><h2 id="学习算法和刷题的框架思维"><a href="#学习算法和刷题的框架思维" class="headerlink" title="学习算法和刷题的框架思维"></a>学习算法和刷题的框架思维</h2><h3 id="数据结构的存储方式"><a href="#数据结构的存储方式" class="headerlink" title="数据结构的存储方式"></a>数据结构的存储方式</h3><p><strong>数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。</strong></p>
<p>这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。</p>
<p>比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。<br><strong>图</strong>的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。</p>
<p><strong>散列表</strong>就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</p>
<p><strong>树</strong>，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。</p>
<p>了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。</p>
<p>综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下：</p>
<ul>
<li><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。</li>
<li><strong>链表</strong>因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</li>
</ul>
<h3 id="数据结构的基本操作"><a href="#数据结构的基本操作" class="headerlink" title="数据结构的基本操作"></a>数据结构的基本操作</h3><p>对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。</p>
<p><strong>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。</strong></p>
<p>如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。线性就是 for/while 迭代为代表，非线性就是递归为代表。再具体一步，无非以下几种框架：</p>
<h4 id="数组遍历框架，典型的线性迭代结构"><a href="#数组遍历框架，典型的线性迭代结构" class="headerlink" title="数组遍历框架，典型的线性迭代结构"></a>数组遍历框架，典型的线性迭代结构</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">int</span>[] arr)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">        <span class="comment">// 迭代访问 arr[i]  </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表遍历框架，兼具迭代和递归结构"><a href="#链表遍历框架，兼具迭代和递归结构" class="headerlink" title="链表遍历框架，兼具迭代和递归结构"></a>链表遍历框架，兼具迭代和递归结构</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的单链表节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    ListNode <span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> traverse(ListNode head) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ListNode p = head; p != <span class="literal">null</span>; p = p.<span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="comment">// 迭代访问 p.val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> traverse(ListNode head) &#123;</span><br><span class="line">    <span class="comment">// 递归访问 head.val</span></span><br><span class="line">    traverse(head.<span class="keyword">next</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树遍历框架，典型的非线性递归遍历结构"><a href="#二叉树遍历框架，典型的非线性递归遍历结构" class="headerlink" title="二叉树遍历框架，典型的非线性递归遍历结构"></a>二叉树遍历框架，典型的非线性递归遍历结构</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的二叉树节点 */</span></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode <span class="attribute">left</span>, <span class="attribute">right</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="built_in">traverse</span>(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看二叉树的递归遍历方式和链表的递归遍历方式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多几条叉，N 叉树你会不会遍历？</p>
<h4 id="二叉树框架可以扩展为-N-叉树的遍历框架"><a href="#二叉树框架可以扩展为-N-叉树的遍历框架" class="headerlink" title="二叉树框架可以扩展为 N 叉树的遍历框架"></a>二叉树框架可以扩展为 N 叉树的遍历框架</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的 N 叉树节点 */</span></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode<span class="selector-attr">[]</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="built_in">traverse</span>(TreeNode root) &#123;</span><br><span class="line">    for (TreeNode child : root.children)</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>N 叉树的遍历又可以扩展为图的遍历，因为图就是好几 N 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，这里就不写代码了。</p>
<p><strong>所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，</strong>你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了，下面会具体举例。</p>
<h3 id="算法刷题指南"><a href="#算法刷题指南" class="headerlink" title="算法刷题指南"></a>算法刷题指南</h3><p>首先要明确的是，数据结构是工具，算法是通过合适的工具解决特定问题的方法。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。<br>所以我建议的刷题顺序是：</p>
<ol>
<li>先学习像数组、链表这种基本数据结构的常用算法，比如单链表翻转，前缀和数组，二分搜索等。因为这些算法属于会者不难难者不会的类型，难度不大，学习它们不会花费太多时间。而且这些小而美的算法经常让你大呼精妙，能够有效培养你对算法的兴趣。</li>
<li>学会基础算法之后，不要急着上来就刷回溯算法、动态规划这类笔试常考题，而应该<strong>先刷二叉树，先刷二叉树，先刷二叉树</strong>，重要的事情说三遍。为什么要先刷二叉树呢，因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">traverse</span>(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。力扣第 124 题，难度困难，让你求二叉树中最大路径和，主要代码如下：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> res = Integer.MIN_VALUE;</span><br><span class="line"><span class="built_in">int</span> one<span class="constructor">SideMax(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root<span class="operator"> == </span>null) return <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> left = max(<span class="number">0</span>, one<span class="constructor">SideMax(<span class="params">root</span>.<span class="params">left</span>)</span>);</span><br><span class="line">    <span class="built_in">int</span> right = max(<span class="number">0</span>, one<span class="constructor">SideMax(<span class="params">root</span>.<span class="params">right</span>)</span>);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    res = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(res, left + right + root.<span class="keyword">val</span>);</span><br><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(left, right) + root.<span class="keyword">val</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意递归函数的位置，这就是个后序遍历嘛，无非就是把 traverse 函数名字改成 oneSideMax 了。</li>
</ol>
<p>对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，你就会发现<strong>只要涉及递归的问题，都是树的问题</strong>。</p>
<p>其实很多动态规划问题就是在遍历一棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。</p>
<p>再看看回溯算法，前文回溯算法详解干脆直接说了，回溯算法就是个 N 叉树的前后序遍历问题，没有例外。比如全排列问题吧，本质上全排列就是在遍历下面这棵树，到叶子节点的路径就是一个全排列。</p>
<p>综上，对于畏惧算法的同学来说，<strong>可以先刷树的相关题目，试着从框架上看问题，而不要纠结于细节问题。</strong></p>
<h2 id="刷题心得"><a href="#刷题心得" class="headerlink" title="刷题心得"></a>刷题心得</h2><h3 id="算法的本质"><a href="#算法的本质" class="headerlink" title="算法的本质"></a>算法的本质</h3><p>如果要让我一句话总结，我想说算法的本质就是<strong>穷举</strong>。</p>
<p>例外肯定是有的，比如前几天我还发了 一行代码就能解决的算法题，这些题目都是通过观察，发现规律，然后找到最优解法。再比如数学相关的算法，很多都是数学推论，然后用编程的形式表现出来了，所以它本质是数学，不是计算机算法。<br>从计算机算法的角度，结合我们大多数人的需求，这种秀智商的纯技巧题目绝对占少数，虽然很容易让人大呼精妙，但不能提炼出思考算法题的通用思维，真正通用的思维反而大道至简，就是穷举。</p>
<p>对计算机算法的误解也许是以前学数学留下的「后遗症」，数学题一般都是你仔细观察，找几何关系，列方程，然后算出答案。如果说你需要进行大规模穷举来寻找答案，那大概率是你的解题思路出问题了。而计算机解决问题的思维恰恰相反，有没有什么数学公式就交给你们人类去推导吧，如果能找到一些巧妙的定理那最好，但如果找不到，那就穷举呗，反正只要复杂度允许，没有什么答案是穷举不出来的。<br>技术岗笔试面试考的那些算法题，求个最大值最小值什么的，你怎么求？必须得把所有可行解穷举出来才能找到最值。</p>
<p>但是，你千万不要觉得穷举这个事儿很简单，<strong>穷举有两个关键难点：无遗漏、无冗余。</strong></p>
<p>遗漏，会直接导致答案出错；冗余，会拖慢算法的运行速度。所以，当你看到一道算法题，可以从这两个维度去思考：</p>
<ol>
<li><strong>如何穷举？即无遗漏地穷举所有可能解。</strong></li>
<li><strong>如何聪明地穷举？即避免所有冗余的计算。</strong></li>
</ol>
<p>不同类型的题目，难点是不同的，有的题目难在<strong>如何穷举</strong>，有的题目难在<strong>如何聪明地穷举</strong>。</p>
<p>什么算法的难点在<strong>如何穷举</strong>呢？<strong>一般是递归类问题，最典型的就是动态规划系列问题。</strong></p>
<p>前文 动态规划核心套路 阐述了动态规划系列问题的核心原理，无非就是先写出暴力穷举解法（状态转移方程），加个备忘录就成自顶向下的递归解法了，再改一改就成自底向上的递推迭代解法了， 动态规划的降维打击 里也讲过如何分析优化动态规划算法的空间复杂度。<br>上述过程就是在不断优化算法的时间、空间复杂度，也就是所谓如何聪明地穷举，这些技巧一听就会了。但很多读者留言说明白了这些原理，遇到动态规划题目还是不会做，因为第一步的暴力解法都写不出来。<br>这很正常，因为动态规划类型的题目可以千奇百怪，找状态转移方程才是难点，所以才有了 动态规划设计方法：数学归纳法 这篇文章，告诉你递归穷举的核心是数学归纳法，明确函数的定义，然后利用这个定义写递归函数，就可以穷举出所有可行解。</p>
<p>什么算法的难点在<strong>如何聪明地穷举</strong>呢？一些耳熟能详的非递归算法技巧，都可以归在这一类。</p>
<h1 id="第一章、手把手刷数据结构"><a href="#第一章、手把手刷数据结构" class="headerlink" title="第一章、手把手刷数据结构"></a>第一章、手把手刷数据结构</h1><h2 id="手把手刷链表算法"><a href="#手把手刷链表算法" class="headerlink" title="手把手刷链表算法"></a>手把手刷链表算法</h2><h3 id="双指针技巧秒杀七道链表题目"><a href="#双指针技巧秒杀七道链表题目" class="headerlink" title="双指针技巧秒杀七道链表题目"></a>双指针技巧秒杀七道链表题目</h3><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>给你输入两个有序链表，请你把他俩合并成一个新的有序链表，函数签名如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;</span><br><span class="line">        ListNode temp = new ListNode(-1),<span class="attribute">p</span>=temp;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">null</span> &amp;&amp; list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">                p.<span class="attribute">next</span>=list1;</span><br><span class="line">                <span class="attribute">list1</span>=list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p.<span class="attribute">next</span>=list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">p</span>=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.<span class="attribute">next</span>=list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p.<span class="attribute">next</span>=list2;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们的 while 循环每次比较 p1 和 p2 的大小，把较小的节点接到结果链表上，这个算法的逻辑类似于「拉拉链」，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并。<br>代码中还用到一个链表的算法题中是很常见的<strong>虚拟头结点</strong>技巧，也就是 <strong>dummy 节点。你可以试试，如果不使用 dummy 虚拟节点，代码会复杂很多，</strong>而有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p>
<h4 id="合并-k-个有序链表"><a href="#合并-k-个有序链表" class="headerlink" title="合并 k 个有序链表"></a>合并 k 个有序链表</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        ListNode node = pq.poll();</span><br><span class="line">        p.<span class="keyword">next</span> = node;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="keyword">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            pq.add(node.<span class="keyword">next</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并 k 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 k 个节点中的最小节点，接到结果链表上？这里我们就要用到 <strong>优先级队列</strong>（二叉堆） 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点：<br>优先队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N 是这些链表的节点总数。</p>
<h4 id="单链表的倒数第-k-个节点"><a href="#单链表的倒数第-k-个节点" class="headerlink" title="单链表的倒数第 k 个节点"></a>单链表的倒数第 k 个节点</h4><p>首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步：</p>
<p><img src="/2023/01/25/LeetCode/%E8%B5%B0K%E6%AD%A5.png"></p>
<p>现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？趁这个时候，再用一个指针 p2 指向链表头节点 head：<br>![](LeetCode/单链表的倒数第 k 个节点.png)</p>
<p>接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时前进了 n - k 步，p2 也从 head 开始前进了 n - k 步，停留在第 n - k + 1 个节点上，即恰好停链表的倒数第 k 个节点上：<br>![](LeetCode/单链表的倒数第 k 个节点-1.png)</p>
<p>这样，只遍历了一次链表，就获得了倒数第 k 个节点 p2。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"><span class="symbol">ListNode</span> findFromEnd(ListNode head, int k) &#123;</span><br><span class="line">    ListNode <span class="built_in">p1</span> = head<span class="comment">;</span></span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    for (int i = <span class="number">0</span><span class="comment">; i &lt; k; i++) &#123;</span></span><br><span class="line">        <span class="built_in">p1</span> = <span class="built_in">p1</span>.next<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode <span class="built_in">p2</span> = head<span class="comment">;</span></span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="meta">while</span> (<span class="built_in">p1</span> != null) &#123;</span><br><span class="line">        <span class="built_in">p2</span> = <span class="built_in">p2</span>.next<span class="comment">;</span></span><br><span class="line">        <span class="built_in">p1</span> = <span class="built_in">p1</span>.next<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k 个节点</span></span><br><span class="line">    return <span class="built_in">p2</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除单链表的第K个节点"><a href="#删除单链表的第K个节点" class="headerlink" title="删除单链表的第K个节点"></a>删除单链表的第K个节点</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">public ListNode remove<span class="constructor">NthFromEnd(ListNode <span class="params">head</span>, <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> <span class="constructor">ListNode(-1)</span>;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span></span><br><span class="line">    ListNode x = find<span class="constructor">FromEnd(<span class="params">dummy</span>, <span class="params">n</span> + 1)</span>;</span><br><span class="line">    <span class="comment">// 删掉倒数第 n 个节点</span></span><br><span class="line">    x.next = x.next.next;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> ListNode find<span class="constructor">FromEnd(ListNode <span class="params">head</span>, <span class="params">int</span> <span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个逻辑就很简单了，要删除倒数第 n 个节点，就得获得倒数第 n + 1 个节点的引用，可以用我们实现的 findFromEnd 来操作。</p>
<p><strong>不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。</strong></p>
<h4 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h4><p>问题的关键也在于我们无法直接得到单链表的长度 n，常规方法也是先遍历链表计算 n，再遍历一次得到第 n / 2 个节点，也就是中间节点。</p>
<p>如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：<br>我们让两个指针 slow 和 fast 分别指向链表头结点 head。<strong>每当慢指针 slow 前进一步，快指针 fast 就前进两步</strong>，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。上述思路的代码实现如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode middleNode(ListNode head) &#123;</span><br><span class="line">    <span class="regexp">//</span> 快慢指针初始化指向 head</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="regexp">//</span> 快指针走到末尾时停止</span><br><span class="line">    <span class="keyword">while</span> (head != null &amp;&amp; head.<span class="keyword">next</span> != null) &#123;</span><br><span class="line">        <span class="regexp">//</span> 慢指针走一步，快指针走两步</span><br><span class="line">        slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        head = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="regexp">//</span> 慢指针指向中点</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。</p>
<h4 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h4><p>判断链表是否包含环属于经典问题了，解决方案也是用<strong>快慢指针</strong>：每当慢指针 slow 前进一步，快指针 fast 就前进两步。<strong>如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环</strong>。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span> hasCycle(ListNode head) &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.<span class="keyword">next</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        fast = fast.<span class="keyword">next</span>;</span><br><span class="line">        slow = slow.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。<br>我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：<br><img src="/2023/01/25/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF.png"></p>
<p>fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的<strong>整数倍</strong>。</p>
<p>假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：<br><img src="/2023/01/25/LeetCode/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF-1.png"></p>
<p>所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。</p>
<h4 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h4><p>给你输入两个链表的头结点 headA 和 headB，这两个链表可能存在相交。如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。<br><img src="/2023/01/25/LeetCode/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4.png"></p>
<p>那么我们的算法应该返回 c1 这个节点。这个题直接的想法可能是用 HashSet 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p>
<p>如果不用额外的空间，只使用两个指针，你如何做呢？难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：<br><img src="/2023/01/25/LeetCode/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-1.png"></p>
<p>如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。</p>
<p>解决这个问题的关键是，<strong>通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1</strong>。<br>所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：<br><img src="/2023/01/25/LeetCode/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-2.png"></p>
<p>那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ListNode</span> getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    ListNode <span class="built_in">p1</span> = headA, <span class="built_in">p2</span> = headB<span class="comment">;</span></span><br><span class="line">    <span class="meta">while</span> (<span class="built_in">p1</span> != <span class="built_in">p2</span>) &#123;</span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="meta">if</span> (<span class="built_in">p1</span> == null) <span class="built_in">p1</span> = headB<span class="comment">;</span></span><br><span class="line">        <span class="meta">else</span>            <span class="built_in">p1</span> = <span class="built_in">p1</span>.next<span class="comment">;</span></span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="meta">if</span> (<span class="built_in">p2</span> == null) <span class="built_in">p2</span> = headA<span class="comment">;</span></span><br><span class="line">        <span class="meta">else</span>            <span class="built_in">p2</span> = <span class="built_in">p2</span>.next<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归魔法：反转单链表"><a href="#递归魔法：反转单链表" class="headerlink" title="递归魔法：反转单链表"></a>递归魔法：反转单链表</h3><h4 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h4><p>递归反转单链表的算法：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点</span><br><span class="line">ListNode<span class="built_in"> reverse</span>(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">(head</span> == null ||<span class="built_in"> head</span>.<span class="keyword">next</span> == null) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode<span class="built_in"> last</span> =<span class="built_in"> reverse</span><span class="built_in">(head</span>.<span class="keyword">next</span>);</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span>.<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span> = null;</span><br><span class="line">    <span class="keyword">return</span><span class="built_in"> last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于递归算法，最重要的就是明确递归函数的定义。具体来说，我们的 reverse 函数定义是这样的：输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。<br>那么输入 reverse(head) 后，会在这里进行递归：<br><code>ListNode last = reverse(head.next);</code><br><img src="en-resource://database/2933:1" alt="72b54c3992c6c1cff6df7344c6193b82.png"></p>
<p>这个 reverse(head.next) 执行完成后，整个链表就成了这样<br><img src="en-resource://database/2935:1" alt="e8accd1505f8962b99fe9ae7e3946d66.png"></p>
<p>并且根据函数定义，reverse 函数会返回反转之后的头结点，我们用变量 last 接收了。现在再来看下面的代码：<code>head.next.next = head;</code><br><img src="en-resource://database/2937:1" alt="85db63b0d9ffcd5d1471728ed2ce7d09.png"></p>
<p>接下来：<code>head.next = null; return last;</code><br><img src="en-resource://database/2939:1" alt="772d8d8b2dd340eb92b0d5c5b84f4e6b.png"></p>
<p>不过其中有两个地方需要注意：</p>
<ol>
<li><p>递归函数要有 base case，也就是这句：<code>if (head == null || head.next == null) &#123;  return head;  &#125;  </code><br> 意思是如果链表为空或者只有一个节点的时候，反转结果就是它自己，直接返回即可。</p>
</li>
<li><p>当链表递归反转之后，新的头结点是 last，而之前的 head 变成了最后一个节点，别忘了链表的末尾要指向 null：</p>
</li>
</ol>
<p>此外还可以通过栈的数据结构反转：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span><span class="built_in">(head</span> == null)&#123;</span><br><span class="line">            <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack<span class="language-xml"><span class="tag">&lt;<span class="name">ListNode</span>&gt;</span> stack = new Stack</span><span class="language-xml"><span class="tag">&lt;<span class="name">ListNode</span>&gt;</span>();</span></span><br><span class="line"><span class="language-xml">        while(head != null)</span><span class="language-xquery">&#123;</span></span><br><span class="line"><span class="language-xquery">            stack.push<span class="built_in">(head</span>);</span></span><br><span class="line"><span class="language-xquery">           <span class="built_in"> head</span> =<span class="built_in"> head</span>.<span class="keyword">next</span>;</span></span><br><span class="line"><span class="language-xquery">        &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        head = stack.pop();</span></span><br><span class="line"><span class="language-xml">        ListNode temp = head;</span></span><br><span class="line"><span class="language-xml">        while (!stack.isEmpty())</span><span class="language-xquery">&#123;</span></span><br><span class="line"><span class="language-xquery">           <span class="built_in"> head</span>.<span class="keyword">next</span>=stack.pop();</span></span><br><span class="line"><span class="language-xquery">           <span class="built_in"> head</span> =<span class="built_in"> head</span>.<span class="keyword">next</span>;</span></span><br><span class="line"><span class="language-xquery">           <span class="built_in"> head</span>.<span class="keyword">next</span>=null;</span></span><br><span class="line"><span class="language-xquery">        &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        return temp;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br></pre></td></tr></table></figure>
<p>也是需要注意置空（head.next=null;），防止链表的下一节点指向原来的节点而陷入循环。</p>
<h4 id="反转链表前-N-个节点"><a href="#反转链表前-N-个节点" class="headerlink" title="反转链表前 N 个节点"></a>反转链表前 N 个节点</h4><p>比如说对于下图链表，执行 reverseN(head, 3)：<br><img src="en-resource://database/2941:1" alt="32a29e167d8ec2fff0f93dab796a9890.png"></p>
<p>解决思路和反转整个链表差不多，只要稍加修改即可：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode successor = null; // 后驱节点</span><br><span class="line"></span><br><span class="line">// 反转以<span class="built_in"> head</span> 为起点的 n 个节点，返回新的头结点</span><br><span class="line">ListNode reverseN(ListNode<span class="built_in"> head</span>, int n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        // 记录第 n + <span class="number">1</span> 个节点</span><br><span class="line">        successor =<span class="built_in"> head</span>.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // 以<span class="built_in"> head</span>.<span class="keyword">next</span> 为起点，需要反转前 n - <span class="number">1</span> 个节点</span><br><span class="line">    ListNode<span class="built_in"> last</span> = reverseN<span class="built_in">(head</span>.<span class="keyword">next</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span>.<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">    // 让反转之后的<span class="built_in"> head</span> 节点和后面的节点连起来</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span> = successor;</span><br><span class="line">    <span class="keyword">return</span><span class="built_in"> last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的区别：</p>
<ol>
<li>base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。</li>
<li>刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。</li>
</ol>
<p><img src="en-resource://database/2943:1" alt="17a0220408c42f2cea4e4c53dca8a423.png"></p>
<h4 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h4><p>现在解决我们最开始提出的问题，给一个索引区间 [m, n]（索引从 1 开始），仅仅反转区间中的链表元素。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverse<span class="constructor">Between(ListNode <span class="params">head</span>, <span class="params">int</span> <span class="params">m</span>, <span class="params">int</span> <span class="params">n</span>)</span></span><br></pre></td></tr></table></figure>

<p>首先，如果 m == 1，就相当于反转链表开头的 n 个元素嘛，也就是我们刚才实现的功能：</p>
<p>如果 m != 1 怎么办？如果我们把 head 的索引视为 1，那么我们是想从第 m 个元素开始反转对吧；如果把 head.next 的索引视为 1 呢？那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的；那么对于 head.next.next 呢……</p>
<p>区别于迭代思想，这就是递归思想，所以我们可以完成代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverse<span class="constructor">Between(ListNode <span class="params">head</span>, <span class="params">int</span> <span class="params">m</span>, <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (m<span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">        return reverse<span class="constructor">N(<span class="params">head</span>, <span class="params">n</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.next = reverse<span class="constructor">Between(<span class="params">head</span>.<span class="params">next</span>, <span class="params">m</span> - 1, <span class="params">n</span> - 1)</span>;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何-K-个一组反转链表"><a href="#如何-K-个一组反转链表" class="headerlink" title="如何 K 个一组反转链表"></a>如何 K 个一组反转链表</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/25/django/" rel="prev" title="django">
      <i class="fa fa-chevron-left"></i> django
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BF%85%E8%AF%BB"><span class="nav-number">1.</span> <span class="nav-text">第一章 必读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%B7%E9%A2%98%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4"><span class="nav-number">1.1.</span> <span class="nav-text">学习算法和刷题的框架思维</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据结构的存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.2.</span> <span class="nav-text">数据结构的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%85%B8%E5%9E%8B%E7%9A%84%E7%BA%BF%E6%80%A7%E8%BF%AD%E4%BB%A3%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">数组遍历框架，典型的线性迭代结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%85%BC%E5%85%B7%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">链表遍历框架，兼具迭代和递归结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%85%B8%E5%9E%8B%E7%9A%84%E9%9D%9E%E7%BA%BF%E6%80%A7%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">二叉树遍历框架，典型的非线性递归遍历结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A1%86%E6%9E%B6%E5%8F%AF%E4%BB%A5%E6%89%A9%E5%B1%95%E4%B8%BA-N-%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%A1%86%E6%9E%B6"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">二叉树框架可以扩展为 N 叉树的遍历框架</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97"><span class="nav-number">1.1.3.</span> <span class="nav-text">算法刷题指南</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97"><span class="nav-number">1.2.</span> <span class="nav-text">刷题心得</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">算法的本质</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E6%89%8B%E6%8A%8A%E6%89%8B%E5%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">第一章、手把手刷数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E6%8A%8A%E6%89%8B%E5%88%B7%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">手把手刷链表算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E7%A7%92%E6%9D%80%E4%B8%83%E9%81%93%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE"><span class="nav-number">2.1.1.</span> <span class="nav-text">双指针技巧秒杀七道链表题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">合并两个有序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">合并 k 个有序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">单链表的倒数第 k 个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.1.3.1.</span> <span class="nav-text">删除单链表的第K个节点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">单链表的中点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">判断链表是否包含环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">两个链表是否相交</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E9%AD%94%E6%B3%95%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">递归魔法：反转单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">递归反转整个链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8D-N-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">反转链表前 N 个节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">反转链表的一部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.3.</span> <span class="nav-text">如何 K 个一组反转链表</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="拓荒者"
      src="/images/touxiang.png">
  <p class="site-author-name" itemprop="name">拓荒者</p>
  <div class="site-description" itemprop="description">欢迎来到程序猿的世界</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/shenhongwei33" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenhongwei33" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/shenhongweihhu@163.com" title="E-Mail → shenhongweihhu@163.com">E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">拓荒者</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">226k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:41</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : '[object Object]',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://shenhongwei33.github.io/2023/01/25/LeetCode/',]
      });
      });
  </script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7caf102ae14da863e229',
      clientSecret: '36112d33a0c873b4a9f2ea922f01b889256554a1',
      repo        : 'shenhongwei33.GitHub.io',
      owner       : 'shenhongwei33',
      admin       : ['shenhongwei33'],
      id          : '643a673986c68d959c50f3503e501edf',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
