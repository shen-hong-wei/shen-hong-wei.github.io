<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shenhongwei33.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideDownIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="开发环境go的安装 安装 mercurial、git、gcc包 1[root@localhost ~]# yum install mercurial git gcc 下载Go的压缩包  用tar 命令来解压压缩包。 1tar -zxvf go1.13.linux-amd64.tar.gz 建立Go的工作空间（workspace，也就是GOPATH环境变量指向的目录），GO代码必须在工作空间内。工作">
<meta property="og:type" content="article">
<meta property="og:title" content="go基础">
<meta property="og:url" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="拓荒者的博客">
<meta property="og:description" content="开发环境go的安装 安装 mercurial、git、gcc包 1[root@localhost ~]# yum install mercurial git gcc 下载Go的压缩包  用tar 命令来解压压缩包。 1tar -zxvf go1.13.linux-amd64.tar.gz 建立Go的工作空间（workspace，也就是GOPATH环境变量指向的目录），GO代码必须在工作空间内。工作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-1.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-2.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-3.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/make%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E5%9C%B0%E5%9D%80%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93.png">
<meta property="og:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/%E9%80%9A%E9%81%93%E6%80%BB%E7%BB%93.png">
<meta property="article:published_time" content="2023-01-25T02:14:41.000Z">
<meta property="article:modified_time" content="2023-01-25T02:50:29.664Z">
<meta property="article:author" content="拓荒者">
<meta property="article:tag" content="go基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-1.png">

<link rel="canonical" href="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>go基础 | 拓荒者的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="拓荒者的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拓荒者的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享自己的学习之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/shenhongwei33" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.png">
      <meta itemprop="name" content="拓荒者">
      <meta itemprop="description" content="欢迎来到程序猿的世界">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拓荒者的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-25 10:14:41" itemprop="dateCreated datePublished" datetime="2023-01-25T10:14:41+08:00">2023-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-25 10:50:29" itemprop="dateModified" datetime="2023-01-25T10:50:29+08:00">2023-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/01/25/go%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/01/25/go%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>40k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:24</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="go的安装"><a href="#go的安装" class="headerlink" title="go的安装"></a>go的安装</h2><ul>
<li><p>安装 mercurial、git、gcc包</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum install mercurial git gcc</span></span><br></pre></td></tr></table></figure></li>
<li><p>下载Go的压缩包</p>
</li>
<li><p>用tar 命令来解压压缩包。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf go1.<span class="number">13</span><span class="selector-class">.linux-amd64</span><span class="selector-class">.tar</span>.gz</span><br></pre></td></tr></table></figure></li>
<li><p>建立Go的工作空间（workspace，也就是GOPATH环境变量指向的目录），GO代码必须在工作空间内。工作空间是一个目录，其中包含三个子目录：<br>src —- 里面每一个子目录，就是一个包。包内是Go的源码文件<br>pkg —- 编译后生成的，包的目标文件<br>bin —- 生成的可执行文件</p>
</li>
</ul>
<p>这里，我们在/home目录下, 建立一个名为go(可以不是go, 任意名字都可以)的文件夹， 然后再建立三个子文件夹(子文件夹名必须为src、pkg、bin)。</p>
<ul>
<li>添加PATH环境变量and设置GOPATH环境变量<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="keyword">go</span>]# <span class="keyword">vi</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure>
加入下面这三行:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">GOROOT</span>=/usr/local/go        ##Golang安装目录</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$GOROOT</span>/bin:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">GOPATH</span>=/home/go  ##Golang项目目录</span><br></pre></td></tr></table></figure></li>
</ul>
<p>保存后，执行以下命令，使环境变量立即生效:</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost go]# source /etc/profile ##刷新环境变量</span><br></pre></td></tr></table></figure>
<p>至此，Go语言的环境已经安装完毕。</p>
<ul>
<li>验证一下是否安装成功，如果出现下面的信息说明安装成功了</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="keyword">go</span>]# <span class="keyword">go</span> <span class="keyword">version</span>        ##查看<span class="keyword">go</span>版本</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">version</span> go1.<span class="number">13</span> linux/amd64</span><br></pre></td></tr></table></figure>

<ul>
<li>查看Go语言的环境信息</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> go]<span class="meta"># go env</span></span><br></pre></td></tr></table></figure>
<p>防止go下载依赖较慢，可设置代理：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go env -w <span class="attribute">GOPROXY</span>=https://goproxy.cn,direct</span><br><span class="line">go env -w  <span class="attribute">GO111MODULE</span>=on</span><br><span class="line">go env -w <span class="attribute">GOARCH</span>=amd64</span><br></pre></td></tr></table></figure>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>需要在环境变量中设置GOPATH<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-1.png"><br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-2.png"><br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/GOPATH-3.png"></p>
<h2 id="配置GOPATH"><a href="#配置GOPATH" class="headerlink" title="配置GOPATH"></a>配置GOPATH</h2><p>GOPATH是一个环境变量，用来表明你写的go项目的存放路径。<br>GOPATH路径最好只设置一个，所有的项目代码都放到GOPATH的src目录下。</p>
<h3 id="go的项目目录"><a href="#go的项目目录" class="headerlink" title="go的项目目录"></a>go的项目目录</h3><p>在进行Go语言开发的时候，我们的代码总是会保存在$GOPATH/src目录下。在工程经过go build、go install或go get等指令后，会将下载的第三方包源代码文件放在$GOPATH/src目录下， 产生的二进制可执行文件放在 $GOPATH/bin目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加$GOPATH/src目录的源代码即可。bin 和 pkg 目录的内容无需版本控制。</p>
<h3 id="目前流行的项目结构"><a href="#目前流行的项目结构" class="headerlink" title="目前流行的项目结构"></a>目前流行的项目结构</h3><p>Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用顶级域名来作为包名的前缀，这样就不担心项目名冲突的问题了。因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的github用户名来区分不同的包。<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p>
<h1 id="go基础"><a href="#go基础" class="headerlink" title="go基础"></a>go基础</h1><h2 id="Go语言的主要特征"><a href="#Go语言的主要特征" class="headerlink" title="Go语言的主要特征"></a>Go语言的主要特征</h2><p>1.自动立即回收。<br>2.更丰富的内置类型。<br>3.函数多返回值。<br>4.错误处理。<br>5.匿名函数和闭包。<br>6.类型和接口。<br>7.并发编程。<br>8.反射。<br>9.语言交互性。</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>Less can be more 大道至简,小而蕴真 让事情变得复杂很容易，让事情变得简单才难 深刻的工程文化</p>
<h3 id="Go语言命名"><a href="#Go语言命名" class="headerlink" title="Go语言命名"></a>Go语言命名</h3><p>Go的函数、变量、常量、自定义类型、包(package)的命名方式遵循以下规则：</p>
<ol>
<li>首字符可以是任意的Unicode字符或者下划线</li>
<li>剩余字符可以是Unicode字符、下划线、数字</li>
<li>字符长度不限</li>
</ol>
<p>Go只有25个关键字：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">break</span>           <span class="keyword">default</span>         func            <span class="keyword">interface</span>       <span class="symbol">select</span></span><br><span class="line"><span class="symbol">case</span>             <span class="symbol">defer</span>            <span class="symbol">go</span>               <span class="symbol">map</span>              <span class="symbol">struct</span></span><br><span class="line"><span class="symbol">chan</span>            <span class="symbol">else</span>              <span class="symbol">goto</span>            <span class="symbol">package</span>       <span class="symbol">switch</span></span><br><span class="line"><span class="symbol">const</span>           <span class="symbol">fallthrough</span>   <span class="symbol">if</span>                 <span class="symbol">range</span>           <span class="symbol">type</span></span><br><span class="line"><span class="symbol">continue</span>     <span class="symbol">for</span>                <span class="symbol">import</span>         <span class="symbol">return</span>           <span class="symbol">var</span></span><br></pre></td></tr></table></figure>

<p>Go还有37个保留字：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">Types:    <span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span>  </span><br><span class="line">              <span class="type">uint</span>  <span class="type">uint8</span>  <span class="type">uint16</span>  <span class="type">uint32</span>  <span class="type">uint64</span>  <span class="type">uintptr</span></span><br><span class="line">              <span class="type">float32</span>  <span class="type">float64</span>  <span class="type">complex128</span>  <span class="type">complex64</span></span><br><span class="line">              <span class="type">bool</span>  <span class="type">byte</span>  <span class="type">rune</span>  <span class="type">string</span>  <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">                 <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">                 <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>

<p>可见性：</p>
<ol>
<li>声明在函数内部，是函数的本地值，类似private</li>
<li>声明在函数外部，是对当前包可见(包内所有.go文件都可见)的全局值，类似protect</li>
<li>声明在函数外部且首字母大写是所有包可见的全局值,类似public</li>
</ol>
<h3 id="Go语言声明"><a href="#Go语言声明" class="headerlink" title="Go语言声明"></a>Go语言声明</h3><p>有四种主要声明方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>（声明变量）, <span class="keyword">const</span>（声明常量）, <span class="keyword">type</span>（声明类型） ,<span class="function"><span class="keyword">func</span>（声明函数）。</span></span><br></pre></td></tr></table></figure>
<p>Go的程序是保存在多个.go文件中，文件的第一行就是package XXX声明，用来说明该文件属于哪个包(package)，package声明下来就是import声明，再下来是类型，变量，常量，函数的声明。</p>
<h3 id="Go项目构建及编译"><a href="#Go项目构建及编译" class="headerlink" title="Go项目构建及编译"></a>Go项目构建及编译</h3><p>一个Go工程中主要包含以下三个目录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src：源代码文件</span><br><span class="line">pkg：包文件</span><br><span class="line"><span class="built_in">bin</span>：相关<span class="built_in">bin</span>文件</span><br></pre></td></tr></table></figure>

<ol>
<li>建立工程文件夹 goproject</li>
<li>在工程文件夹中建立src,pkg,bin文件夹</li>
<li>在GOPATH中添加projiect路径 例 e:/goproject</li>
<li>如工程中有自己的包examplepackage，那在src文件夹下建立以包名命名的文件夹 例 examplepackage</li>
<li>在src文件夹下编写主程序代码代码 goproject.go</li>
<li>在examplepackage文件夹中编写 examplepackage.go 和 包测试文件 examplepackage_test.go</li>
<li>编译调试包<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build examplepackage</span><br><span class="line"><span class="keyword">go</span> test examplepackage</span><br><span class="line"><span class="keyword">go</span> install examplepackage</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这时在pkg文件夹中可以发现会有一个相应的操作系统文件夹如windows_386z, 在这个文件夹中会有examplepackage文件夹，在该文件中有examplepackage.a文件</p>
<ol start="8">
<li>编译主程序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build goproject.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
成功后会生成goproject.exe文件，至此一个Go工程编辑成功。</li>
</ol>
<h3 id="go-编译问题"><a href="#go-编译问题" class="headerlink" title="go 编译问题"></a>go 编译问题</h3><p>golang的编译使用命令 go build , go install;除非仅写一个main函数，否则还是准备好目录结构； GOPATH=工程根目录；其下应创建src，pkg，bin目录，bin目录中用于生成可执行文件，pkg目录中用于生成.a文件； golang中的import name，实际是到GOPATH中去寻找name.a, 使用时是该name.a的源码中生命的package 名字；这个在前面已经介绍过了。<br>注意点：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.系统编译时 go install abc_name时，系统会到GOPATH的src目录中寻找abc_name目录，然后编译其下的go文件；</span><br><span class="line">    <span class="number">2</span>.同一个目录中所有的go文件的<span class="keyword">package</span>声明必须相同，所以main方法要单独放一个文件，否则在eclipse和liteide中都会报错；</span><br><span class="line">    编译报错如下：（假设test目录中有个main.go 和mymath.go,其中main.go声明<span class="keyword">package</span>为main，mymath.go声明packag 为test);</span><br><span class="line">        $ go install test</span><br><span class="line">        can<span class="symbol">&#x27;t</span> load <span class="keyword">package</span>: <span class="keyword">package</span> <span class="title">test: found packages main (main.go) and test (mymath.go) in /home/wanjm/go/src/test</span></span><br><span class="line">        报错说 不能加载<span class="keyword">package</span> <span class="title">test（这是命令行的参数），因为发现了两个<span class="keyword">package</span>，分别时main.go 和 mymath.go;</span></span><br><span class="line">    <span class="number">3</span>.对于main方法，只能在bin目录下运行 go build path_tomain.go; 可以用-o参数指出输出文件名；</span><br><span class="line">    <span class="number">4</span>.可以添加参数 go build -gcflags <span class="string">&quot;-N -l&quot;</span> ****,可以更好的便于gdb；详细参见 http://golang.org/doc/gdb</span><br><span class="line">    <span class="number">5</span>.gdb全局变量主一点。 如有全局变量 a；则应写为 p <span class="symbol">&#x27;main.a</span>&#x27;；注意但引号不可少；</span><br></pre></td></tr></table></figure>

<h2 id="Golang内置类型和函数"><a href="#Golang内置类型和函数" class="headerlink" title="Golang内置类型和函数"></a>Golang内置类型和函数</h2><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="type">int</span>(<span class="number">32</span> or <span class="number">64</span>), <span class="type">int8</span>, <span class="type">int16</span>, <span class="type">int32</span>, <span class="type">int64</span></span><br><span class="line"><span class="type">uint</span>(<span class="number">32</span> or <span class="number">64</span>), <span class="type">uint8</span>(<span class="type">byte</span>), <span class="type">uint16</span>, <span class="type">uint32</span>, <span class="type">uint64</span></span><br><span class="line"><span class="type">float32</span>, <span class="type">float64</span></span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">complex64</span>, <span class="type">complex128</span></span><br><span class="line">array    -- 固定长度的数组</span><br></pre></td></tr></table></figure>

<h4 id="引用类型：-指针类型"><a href="#引用类型：-指针类型" class="headerlink" title="引用类型：(指针类型)"></a>引用类型：(指针类型)</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">slice</span>   <span class="comment">-- 序列数组(最常用)</span></span><br><span class="line">map     <span class="comment">-- 映射</span></span><br><span class="line">chan    <span class="comment">-- 管道</span></span><br></pre></td></tr></table></figure>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>          -- 用来追加元素到数组、slice中,返回修改后的数组、slice</span><br><span class="line"><span class="built_in">close</span>           -- 主要用来关闭channel</span><br><span class="line"><span class="built_in">delete</span>            -- 从<span class="keyword">map</span>中删除key对应的value</span><br><span class="line"><span class="built_in">panic</span>            -- 停止常规的goroutine  （<span class="built_in">panic</span>和<span class="built_in">recover</span>：用来做错误处理）</span><br><span class="line"><span class="built_in">recover</span>         -- 允许程序定义goroutine的<span class="built_in">panic</span>动作</span><br><span class="line"><span class="built_in">real</span>            -- 返回<span class="built_in">complex</span>的实部   （<span class="built_in">complex</span>、<span class="built_in">real</span> <span class="built_in">imag</span>：用于创建和操作复数）</span><br><span class="line"><span class="built_in">imag</span>            -- 返回<span class="built_in">complex</span>的虚部</span><br><span class="line"><span class="built_in">make</span>            -- 用来分配内存，返回Type本身(只能应用于slice, <span class="keyword">map</span>, channel)</span><br><span class="line"><span class="built_in">new</span>                -- 用来分配内存，主要用来分配值类型，比如<span class="type">int</span>、<span class="keyword">struct</span>。返回指向Type的指针</span><br><span class="line"><span class="built_in">cap</span>                -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 <span class="keyword">map</span>）</span><br><span class="line"><span class="built_in">copy</span>            -- 用于复制和连接slice，返回复制的数目</span><br><span class="line"><span class="built_in">len</span>                -- 来求长度，比如<span class="type">string</span>、array、slice、<span class="keyword">map</span>、channel ，返回长度</span><br><span class="line"><span class="built_in">print</span>、<span class="built_in">println</span>     -- 底层打印函数，在部署环境中建议使用 fmt 包</span><br></pre></td></tr></table></figure>

<h3 id="内置接口error"><a href="#内置接口error" class="headerlink" title="内置接口error"></a>内置接口error</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error interface &#123; //只要实现了<span class="type">Error</span>()函数，返回值为<span class="type">String</span>的都实现了err接口</span><br><span class="line">            <span class="type">Error</span>()    <span class="type">String</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Init函数和main函数"><a href="#Init函数和main函数" class="headerlink" title="Init函数和main函数"></a>Init函数和main函数</h2><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>go语言中init函数用于包(package)的初始化，该函数是go语言的一个重要特性。<br>有下面的特征：</p>
<ol>
<li>init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</li>
<li>每个包可以拥有多个init函数</li>
<li>包的每个源文件也可以拥有多个init函数</li>
<li>同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</li>
<li>不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</li>
<li>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</li>
</ol>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>Go语言程序的默认入口函数(主函数)：func main()函数体用｛｝一对括号包裹。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main()&#123;</span><br><span class="line">        <span class="regexp">//</span>函数体</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="init函数和main函数的异同"><a href="#init函数和main函数的异同" class="headerlink" title="init函数和main函数的异同"></a>init函数和main函数的异同</h3><p>相同点：<br>        两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。<br>不同点：<br>        init可以应用于任意包中，且可以重复定义多个。<br>        main函数只能用于main包中，且只能定义一个。</p>
<p>两个函数的执行顺序：</p>
<ul>
<li><p>对同一个go文件的init()调用顺序是从上到下的。</p>
</li>
<li><p>对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数。</p>
</li>
<li><p>对于不同的package，如果不相互依赖的话，按照main包中”先import的后调用”的顺序调用其包中的init()，如果package存在依赖，则先调用最早被依赖的package中的init()，最后调用main函数。</p>
</li>
<li><p>如果init函数中使用了println()或者print()你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2></li>
<li><p>go env用于打印Go语言的环境信息。</p>
</li>
<li><p>go run命令可以编译并运行命令源码文件。</p>
</li>
<li><p>go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。</p>
</li>
<li><p>go build命令用于编译我们指定的源码文件或代码包以及它们的依赖包。</p>
</li>
<li><p>go install用于编译并安装指定的代码包及它们的依赖包。</p>
</li>
<li><p>go clean命令会删除掉执行其它命令时产生的一些文件和目录。</p>
</li>
<li><p>go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p>
</li>
<li><p>go test命令用于对Go语言编写的程序进行测试。</p>
</li>
<li><p>go list命令的作用是列出指定的代码包的信息。</p>
</li>
<li><p>go fix会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。</p>
</li>
<li><p>go vet是一个用于检查Go语言源码中静态错误的简单工具。</p>
</li>
<li><p>go tool pprof命令来交互式的访问概要文件的内容。</p>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>相加</td>
</tr>
<tr>
<td>-</td>
<td>相减</td>
</tr>
<tr>
<td>*</td>
<td>相乘</td>
</tr>
<tr>
<td>/</td>
<td>相除</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
</tr>
</tbody></table>
<p><strong>注意： ++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符。</strong></p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul>
<li>==</li>
<li>!=</li>
<li><blockquote>
</blockquote>
</li>
<li>&lt;</li>
<li><blockquote>
<p>=</p>
</blockquote>
</li>
<li>&lt;=</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>&amp;&amp;</li>
<li>||</li>
<li>!</li>
</ul>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul>
<li>&amp;</li>
<li>|</li>
<li>^</li>
<li><pre><code>&gt;&gt; ：左移n位就是乘以2的n次方。
</code></pre>
</li>
<li>&lt; &lt;</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul>
<li>=</li>
<li>+=</li>
<li>-=</li>
<li><pre><code> * =
</code></pre>
</li>
<li>/=</li>
<li>%=</li>
<li>  &lt;&lt;=</li>
<li><blockquote>
<blockquote>
<p>=</p>
</blockquote>
</blockquote>
</li>
<li>  &amp;=</li>
<li>  |=</li>
<li>  ^=</li>
</ul>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>“_”是特殊标识符，用来忽略结果。</p>
<h3 id="下划线在import中"><a href="#下划线在import中" class="headerlink" title="下划线在import中"></a>下划线在import中</h3><p>在Golang里，import的作用是导入其他package。</p>
<p>import 下划线（如：import hello/imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;./hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// hello.Print() </span></span><br><span class="line">    <span class="comment">//编译报错：./main.go:6:5: undefined: hello&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="下划线在代码中"><a href="#下划线在代码中" class="headerlink" title="下划线在代码中"></a>下划线在代码中</h3><p>占位符，意思是那个位置本应赋给某个值，但是咱们不需要这个值。所以就把该值赋给下划线，意思是丢掉不要。这样编译器可以更好的优化，任何类型的单个值都可以丢给下划线。这种情况是占位用的，方法返回两个结果，而你只想要一个结果。那另一个就用 “ _ “ 占位，而如果用变量的话，不使用，编译器是会报错的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    f, _ := os.Open(<span class="string">&quot;/Users/***/Desktop/text.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, _ := f.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>    </span><br><span class="line">        &#125;</span><br><span class="line">        os.Stdout.Write(buf[:n])</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。</p>
<h4 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h4><p>Go语言的变量声明格式为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure>
<p>变量声明以关键字var开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="built_in">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="built_in">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>

<h4 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h4><p>每声明一个变量就需要写var关键字会比较繁琐，go语言中还支持批量变量声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">       a <span class="type">string</span></span><br><span class="line">       b <span class="type">int</span></span><br><span class="line">       c <span class="type">bool</span></span><br><span class="line">       d <span class="type">float32</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure>
<h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 类型 <span class="operator">=</span> 表达式</span><br></pre></td></tr></table></figure>
<p>或者一次初始化多个变量：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, sex = <span class="string">&quot;pprof.cn&quot;</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name <span class="operator">=</span> <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">var sex <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h5><p>在函数内部，可以使用更简略的 := 方式声明并初始化变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)<span class="comment">// 全局变量mvar m = 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">10</span></span><br><span class="line">    m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">    fmt.Println(m, n)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h5><p>在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, _ := foo()</span><br><span class="line">    _, y := foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;x=&quot;</span>, x)</span><br><span class="line">    fmt.Println(<span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在Lua等编程语言里，匿名变量也被叫做哑元变量。)</p>
<p>注意事项：</p>
<ol>
<li>函数外的每个语句都必须以关键字开始（var、const、func等）</li>
<li>:=不能使用在函数外。</li>
<li> _ 多用于占位，表示忽略值。</li>
</ol>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const</span> pi = <span class="number">3</span>.<span class="number">1415</span></span><br><span class="line"><span class="attribute">const</span> e = <span class="number">2</span>.<span class="number">7182</span></span><br></pre></td></tr></table></figure>
<p>多个常量也可以一起声明：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">        pi <span class="operator">=</span> <span class="number">3.1415</span></span><br><span class="line">        e <span class="operator">=</span> <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">        n1 <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">        n2</span><br><span class="line">        n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面示例中，常量n1、n2、n3的值都是100。</p>
<h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p>iota是go语言的常量计数器，只能在常量的表达式中使用。 iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。例如：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">            n1 = iota <span class="regexp">//</span><span class="number">0</span></span><br><span class="line">            n2        <span class="regexp">//</span><span class="number">1</span></span><br><span class="line">            n3        <span class="regexp">//</span><span class="number">2</span></span><br><span class="line">            n4        <span class="regexp">//</span><span class="number">3</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h4 id="几个常见的iota示例"><a href="#几个常见的iota示例" class="headerlink" title="几个常见的iota示例"></a>几个常见的iota示例</h4><p>使用_跳过某些值：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">            n1 = iota <span class="regexp">//</span><span class="number">0</span></span><br><span class="line">            n2        <span class="regexp">//</span><span class="number">1</span></span><br><span class="line">            _</span><br><span class="line">            n4        <span class="regexp">//</span><span class="number">3</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>iota声明中间插队：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">            n1 = iota <span class="regexp">//</span><span class="number">0</span></span><br><span class="line">            n2 = <span class="number">100</span>  <span class="regexp">//</span><span class="number">100</span></span><br><span class="line">            n3 = iota <span class="regexp">//</span><span class="number">2</span></span><br><span class="line">            n4        <span class="regexp">//</span><span class="number">3</span></span><br><span class="line">        )</span><br><span class="line">    const n5 = iota <span class="regexp">//</span><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>定义数量级 （这里的&lt;&lt;表示左移操作，1&lt;&lt;10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2&lt;&lt;2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">            _  = <span class="literal">iota</span></span><br><span class="line">            KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">            MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">            GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">            TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">            PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>多个iota定义在一行：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">            a, b = iota + <span class="number">1</span>, iota + <span class="number">2</span> <span class="regexp">//</span><span class="number">1</span>,<span class="number">2</span></span><br><span class="line">            c, d                      <span class="regexp">//</span><span class="number">2</span>,<span class="number">3</span></span><br><span class="line">            e, f                      <span class="regexp">//</span><span class="number">3</span>,<span class="number">4</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="基本类型介绍"><a href="#基本类型介绍" class="headerlink" title="基本类型介绍"></a>基本类型介绍</h3><p>Golang 更明确的数字类型命名，支持 Unicode，支持常用数据结构。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度（字节）</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>1</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
<td>0</td>
<td>uint8</td>
</tr>
<tr>
<td>rune</td>
<td>4</td>
<td>0</td>
<td>Unicode Code Point, int32</td>
</tr>
<tr>
<td>int, uint</td>
<td>4或8</td>
<td>0</td>
<td>32 或 64 位</td>
</tr>
<tr>
<td>int8, uint8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127, 0 ~ 255，byte是uint8 的别名</td>
</tr>
<tr>
<td>int16, uint16</td>
<td>2</td>
<td>0</td>
<td>-32768 ~ 32767, 0 ~ 65535</td>
</tr>
<tr>
<td>int32, uint32</td>
<td>4</td>
<td>0</td>
<td>-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td>
</tr>
<tr>
<td>int64, uint64</td>
<td>8</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>float32</td>
<td>4</td>
<td>0.0</td>
<td></td>
</tr>
<tr>
<td>float64</td>
<td>8</td>
<td>0.0</td>
<td></td>
</tr>
<tr>
<td>complex64</td>
<td>8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>complex128</td>
<td>16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>uintptr</td>
<td>4或8</td>
<td></td>
<td>以存储指针的 uint32 或 uint64 整数</td>
</tr>
<tr>
<td>array</td>
<td></td>
<td></td>
<td>值类型</td>
</tr>
<tr>
<td>struct</td>
<td></td>
<td></td>
<td>值类型</td>
</tr>
<tr>
<td>string</td>
<td></td>
<td>“”</td>
<td>UTF-8 字符串</td>
</tr>
<tr>
<td>slice</td>
<td></td>
<td>nil</td>
<td>引用类型</td>
</tr>
<tr>
<td>map</td>
<td></td>
<td>nil</td>
<td>引用类型</td>
</tr>
<tr>
<td>channel</td>
<td></td>
<td>nil</td>
<td>引用类型</td>
</tr>
<tr>
<td>interface</td>
<td></td>
<td>nil</td>
<td>接口</td>
</tr>
<tr>
<td>function</td>
<td></td>
<td>nil</td>
<td>函数</td>
</tr>
</tbody></table>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64对应的无符号整型：uint8、uint16、uint32、uint64其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。</p>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。</p>
<h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>complex64和complex128复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。</p>
<p><strong>注意：</strong></p>
<ul>
<li><pre><code>布尔类型变量的默认值为false。
</code></pre>
</li>
<li><pre><code>Go 语言中不允许将整型强制转换为布尔型.
</code></pre>
</li>
<li><pre><code>布尔型无法参与数值运算，也无法与其他类型进行转换。
</code></pre>
</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(“)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p>
<table>
<thead>
<tr>
<th>转义</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\r</td>
<td>回车符（返回行首）</td>
</tr>
<tr>
<td>\n</td>
<td>换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
</tbody></table>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>Go语言中要定义一个多行字符串时，就必须使用反引号字符：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := `第一行</span><br><span class="line">    第二行</span><br><span class="line">    第三行</span><br><span class="line">    `</span><br><span class="line">    fmt.Println(s1)</span><br></pre></td></tr></table></figure>
<p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<h4 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h4><table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>len(str)</td>
<td>求长度</td>
</tr>
<tr>
<td>+或fmt.Sprintf</td>
<td>拼接字符串</td>
</tr>
<tr>
<td>strings.Split</td>
<td>分割</td>
</tr>
<tr>
<td>strings.Contains</td>
<td>判断是否包含</td>
</tr>
<tr>
<td>strings.HasPrefix,strings.HasSuffix</td>
<td>前缀/后缀判断</td>
</tr>
<tr>
<td>strings.Index(),strings.LastIndex()</td>
<td>子串出现的位置</td>
</tr>
<tr>
<td>strings.Join(a[]string, sep string)</td>
<td>join操作，连接指定数组的元素或集合的成员，在每个元素或成员之间使用指定的分隔符。</td>
</tr>
</tbody></table>
<h4 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h4><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a := <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b := <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Go 语言的字符有以下两种：</p>
<ol>
<li>uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。</li>
<li>rune类型，代表一个 UTF-8字符。</li>
</ol>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。 Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line">    func <span class="built_in">traversalString</span>() &#123;</span><br><span class="line">        s := <span class="string">&quot;pprof.cn博客&quot;</span></span><br><span class="line">        for i := <span class="number">0</span>; <span class="selector-tag">i</span> &lt; <span class="built_in">len</span>(s); <span class="selector-tag">i</span>++ &#123; <span class="comment">//byte</span></span><br><span class="line">            fmt<span class="selector-class">.Printf</span>(&quot;%v(%c) &quot;, s<span class="selector-attr">[i]</span>, s<span class="selector-attr">[i]</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>()</span><br><span class="line">        for _, r := range s &#123; <span class="comment">//rune</span></span><br><span class="line">            fmt<span class="selector-class">.Printf</span>(&quot;%v(%c) &quot;, r, r)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> 输出：</span><br><span class="line"> </span><br><span class="line"> <span class="number">112</span>(p) <span class="number">112</span>(p) <span class="number">114</span>(r) <span class="number">111</span>(o) <span class="number">102</span>(f) <span class="number">46</span>(.) <span class="number">99</span>(c) <span class="number">110</span>(n) <span class="number">229</span>(å) <span class="number">141</span>() <span class="number">154</span>() <span class="number">229</span>(å) <span class="number">174</span>(®) <span class="number">162</span>(¢)</span><br><span class="line"> </span><br><span class="line"> <span class="number">112</span>(p) <span class="number">112</span>(p) <span class="number">114</span>(r) <span class="number">111</span>(o) <span class="number">102</span>(f) <span class="number">46</span>(.) <span class="number">99</span>(c) <span class="number">110</span>(n) <span class="number">21338</span>(博) <span class="number">23458</span>(客)</span><br></pre></td></tr></table></figure>
<p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p>
<h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="built_in">changeString</span>() &#123;</span><br><span class="line">        s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">        <span class="comment">// 强制类型转换</span></span><br><span class="line">        byteS1 := <span class="selector-attr">[]</span><span class="built_in">byte</span>(s1)</span><br><span class="line">        byteS1<span class="selector-attr">[0]</span> = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="built_in">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">        s2 := <span class="string">&quot;博客&quot;</span></span><br><span class="line">        runeS2 := <span class="selector-attr">[]</span><span class="built_in">rune</span>(s2)</span><br><span class="line">        runeS2<span class="selector-attr">[0]</span> = <span class="string">&#x27;狗&#x27;</span></span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="built_in">string</span>(runeS2))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。强制类型转换的基本语法如下：<br><code>T(表达式)</code><br>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p>
<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func sqrt<span class="constructor">Demo()</span> &#123;</span><br><span class="line">        var a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">        var c <span class="built_in">int</span></span><br><span class="line">        <span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">        c = <span class="built_in">int</span>(math.<span class="constructor">Sqrt(<span class="params">float64</span>(<span class="params">a</span><span class="operator">*</span><span class="params">a</span> + <span class="params">b</span><span class="operator">*</span><span class="params">b</span>)</span>))</span><br><span class="line">        fmt.<span class="constructor">Println(<span class="params">c</span>)</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h2><p>Golang Array和以往认知的数组有很大不同：</p>
<ol>
<li><p>数组：是同一种数据类型的固定长度的序列。</p>
</li>
<li><p>数组定义：var a [len]int，比如：var a [5]int，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。</p>
</li>
<li><p>长度是数组类型的一部分，因此，var a[5] int和var a [10]int是不同的类型。</p>
</li>
<li><p>数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for <span class="selector-tag">i</span> := <span class="number">0</span>; <span class="selector-tag">i</span> &lt; len(<span class="selector-tag">a</span>); <span class="selector-tag">i</span>++ &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for index, v := range a &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic</p>
</li>
<li><p>数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。</p>
</li>
<li><p>支持 “==”、”!=” 操作符，因为内存总是被初始化过的。</p>
</li>
<li><p>指针数组 [n]*T，数组指针 *[n]T。</p>
</li>
</ol>
<h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">全局：</span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">var</span> str = [<span class="number">5</span>]<span class="type">string</span>&#123;<span class="number">3</span>: <span class="string">&quot;hello world&quot;</span>, <span class="number">4</span>: <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line">局部：</span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;           <span class="comment">// 未初始化元素值为 0。</span></span><br><span class="line">b := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;   <span class="comment">// 通过初始化值确定数组长度。</span></span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">100</span>, <span class="number">4</span>: <span class="number">200</span>&#125; <span class="comment">// 使用索引号初始化元素。</span></span><br><span class="line">d := [...]<span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">uint8</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;user1&quot;</span>, <span class="number">10</span>&#125;, <span class="comment">// 可省略元素类型。</span></span><br><span class="line">        &#123;<span class="string">&quot;user2&quot;</span>, <span class="number">20</span>&#125;, <span class="comment">// 别忘了最后一行的逗号。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">var</span> str = [<span class="number">5</span>]<span class="type">string</span>&#123;<span class="number">3</span>: <span class="string">&quot;hello world&quot;</span>, <span class="number">4</span>: <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;           <span class="comment">// 未初始化元素值为 0。</span></span><br><span class="line">    b := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;   <span class="comment">// 通过初始化值确定数组长度。</span></span><br><span class="line">    c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">100</span>, <span class="number">4</span>: <span class="number">200</span>&#125; <span class="comment">// 使用引号初始化元素。</span></span><br><span class="line">    d := [...]<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">        age  <span class="type">uint8</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;user1&quot;</span>, <span class="number">10</span>&#125;, <span class="comment">// 可省略元素类型。</span></span><br><span class="line">        &#123;<span class="string">&quot;user2&quot;</span>, <span class="number">20</span>&#125;, <span class="comment">// 别忘了最后一行的逗号。</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(arr0, arr1, arr2, str)</span><br><span class="line">    fmt.Println(a, b, c, d)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">全局</span></span><br><span class="line"><span class="language-xml">var arr0 [5][3]int</span></span><br><span class="line"><span class="language-xml">var arr1 [2][3]int = [...][3]int</span><span class="template-variable">&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">局部：</span></span><br><span class="line"><span class="language-xml">a := [2][3]int</span><span class="template-variable">&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">b := [...][2]int</span><span class="template-variable">&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125;</span><span class="language-xml"> // 第 2 纬度不能用 &quot;...&quot;。</span></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> arr0 <span class="selector-attr">[5]</span><span class="selector-attr">[3]</span>int</span><br><span class="line"><span class="selector-tag">var</span> arr1 <span class="selector-attr">[2]</span><span class="selector-attr">[3]</span>int = <span class="selector-attr">[...]</span><span class="selector-attr">[3]</span>int&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">a</span> := <span class="selector-attr">[2]</span><span class="selector-attr">[3]</span>int&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">    <span class="selector-tag">b</span> := <span class="selector-attr">[...]</span><span class="selector-attr">[2]</span>int&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125; <span class="comment">// 第 2 纬度不能用 &quot;...&quot;。</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(arr0, arr1)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="selector-tag">a</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值拷贝行为会造成性能问题，通常会建议使用 slice，或数组指针。</p>
<h5 id="多维数组遍历"><a href="#多维数组遍历" class="headerlink" title="多维数组遍历"></a>多维数组遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> f [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> = [...][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k1, v1 := <span class="keyword">range</span> f &#123;</span><br><span class="line">        <span class="keyword">for</span> k2, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;(%d,%d)=%d &quot;</span>, k1, k2, v2)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组拷贝和传参"><a href="#数组拷贝和传参" class="headerlink" title="数组拷贝和传参"></a>数组拷贝和传参</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">printArr</span>(arr *<span class="selector-attr">[5]</span>int) &#123;</span><br><span class="line">    arr<span class="selector-attr">[0]</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span>, v := range arr &#123;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="selector-tag">i</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> arr1 <span class="selector-attr">[5]</span>int</span><br><span class="line">    <span class="built_in">printArr</span>(&amp;arr1)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(arr1)</span><br><span class="line">    arr2 := <span class="selector-attr">[...]</span>int&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;</span><br><span class="line">    <span class="built_in">printArr</span>(&amp;arr2)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(arr2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a>切片Slice</h2><p>需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。</p>
<ol>
<li>切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</li>
<li>切片的长度可以改变，因此，切片是一个可变的数组。</li>
<li>切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 </li>
<li>cap可以求出slice最大扩张容量，不能超出数组限制。0 &lt;= len(slice) &lt;= len(array)，其中array是slice引用的数组。</li>
<li>切片的定义：var 变量名 []类型，比如 var str []string  var arr []int。</li>
<li>如果 slice == nil，那么 len、cap 结果都等于 0。<h3 id="创建切片的各种方式"><a href="#创建切片的各种方式" class="headerlink" title="创建切片的各种方式"></a>创建切片的各种方式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">   <span class="comment">//1.声明切片</span></span><br><span class="line">   <span class="selector-tag">var</span> s1 <span class="selector-attr">[]</span>int</span><br><span class="line">   <span class="keyword">if</span> s1 == nil &#123;</span><br><span class="line">      fmt<span class="selector-class">.Println</span>(<span class="string">&quot;是空&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt<span class="selector-class">.Println</span>(<span class="string">&quot;不是空&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.:=</span></span><br><span class="line">   s2 := <span class="selector-attr">[]</span>int&#123;&#125;</span><br><span class="line">   <span class="comment">// 3.make()</span></span><br><span class="line">   <span class="selector-tag">var</span> s3 <span class="selector-attr">[]</span>int = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">0</span>)</span><br><span class="line">   fmt<span class="selector-class">.Println</span>(s1, s2, s3)</span><br><span class="line">   <span class="comment">// 4.初始化赋值</span></span><br><span class="line">   <span class="selector-tag">var</span> s4 <span class="selector-attr">[]</span>int = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">   fmt<span class="selector-class">.Println</span>(s4)</span><br><span class="line">   s5 := <span class="selector-attr">[]</span>int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   fmt<span class="selector-class">.Println</span>(s5)</span><br><span class="line">   <span class="comment">// 5.从数组切片</span></span><br><span class="line">   arr := <span class="selector-attr">[5]</span>int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">   <span class="selector-tag">var</span> s6 <span class="selector-attr">[]</span>int</span><br><span class="line">   <span class="comment">// 前包后不包</span></span><br><span class="line">   s6 = arr<span class="selector-attr">[1:4]</span></span><br><span class="line">   fmt<span class="selector-class">.Println</span>(s6)&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">全局：</span><br><span class="line"><span class="selector-tag">var</span> arr = <span class="selector-attr">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="selector-tag">var</span> slice0 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[start:end]</span> </span><br><span class="line"><span class="selector-tag">var</span> slice1 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[:end]</span>        </span><br><span class="line"><span class="selector-tag">var</span> slice2 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[start:]</span>        </span><br><span class="line"><span class="selector-tag">var</span> slice3 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[:]</span> </span><br><span class="line"><span class="selector-tag">var</span> slice4 = arr<span class="selector-attr">[:len(arr)-1]</span>      <span class="comment">//去掉切片的最后一个元素</span></span><br><span class="line">局部：</span><br><span class="line">arr2 := <span class="selector-attr">[...]</span>int&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">slice5 := arr<span class="selector-attr">[start:end]</span></span><br><span class="line">slice6 := arr<span class="selector-attr">[:end]</span>        </span><br><span class="line">slice7 := arr<span class="selector-attr">[start:]</span>     </span><br><span class="line">slice8 := arr<span class="selector-attr">[:]</span>  </span><br><span class="line">slice9 := arr<span class="selector-attr">[:len(arr)-1]</span> <span class="comment">//去掉切片的最后一个元素</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87.png"><br>代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> arr = <span class="selector-attr">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;<span class="selector-tag">var</span> slice0 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[2:8]</span><span class="selector-tag">var</span> slice1 <span class="selector-attr">[]</span>int = arr<span class="selector-attr">[0:6]</span>        <span class="comment">//可以简写为 var slice []int = arr[:end]var slice2 []int = arr[5:10]       //可以简写为 var slice[]int = arr[start:]var slice3 []int = arr[0:len(arr)] //var slice []int = arr[:]var slice4 = arr[:len(arr)-1]      //去掉切片的最后一个元素func main() &#123;</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：arr %v\n&quot;</span>, arr)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice0 %v\n&quot;</span>, slice0)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice1 %v\n&quot;</span>, slice1)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice2 %v\n&quot;</span>, slice2)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice3 %v\n&quot;</span>, slice3)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;全局变量：slice4 %v\n&quot;</span>, slice4)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>)</span><br><span class="line">    arr2 := <span class="selector-attr">[...]</span>int&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    slice5 := arr<span class="selector-attr">[2:8]</span></span><br><span class="line">    slice6 := arr<span class="selector-attr">[0:6]</span>         <span class="comment">//可以简写为 slice := arr[:end]</span></span><br><span class="line">    slice7 := arr<span class="selector-attr">[5:10]</span>        <span class="comment">//可以简写为 slice := arr[start:]</span></span><br><span class="line">    slice8 := arr<span class="selector-attr">[0:len(arr)]</span>  <span class="comment">//slice := arr[:]</span></span><br><span class="line">    slice9 := arr<span class="selector-attr">[:len(arr)-1]</span> <span class="comment">//去掉切片的最后一个元素</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： arr2 %v\n&quot;</span>, arr2)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice5 %v\n&quot;</span>, slice5)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice6 %v\n&quot;</span>, slice6)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice7 %v\n&quot;</span>, slice7)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice8 %v\n&quot;</span>, slice8)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;局部变量： slice9 %v\n&quot;</span>, slice9)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">全局变量：arr [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">全局变量：slice0 [<span class="number">2 3 4 5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">全局变量：slice1 [<span class="number">0 1 2 3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">全局变量：slice2 [<span class="number">5 6 7 8</span> <span class="number">9</span>]</span><br><span class="line">全局变量：slice3 [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">全局变量：slice4 [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span>]</span><br><span class="line">-----------------------------------</span><br><span class="line">局部变量： arr2 [<span class="number">9 8 7 6</span> <span class="number">5 4 3 2</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">局部变量： slice5 [<span class="number">2 3 4 5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">局部变量： slice6 [<span class="number">0 1 2 3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">局部变量： slice7 [<span class="number">5 6 7 8</span> <span class="number">9</span>]</span><br><span class="line">局部变量： slice8 [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">局部变量： slice9 [<span class="number">0 1 2 3</span> <span class="number">4 5 6 7</span> <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h3 id="通过make来创建切片"><a href="#通过make来创建切片" class="headerlink" title="通过make来创建切片"></a>通过make来创建切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line">slice  := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line">slice  := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/make%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87.png"><br>代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> slice0 <span class="selector-attr">[]</span>int = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>)</span><br><span class="line"><span class="selector-tag">var</span> slice1 = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>)</span><br><span class="line"><span class="selector-tag">var</span> slice2 = <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make全局slice0 ：%v\n&quot;</span>, slice0)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make全局slice1 ：%v\n&quot;</span>, slice1)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make全局slice2 ：%v\n&quot;</span>, slice2)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;--------------------------------------&quot;</span>)</span><br><span class="line">    slice3 := <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>)</span><br><span class="line">    slice4 := <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>)</span><br><span class="line">    slice5 := <span class="built_in">make</span>(<span class="selector-attr">[]</span>int, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make局部slice3 ：%v\n&quot;</span>, slice3)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make局部slice4 ：%v\n&quot;</span>, slice4)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;make局部slice5 ：%v\n&quot;</span>, slice5)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> make全局slice0 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> make全局slice1 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> make全局slice2 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> --------------------------------------</span><br><span class="line">make局部slice3 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">make局部slice4 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">make局部slice5 ：[<span class="number">0 0 0 0</span> <span class="number">0 0 0 0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>切片的内存布局：<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></p>
<p>读写操作实际目标是底层数组，只需注意索引号的差别。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    data := <span class="selector-attr">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    s := data<span class="selector-attr">[2:4]</span></span><br><span class="line">    s<span class="selector-attr">[0]</span> += <span class="number">100</span></span><br><span class="line">    s<span class="selector-attr">[1]</span> += <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(s)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(data)&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[102 203]</span></span><br><span class="line"><span class="string">[0 1 102 203 4 5]</span></span><br></pre></td></tr></table></figure>

<p>可直接创建 slice 对象，自动分配底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>: <span class="number">100</span>&#125; <span class="comment">// 通过初始化表达式构造，可使用索引号。</span></span><br><span class="line">    fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line"></span><br><span class="line">    s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">6</span>, <span class="number">8</span>) <span class="comment">// 使用 make 创建，指定 len 和 cap 值。</span></span><br><span class="line">    fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line"></span><br><span class="line">    s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">6</span>) <span class="comment">// 省略 cap，相当于 cap = len。</span></span><br><span class="line">    fmt.Println(s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0<span class="number"> 1 </span>2<span class="number"> 3 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>100]<span class="number"> 9 </span>9</span><br><span class="line">[0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0]<span class="number"> 6 </span>8</span><br><span class="line">[0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0]<span class="number"> 6 </span>6</span><br></pre></td></tr></table></figure>

<p>使用 make 动态创建slice，避免了数组必须用常量做长度的麻烦。还可用指针直接访问底层数组，退化成普通数组操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    p := &amp;s[<span class="number">2</span>] <span class="comment">// *int, 获取底层数组元素指针。</span></span><br><span class="line">    *p += <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(s)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0 1 102 3]</span></span><br></pre></td></tr></table></figure>
<p>至于 [][]T，是指元素类型为 []T 。<br>可直接修改 struct array/slice 成员。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    d := <span class="selector-attr">[5]</span>struct &#123;</span><br><span class="line">        x int</span><br><span class="line">    &#125;&#123;&#125;</span><br><span class="line">    s := d<span class="selector-attr">[:]</span></span><br><span class="line">    d<span class="selector-attr">[1]</span><span class="selector-class">.x</span> = <span class="number">10</span></span><br><span class="line">    s<span class="selector-attr">[2]</span><span class="selector-class">.x</span> = <span class="number">20</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(d)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%p, %p\n&quot;</span>, &amp;d, &amp;d<span class="selector-attr">[0]</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">[</span><span class="template-variable">&#123;0&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;10&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;20&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;0&#125;</span><span class="language-xml"> </span><span class="template-variable">&#123;0&#125;</span><span class="language-xml">]</span></span><br><span class="line"><span class="language-xml">0xc4200160f0, 0xc4200160f0</span></span><br></pre></td></tr></table></figure>

<h3 id="用append内置函数操作切片（切片追加）"><a href="#用append内置函数操作切片（切片追加）" class="headerlink" title="用append内置函数操作切片（切片追加）"></a>用append内置函数操作切片（切片追加）</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice a : %v\n&quot;</span>, a)</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="selector-attr">[]</span>int&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice b : %v\n&quot;</span>, b)</span><br><span class="line">    c := <span class="built_in">append</span>(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>...)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice c : %v\n&quot;</span>, c)</span><br><span class="line">    d := <span class="built_in">append</span>(c, <span class="number">7</span>)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice d : %v\n&quot;</span>, d)</span><br><span class="line">    e := <span class="built_in">append</span>(d, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice e : %v\n&quot;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice a : [1<span class="number"> 2 </span>3]</span><br><span class="line">slice b : [4<span class="number"> 5 </span>6]</span><br><span class="line">slice c : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5 6]</span><br><span class="line">slice d : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7]</span><br><span class="line">slice e : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9 10]</span><br></pre></td></tr></table></figure>
<p>append ：向 slice 尾部添加数据，返回新的 slice 对象。</p>
<h3 id="超出原-slice-cap-限制，就会重新分配底层数组，即便原数组并未填满。"><a href="#超出原-slice-cap-限制，就会重新分配底层数组，即便原数组并未填满。" class="headerlink" title="超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。"></a>超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    data := <span class="selector-attr">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>: <span class="number">0</span>&#125;</span><br><span class="line">    s := data<span class="selector-attr">[:2:3]</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">100</span>, <span class="number">200</span>) <span class="comment">// 一次 append 两个值，超出 s.cap 限制。</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(s, data)         <span class="comment">// 重新分配底层数组，与原数组无关。</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(&amp;s<span class="selector-attr">[0]</span>, &amp;data<span class="selector-attr">[0]</span>) <span class="comment">// 比对底层数组起始指针。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0<span class="number"> 1 </span>100 200] [0<span class="number"> 1 </span>2<span class="number"> 3 </span>4<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0]</span><br><span class="line">0xc4200160f0 0xc420070060</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，append 后的 s 重新分配了底层数组，并复制数据。如果只追加一个值，则不会超过 s.cap 限制，也就不会重新分配。 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。</p>
<h3 id="slice中cap重新分配规律："><a href="#slice中cap重新分配规律：" class="headerlink" title="slice中cap重新分配规律："></a>slice中cap重新分配规律：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    c := <span class="built_in">cap</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, i)</span><br><span class="line">        <span class="keyword">if</span> n := <span class="built_in">cap</span>(s); n &gt; c &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;cap: %d -&gt; %d\n&quot;</span>, c, n)</span><br><span class="line">            c = n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cap</span>: <span class="number">1</span> -&gt; <span class="number">2</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">2</span> -&gt; <span class="number">4</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">4</span> -&gt; <span class="number">8</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">8</span> -&gt; <span class="number">16</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">16</span> -&gt; <span class="number">32</span></span><br><span class="line"><span class="attribute">cap</span>: <span class="number">32</span> -&gt; <span class="number">64</span></span><br></pre></td></tr></table></figure>

<h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="symbol">func</span> main() &#123;</span><br><span class="line">    <span class="built_in">s1</span> := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice s1 : %v\n&quot;</span>, <span class="built_in">s1</span>)</span><br><span class="line">    <span class="built_in">s2</span> := make([]int, <span class="number">10</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice s2 : %v\n&quot;</span>, <span class="built_in">s2</span>)</span><br><span class="line">    copy(<span class="built_in">s2</span>, <span class="built_in">s1</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;copied slice s1 : %v\n&quot;</span>, <span class="built_in">s1</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;copied slice s2 : %v\n&quot;</span>, <span class="built_in">s2</span>)</span><br><span class="line">    <span class="built_in">s3</span> := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice s3 : %v\n&quot;</span>, <span class="built_in">s3</span>)</span><br><span class="line">    <span class="built_in">s3</span> = append(<span class="built_in">s3</span>, <span class="built_in">s2</span>...)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;appended slice s3 : %v\n&quot;</span>, <span class="built_in">s3</span>)</span><br><span class="line">    <span class="built_in">s3</span> = append(<span class="built_in">s3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;last slice s3 : %v\n&quot;</span>, <span class="built_in">s3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice s1 : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5]</span><br><span class="line">slice s2 : [0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0]</span><br><span class="line">copied slice s1 : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5]</span><br><span class="line">copied slice s2 : [1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0]</span><br><span class="line">slice s3 : [1<span class="number"> 2 </span>3]</span><br><span class="line">appended slice s3 : [1<span class="number"> 2 </span>3<span class="number"> 1 </span>2<span class="number"> 3 </span>4<span class="number"> 5 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0]</span><br><span class="line">last slice s3 : [1<span class="number"> 2 </span>3<span class="number"> 1 </span>2<span class="number"> 3 </span>4<span class="number"> 5 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 4 </span>5 6]</span><br></pre></td></tr></table></figure>
<p>copy ：函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。<br>应及时将所需数据 copy 到较小的 slice，以便释放超大号底层数组内存。</p>
<h3 id="slice遍历"><a href="#slice遍历" class="headerlink" title="slice遍历"></a>slice遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    slice := data[:]</span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;inde : %v , value : %v\n&quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inde : 0 , <span class="type">value</span> : 0</span><br><span class="line">inde : 1 , <span class="type">value</span> : 1</span><br><span class="line">inde : 2 , <span class="type">value</span> : 2</span><br><span class="line">inde : 3 , <span class="type">value</span> : 3</span><br><span class="line">inde : 4 , <span class="type">value</span> : 4</span><br><span class="line">inde : 5 , <span class="type">value</span> : 5</span><br><span class="line">inde : 6 , <span class="type">value</span> : 6</span><br><span class="line">inde : 7 , <span class="type">value</span> : 7</span><br><span class="line">inde : 8 , <span class="type">value</span> : 8</span><br><span class="line">inde : 9 , <span class="type">value</span> : 9</span><br></pre></td></tr></table></figure>
<h3 id="切片resize（调整大小）"><a href="#切片resize（调整大小）" class="headerlink" title="切片resize（调整大小）"></a>切片resize（调整大小）</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>int&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice a : %v , len(a) : %v\n&quot;</span>, <span class="selector-tag">a</span>, <span class="built_in">len</span>(a))</span><br><span class="line">    <span class="selector-tag">b</span> := <span class="selector-tag">a</span><span class="selector-attr">[1:2]</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice b : %v , len(b) : %v\n&quot;</span>, <span class="selector-tag">b</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    c := <span class="selector-tag">b</span><span class="selector-attr">[0:3]</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;slice c : %v , len(c) : %v\n&quot;</span>, c, <span class="built_in">len</span>(c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice <span class="selector-tag">a</span> : <span class="selector-attr">[1 3 4 5]</span> , <span class="built_in">len</span>(a) : <span class="number">4</span></span><br><span class="line">slice <span class="selector-tag">b</span> : <span class="selector-attr">[3]</span> , <span class="built_in">len</span>(b) : <span class="number">1</span></span><br><span class="line">slice c : <span class="selector-attr">[3 4 5]</span> , <span class="built_in">len</span>(c) : <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="数组和切片的内存布局"><a href="#数组和切片的内存布局" class="headerlink" title="数组和切片的内存布局"></a>数组和切片的内存布局</h3><p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></p>
<h3 id="字符串和切片（string-and-slice）"><a href="#字符串和切片（string-and-slice）" class="headerlink" title="字符串和切片（string and slice）"></a>字符串和切片（string and slice）</h3><p>string底层就是一个byte的数组，因此，也可以进行切片操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    s1 := str[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">    s2 := str[<span class="number">6</span>:]</span><br><span class="line">    fmt.Println(s2)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello</span></span><br><span class="line"><span class="attribute">world</span></span><br></pre></td></tr></table></figure>
<p>string本身是不可变的，因此要改变string中字符。需要如下操作： </p>
<h4 id="英文字符串"><a href="#英文字符串" class="headerlink" title="英文字符串"></a>英文字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">    s := []<span class="type">byte</span>(str) <span class="comment">//中文字符需要用[]rune(str)</span></span><br><span class="line">    s[<span class="number">6</span>] = <span class="string">&#x27;G&#x27;</span></span><br><span class="line">    s = s[:<span class="number">8</span>]</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">    str = <span class="type">string</span>(s)</span><br><span class="line">    fmt.Println(str)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：Hello Go!</p>
<h4 id="中文字符串"><a href="#中文字符串" class="headerlink" title="中文字符串"></a>中文字符串</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    str := <span class="string">&quot;你好，世界！hello world！&quot;</span></span><br><span class="line">    s := <span class="selector-attr">[]</span><span class="built_in">rune</span>(str) </span><br><span class="line">    s<span class="selector-attr">[3]</span> = <span class="string">&#x27;够&#x27;</span></span><br><span class="line">    s<span class="selector-attr">[4]</span> = <span class="string">&#x27;浪&#x27;</span></span><br><span class="line">    s<span class="selector-attr">[12]</span> = <span class="string">&#x27;g&#x27;</span></span><br><span class="line">    s = s<span class="selector-attr">[:14]</span></span><br><span class="line">    str = <span class="built_in">string</span>(s)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(str)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，够浪！hello <span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<p>golang slice data[:6:8] 两个冒号的理解常规<br>slice , data[6:8]，从第6位到第8位（返回6，7），长度len为2， 最大可扩充长度cap为4（6-9）<br>另一种写法： data[:6:8] 每个数字前都有个冒号， slice内容为data从0到第6位，长度len为6，最大扩充项cap设置为8<br>a[x:y:z] 切片内容 [x:y] 切片长度: y-x 切片容量:z-x</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。<br>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p>
<h3 id="Go语言中的指针"><a href="#Go语言中的指针" class="headerlink" title="Go语言中的指针"></a>Go语言中的指针</h3><p>Go语言中的函数传参都是值拷贝，当我们想要修改某个变量的时候，我们可以创建一个指向该变量地址的指针变量。传递数据使用指针，而无须拷贝数据。类型指针不能进行偏移和运算。Go语言中的指针操作非常简单，只需要记住两个符号：&amp;（取地址）和* （根据地址取值）。</p>
<h4 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h4><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：* int、* int64、* string等。<br>取变量指针的语法如下：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := <span class="meta">&amp;v    <span class="comment">// v的类型为T</span></span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>v:代表被取地址的变量，类型为T</li>
<li> ptr:用于接收地址的变量，ptr的类型就为* T，称做T的指针类型。* 代表指针。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">a</span> := <span class="number">10</span></span><br><span class="line">    <span class="selector-tag">b</span> := &amp;<span class="selector-tag">a</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;a:%d ptr:%p\n&quot;</span>, <span class="selector-tag">a</span>, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;b:%p type:%T\n&quot;</span>, <span class="selector-tag">b</span>, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下b := &amp;a的图示：<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E5%9C%B0%E5%9D%80%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B.png"></p>
<h4 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h4><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用* 操作，也就是指针取值，代码如下。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="comment">//指针取值</span></span><br><span class="line">    <span class="selector-tag">a</span> := <span class="number">10</span></span><br><span class="line">    <span class="selector-tag">b</span> := &amp;<span class="selector-tag">a</span> <span class="comment">// 取变量a的地址，将指针保存到b中</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type of b:%T\n&quot;</span>, b)</span><br><span class="line">    c := *<span class="selector-tag">b</span> <span class="comment">// 指针取值（根据指针去内存取值）</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type of c:%T\n&quot;</span>, c)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;value of c:%v\n&quot;</span>, c)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">of </span>b:*int</span><br><span class="line"><span class="keyword">type</span> <span class="type">of </span>c:int</span><br><span class="line">value <span class="keyword">of</span> c:<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>总结： 取地址操作符&amp;和取值操作符* 是一对互补操作符，&amp;取出地址，* 根据地址取出地址指向的值。变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>
<ol>
<li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值（* ）操作，可以获得指针变量指向的原变量的值。</li>
</ol>
<p>指针传值示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x = <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *x = <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    modify1(a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">    modify2(&amp;a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 100&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><ul>
<li>当一个指针被定义后没有分配到任何变量时，它的值为 nil</li>
<li>空指针的判断<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">p</span> *string</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;p的值是%v\n&quot;</span>, p)</span><br><span class="line">    <span class="keyword">if</span> <span class="selector-tag">p</span> != nil &#123;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;非空&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt<span class="selector-class">.Println</span>(<span class="string">&quot;空值&quot;</span>)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> *int</span><br><span class="line">    *<span class="selector-tag">a</span> = <span class="number">100</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(*a)</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> map<span class="selector-attr">[string]</span>int</span><br><span class="line">    <span class="selector-tag">b</span><span class="selector-attr">[<span class="string">&quot;测试&quot;</span>]</span> = <span class="number">100</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(b)&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p>
<h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><p>new是一个内置的函数，它的函数签名如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func <span class="keyword">new</span>(<span class="keyword">Type</span>) *<span class="keyword">Type</span></span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ol>
<li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li>
<li><ul>
<li>Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li>
</ul>
</li>
</ol>
<p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">a</span> := <span class="built_in">new</span>(int)</span><br><span class="line">    <span class="selector-tag">b</span> := <span class="built_in">new</span>(bool)</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%T\n&quot;</span>, b) <span class="comment">// *bool</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(*a)       <span class="comment">// 0</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(*b)       <span class="comment">// false&#125;</span></span><br></pre></td></tr></table></figure>

<p>本节开始的示例代码中var a * int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> *int</span><br><span class="line">    <span class="selector-tag">a</span> = <span class="built_in">new</span>(int)</span><br><span class="line">    *<span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(*a)&#125;</span><br></pre></td></tr></table></figure>

<h5 id="make"><a href="#make" class="headerlink" title="make"></a>make</h5><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func make(<span class="built_in">t</span> <span class="built_in">Type</span>, size ...IntegerType) <span class="built_in">Type</span></span><br></pre></td></tr></table></figure>
<p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。<br>本节开始的示例中var b map[string]int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    b[<span class="string">&quot;测试&quot;</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(b)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a>new与make的区别</h5><ol>
<li>二者都是用来做内存分配的。</li>
<li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li>
<li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>
<h3 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h3><p>Go语言中 map的定义语法如下：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure>

<p>其中，KeyType:表示键的类型，ValueType:表示键对应的值的类型。<br>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>
<p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p>
<h3 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h3><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">8</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(scoreMap)</span><br><span class="line">    fmt.Println(scoreMap[<span class="string">&quot;小明&quot;</span>])</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, scoreMap)</span><br><span class="line"> &#125;</span><br><span class="line"> 输出：</span><br><span class="line"> </span><br><span class="line"><span class="keyword">map</span>[小明:<span class="number">100</span> 张三:<span class="number">90</span>]</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="keyword">type</span> of a:<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>map也支持在声明的时候填充元素，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    userInfo := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(userInfo) <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h3><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    <span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">    v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h3><p>Go语言中使用for range遍历map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">&quot;王五&quot;</span>] = <span class="number">60</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>但我们只想遍历key的时候，可以按下面的写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">&quot;王五&quot;</span>] = <span class="number">60</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">        fmt.Println(k)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意： 遍历map时的元素顺序与添加键值对的顺序无关。</strong></p>
<h3 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h3><p>使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="built_in">map</span>, <span class="built_in">key</span>)</span><br></pre></td></tr></table></figure>
<p>其中，map:表示要删除键值对的map， key:表示要删除的键值对的键<br>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">&quot;王五&quot;</span>] = <span class="number">60</span></span><br><span class="line">    <span class="built_in">delete</span>(scoreMap, <span class="string">&quot;小明&quot;</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    <span class="built_in">rand</span>.Seed(time.Now().UnixNano()) <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">var</span> scoreMap = make(map[<span class="built_in">string</span>]<span class="type">int</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    for i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="built_in">key</span> := fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i) <span class="comment">//生成stu开头的字符串</span></span><br><span class="line">        <span class="built_in">value</span> := <span class="built_in">rand</span>.Intn(<span class="number">100</span>)          <span class="comment">//生成0~99的随机整数</span></span><br><span class="line">        scoreMap[<span class="built_in">key</span>] = <span class="built_in">value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出map中的所有key存入切片keys</span></span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">keys</span> = make([]<span class="built_in">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line">    for <span class="built_in">key</span> := range scoreMap &#123;</span><br><span class="line">        <span class="built_in">keys</span> = append(<span class="built_in">keys</span>, <span class="built_in">key</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对切片进行排序</span></span><br><span class="line">    sort.Strings(<span class="built_in">keys</span>)</span><br><span class="line">    <span class="comment">//按照排序后的key遍历map</span></span><br><span class="line">    for _, <span class="built_in">key</span> := range <span class="built_in">keys</span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">key</span>, scoreMap[<span class="built_in">key</span>])</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> mapSlice = <span class="built_in">make</span>(<span class="selector-attr">[]</span>map<span class="selector-attr">[string]</span>string, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> index, value := range mapSlice &#123;</span><br><span class="line">        fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">    <span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line">    mapSlice<span class="selector-attr">[0]</span> = <span class="built_in">make</span>(map<span class="selector-attr">[string]</span>string, <span class="number">10</span>)</span><br><span class="line">    mapSlice<span class="selector-attr">[0]</span><span class="selector-attr">[<span class="string">&quot;name&quot;</span>]</span> = <span class="string">&quot;王五&quot;</span></span><br><span class="line">    mapSlice<span class="selector-attr">[0]</span><span class="selector-attr">[<span class="string">&quot;password&quot;</span>]</span> = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    mapSlice<span class="selector-attr">[0]</span><span class="selector-attr">[<span class="string">&quot;address&quot;</span>]</span> = <span class="string">&quot;红旗大街&quot;</span></span><br><span class="line">    <span class="keyword">for</span> index, value := range mapSlice &#123;</span><br><span class="line">        fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> sliceMap = <span class="built_in">make</span>(map<span class="selector-attr">[string]</span><span class="selector-attr">[]</span>string, <span class="number">3</span>)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(sliceMap)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">    key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">    value, ok := sliceMap<span class="selector-attr">[key]</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        value = <span class="built_in">make</span>(<span class="selector-attr">[]</span>string, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    value = <span class="built_in">append</span>(value, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line">    sliceMap<span class="selector-attr">[key]</span> = value</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(sliceMap)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<h3 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h3><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来定义自定义类型。自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将MyInt定义为<span class="built_in">int</span>类型</span><br><span class="line"><span class="built_in">type</span> MyInt <span class="built_in">int</span></span><br></pre></td></tr></table></figure>
<p>通过Type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名是Go1.9版本添加的新功能。类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">TypeAlias </span>= <span class="keyword">Type</span></span><br></pre></td></tr></table></figure>
<p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">byte</span> = <span class="type">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></table></figure>

<h4 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h4><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义type NewInt int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名type MyInt = int</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> NewInt</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> MyInt</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">//type of b:int&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</p>
<h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。Go语言中通过struct来实现面向对象。</p>
<h4 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h4><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 struct &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型。</li>
</ol>
<p>举个例子，我们定义一个Person（人）结构体，代码如下：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">    age  int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样类型的字段也可以写在一行，</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name, city <span class="keyword">string</span></span><br><span class="line">    age        int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型。</p>
<h4 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h4><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure>

<h4 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">    age  <span class="type">int8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p1 person</span><br><span class="line">    p1.name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">    p1.age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;pprof.cn 北京 18&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。</p>
<h4 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h4><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="type">string</span>; Age <span class="type">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h4><p>我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p2 = <span class="keyword">new</span>(person)</span><br><span class="line">fmt.<span class="constructor">Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="params">p2</span>)</span>     <span class="comment">//*main.person</span></span><br><span class="line">fmt.<span class="constructor">Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, <span class="params">p2</span>)</span> <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure>

<p>从打印的结果中我们可以看出p2是一个结构体指针。需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2<span class="selector-class">.name</span> = <span class="string">&quot;测试&quot;</span></span><br><span class="line">p2<span class="selector-class">.age</span> = <span class="number">18</span></span><br><span class="line">p2<span class="selector-class">.city</span> = <span class="string">&quot;北京&quot;</span></span><br><span class="line">fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;测试&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h4><p>使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="regexp">//</span>*main.person</span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="regexp">//</span>p3=&amp;main.person&#123;name:<span class="string">&quot;&quot;</span>, city:<span class="string">&quot;&quot;</span>, age:<span class="number">0</span>&#125;</span><br><span class="line">p3.name = <span class="string">&quot;博客&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="regexp">//</span>p3=&amp;main.person&#123;name:<span class="string">&quot;博客&quot;</span>, city:<span class="string">&quot;成都&quot;</span>, age:<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>

<p>p3.name = “博客”其实在底层是(* p3).name = “博客”，这是Go语言帮我们实现的语法糖。</p>
<h4 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">    age  <span class="type">int8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p4 person</span><br><span class="line">    fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h5><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">p5</span> := person&#123;</span><br><span class="line">    <span class="attribute">name</span>: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    <span class="attribute">city</span>: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="attribute">age</span>:  <span class="number">18</span>,&#125;</span><br><span class="line"><span class="attribute">fmt</span>.Printf(<span class="string">&quot;p5=%#v\n&quot;</span>, p5) //p5=main.person&#123;name:<span class="string">&quot;pprof.cn&quot;</span>, city:<span class="string">&quot;北京&quot;</span>, age:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对结构体指针进行键值对初始化，例如：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p6 := <span class="variable">&amp;person</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    name:</span> <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line"><span class="symbol">    city:</span> <span class="string">&quot;北京&quot;</span>,</span><br><span class="line"><span class="symbol">    age:</span>  <span class="number">18</span>,<span class="punctuation">&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p6=%#v\n&quot;</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure>
<p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p7=%#v\n&quot;</span>, p7) <span class="regexp">//</span>p7=&amp;main.person&#123;name:<span class="string">&quot;&quot;</span>, city:<span class="string">&quot;北京&quot;</span>, age:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h5><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">    <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="number">18</span>,&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p8=%#v\n&quot;</span>, p8) <span class="regexp">//</span>p8=&amp;main.person&#123;name:<span class="string">&quot;pprof.cn&quot;</span>, city:<span class="string">&quot;北京&quot;</span>, age:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种格式初始化时，需要注意：</p>
<ol>
<li>必须初始化结构体的所有字段。</li>
<li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>该方式不能和键值初始化方式混用。</li>
</ol>
<h4 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h4><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type test struct &#123;</span><br><span class="line">    <span class="attribute">a int8</span></span><br><span class="line"><span class="attribute">    b int8</span></span><br><span class="line"><span class="attribute">    c int8</span></span><br><span class="line"><span class="attribute">    d int8&#125;</span></span><br><span class="line"><span class="attribute">n</span> := test&#123;</span><br><span class="line">    1, 2, 3, 4,&#125;</span><br><span class="line">fmt<span class="variable">.Printf</span>(&quot;n<span class="variable">.a</span> %p\n&quot;, &amp;n<span class="variable">.a</span>)</span><br><span class="line">fmt<span class="variable">.Printf</span>(&quot;n<span class="variable">.b</span> %p\n&quot;, &amp;n<span class="variable">.b</span>)</span><br><span class="line">fmt<span class="variable">.Printf</span>(&quot;n<span class="variable">.c</span> %p\n&quot;, &amp;n<span class="variable">.c</span>)</span><br><span class="line">fmt<span class="variable">.Printf</span>(&quot;n<span class="variable">.d</span> %p\n&quot;, &amp;n<span class="variable">.d</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">n</span>.a <span class="number">0</span>xc0000a0060</span><br><span class="line"><span class="attribute">n</span>.b <span class="number">0</span>xc0000a0061</span><br><span class="line"><span class="attribute">n</span>.c <span class="number">0</span>xc0000a0062</span><br><span class="line"><span class="attribute">n</span>.d <span class="number">0</span>xc0000a0063</span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func <span class="keyword">new</span><span class="constructor">Person(<span class="params">name</span>, <span class="params">city</span> <span class="params">string</span>, <span class="params">age</span> <span class="params">int8</span>)</span> *person &#123;</span><br><span class="line">    return &amp;person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        city: city,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>调用构造函数：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := <span class="built_in">newPerson</span>(<span class="string">&quot;pprof.cn&quot;</span>, <span class="string">&quot;测试&quot;</span>, <span class="number">90</span>)</span><br><span class="line">fmt.<span class="built_in">Printf</span>(<span class="string">&quot;%#v\n&quot;</span>, p9)</span><br></pre></td></tr></table></figure>

<h4 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h4><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p>
<p>方法的定义格式如下：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span> &#123;</span><br><span class="line">        函数体</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ol>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>
<h4 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h4><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line">func (p *Person) SetAge(<span class="keyword">new</span><span class="type">Age</span> int8) &#123;</span><br><span class="line">    p.age = <span class="keyword">new</span><span class="type">Age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该方法：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    p1 := <span class="built_in">NewPerson</span>(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1<span class="selector-class">.SetAge</span>(<span class="number">30</span>)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p1.age) <span class="comment">// 30&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h4><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄// 使用值接收者</span></span><br><span class="line">func (<span class="selector-tag">p</span> Person) <span class="built_in">SetAge2</span>(newAge int8) &#123;</span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.age</span> = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    p1 := <span class="built_in">NewPerson</span>(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1<span class="selector-class">.Dream</span>()</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1<span class="selector-class">.SetAge2</span>(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(p1.age) <span class="comment">// 25&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h4><ol>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ol>
<h4 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h4><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line">func (m MyInt) <span class="constructor">SayHello()</span> &#123;</span><br><span class="line">    fmt.<span class="constructor">Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span>&#125;</span><br><span class="line">    </span><br><span class="line">func main<span class="literal">()</span> &#123;</span><br><span class="line">    var m1 MyInt</span><br><span class="line">    m1.<span class="constructor">SayHello()</span> <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">    m1 = <span class="number">100</span></span><br><span class="line">    fmt.<span class="constructor">Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, <span class="params">m1</span>, <span class="params">m1</span>)</span> <span class="comment">//100  main.MyInt&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p>
<h4 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">string</span></span><br><span class="line">    <span class="type">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;</span><br><span class="line">        <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">        <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;pprof.cn&quot;, int:18&#125;</span></span><br><span class="line">    fmt.Println(p1.<span class="type">string</span>, p1.<span class="type">int</span>) <span class="comment">//pprof.cn 18&#125;</span></span><br></pre></td></tr></table></figure>
<p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">Address</span> 地址结构体</span><br><span class="line"><span class="keyword">type</span> <span class="type">Address</span> struct &#123;</span><br><span class="line">    <span class="type">Province</span> string</span><br><span class="line">    <span class="type">City</span>     string&#125;</span><br><span class="line"></span><br><span class="line">//<span class="type">User</span> 用户结构体</span><br><span class="line"><span class="keyword">type</span> <span class="type">User</span> struct &#123;</span><br><span class="line">    <span class="type">Name</span>    string</span><br><span class="line">    <span class="type">Gender</span>  string</span><br><span class="line">    <span class="type">Address</span> <span class="type">Address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">func</span> main() &#123;</span><br><span class="line">    user1 := <span class="type">User</span>&#123;</span><br><span class="line">        <span class="type">Name</span>:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">        <span class="type">Gender</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        <span class="type">Address</span>: <span class="type">Address</span>&#123;</span><br><span class="line">            <span class="type">Province</span>: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">            <span class="type">City</span>:     <span class="string">&quot;哈尔滨&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.<span class="type">Printf</span>(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)//user1=main.<span class="type">User</span>&#123;<span class="type">Name</span>:<span class="string">&quot;pprof&quot;</span>, <span class="type">Gender</span>:<span class="string">&quot;女&quot;</span>, <span class="type">Address</span>:main.<span class="type">Address</span>&#123;<span class="type">Province</span>:<span class="string">&quot;黑龙江&quot;</span>, <span class="type">City</span>:<span class="string">&quot;哈尔滨&quot;</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a>嵌套匿名结构体</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Address 地址结构体</span><br><span class="line"><span class="keyword">type</span> Address struct &#123;</span><br><span class="line">    Province <span class="keyword">string</span></span><br><span class="line">    City     <span class="keyword">string</span>&#125;</span><br><span class="line"></span><br><span class="line">//<span class="keyword">User</span> <span class="title">用户结构体</span></span><br><span class="line"><span class="title">type</span> <span class="keyword">User</span> <span class="title">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Gender  <span class="keyword">string</span></span><br><span class="line">    Address //匿名结构体&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var user2 <span class="keyword">User</span></span><br><span class="line">    <span class="title">user2</span>.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user2.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    user2.Address.Province = <span class="string">&quot;黑龙江&quot;</span>    //通过匿名结构体.字段名访问</span><br><span class="line">    user2.City = <span class="string">&quot;哈尔滨&quot;</span>                //直接访问匿名结构体的字段名</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user2=%#v\n&quot;</span>, user2) //<span class="attr">user2=</span>main.User&#123;Name:<span class="string">&quot;pprof&quot;</span>, Gender:<span class="string">&quot;女&quot;</span>, Address:main.Address&#123;Province:<span class="string">&quot;黑龙江&quot;</span>, City:<span class="string">&quot;哈尔滨&quot;</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p>
<h4 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h4><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province   <span class="type">string</span></span><br><span class="line">    City       <span class="type">string</span></span><br><span class="line">    CreateTime <span class="type">string</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account    <span class="type">string</span></span><br><span class="line">    CreateTime <span class="type">string</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span></span><br><span class="line">    Gender <span class="type">string</span></span><br><span class="line">    Address</span><br><span class="line">    Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user3 User</span><br><span class="line">    user3.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user3.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    <span class="comment">// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</span></span><br><span class="line">    user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">    user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">//指定Email结构体中的CreateTime&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h4><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet    <span class="type">int8</span></span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: <span class="number">4</span>,</span><br><span class="line">        Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">            name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">    d1.move() <span class="comment">//乐乐会动！&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h4><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p>
<h4 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">Student</span> 学生</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Student</span> struct &#123;</span></span><br><span class="line"><span class="class">    <span class="type">ID</span>     <span class="title">int</span></span></span><br><span class="line"><span class="class">    <span class="type">Gender</span> <span class="title">string</span></span></span><br><span class="line"><span class="class">    <span class="type">Name</span>   <span class="title">string</span>&#125;</span></span><br><span class="line"></span><br><span class="line">//<span class="type">Class</span> 班级</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Class</span> struct &#123;</span></span><br><span class="line"><span class="class">    <span class="type">Title</span>    <span class="title">string</span></span></span><br><span class="line"><span class="class">    <span class="type">Students</span> []*<span class="type">Student</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">func</span> main() &#123;</span><br><span class="line">    c := &amp;<span class="type">Class</span>&#123;</span><br><span class="line">        <span class="type">Title</span>:    <span class="string">&quot;101&quot;</span>,</span><br><span class="line">        <span class="type">Students</span>: make([]*<span class="type">Student</span>, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    for i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        stu := &amp;<span class="type">Student</span>&#123;</span><br><span class="line">            <span class="type">Name</span>:   fmt.<span class="type">Sprintf</span>(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">            <span class="type">Gender</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">            <span class="type">ID</span>:     i,</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="type">Students</span> = append(c.<span class="type">Students</span>, stu)</span><br><span class="line">    &#125;</span><br><span class="line">    //<span class="type">JSON</span>序列化：结构体<span class="comment">--&gt;JSON格式的字符串</span></span><br><span class="line">    <span class="class"><span class="keyword">data</span>, err := json.<span class="type">Marshal</span>(<span class="title">c</span>)</span></span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.<span class="type">Println</span>(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.<span class="type">Printf</span>(<span class="string">&quot;json:%s\n&quot;</span>, <span class="class"><span class="keyword">data</span>)</span></span><br><span class="line">    //<span class="type">JSON</span>反序列化：<span class="type">JSON</span>格式的字符串<span class="comment">--&gt;结构体</span></span><br><span class="line">    str := `&#123;<span class="string">&quot;Title&quot;</span>:<span class="string">&quot;101&quot;</span>,<span class="string">&quot;Students&quot;</span>:[&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">0</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu00&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">1</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu01&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">2</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu02&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">3</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu03&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">4</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu04&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">5</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu05&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">6</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu06&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">7</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu07&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">8</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu08&quot;</span>&#125;,&#123;<span class="string">&quot;ID&quot;</span>:<span class="number">9</span>,<span class="string">&quot;Gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;stu09&quot;</span>&#125;]&#125;`</span><br><span class="line">    c1 := &amp;<span class="type">Class</span>&#123;&#125;</span><br><span class="line">    err = json.<span class="type">Unmarshal</span>([]byte(str), c1)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.<span class="type">Println</span>(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.<span class="type">Printf</span>(<span class="string">&quot;%#v\n&quot;</span>, c1)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h4><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:<span class="string">&quot;value1&quot;</span> key2:<span class="string">&quot;value2&quot;</span>`</span><br></pre></td></tr></table></figure>

<p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。<br>例如我们为Student结构体的每个字段定义json序列化时使用的Tag：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">    Gender <span class="type">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">    name   <span class="type">string</span> <span class="comment">//私有不能被json包访问&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;</span><br><span class="line">        ID:     <span class="number">1</span>,</span><br><span class="line">        Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    data, err := json.Marshal(s1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;女&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="条件语句if"><a href="#条件语句if" class="headerlink" title="条件语句if"></a>条件语句if</h2><p> if 语句 由一个布尔表达式后紧跟一个或多个语句组成。</p>
<p>Go 编程语言中 if 语句的语法如下：</p>
<ul>
<li>可省略条件表达式括号。</li>
<li>持初始化语句，可定义代码块局部变量。 </li>
<li>代码块左 括号必须在条件表达式尾部。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">    <span class="regexp">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n := <span class="string">&quot;abc&quot;</span>; x &gt; <span class="number">0</span> &#123;     <span class="regexp">//</span> 初始化语句未必就是定义变量， 如 println(<span class="string">&quot;init&quot;</span>) 也是可以的。</span><br><span class="line">    println(n[<span class="number">2</span>])&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;    <span class="regexp">//</span> 注意 <span class="keyword">else</span> <span class="keyword">if</span> 和 <span class="keyword">else</span> 左大括号位置。</span><br><span class="line">    println(n[<span class="number">1</span>])&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(n[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意：不支持三元操作符(三目运算符) “a &gt; b ? a : b”。</li>
</ul>
<p>Go 编程语言中 if…else 语句的语法如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="regexp">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="regexp">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件语句switch"><a href="#条件语句switch" class="headerlink" title="条件语句switch"></a>条件语句switch</h2><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。 Golang switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。</p>
<p>Go 编程语言中 switch 语句的语法如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        <span class="params">...</span></span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        <span class="params">...</span></span><br><span class="line">    default:</span><br><span class="line">        <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。 您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> grade string <span class="operator">=</span> <span class="string">&quot;B&quot;</span></span><br><span class="line">   <span class="keyword">var</span> marks int <span class="operator">=</span> <span class="number">90</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> marks &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">90</span>: grade <span class="operator">=</span> <span class="string">&quot;A&quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">80</span>: grade <span class="operator">=</span> <span class="string">&quot;B&quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span> : grade <span class="operator">=</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">      <span class="keyword">default</span>: grade <span class="operator">=</span> <span class="string">&quot;D&quot;</span>  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> grade <span class="operator">==</span> <span class="string">&quot;A&quot;</span> :</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;优秀!<span class="subst">\n</span>&quot;</span> )     </span><br><span class="line">      <span class="keyword">case</span> grade <span class="operator">==</span> <span class="string">&quot;B&quot;</span>, grade <span class="operator">==</span> <span class="string">&quot;C&quot;</span> :</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;良好<span class="subst">\n</span>&quot;</span> )      </span><br><span class="line">      <span class="keyword">case</span> grade <span class="operator">==</span> <span class="string">&quot;D&quot;</span> :</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;及格<span class="subst">\n</span>&quot;</span> )      </span><br><span class="line">      <span class="keyword">case</span> grade <span class="operator">==</span> <span class="string">&quot;F&quot;</span>:</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;不及格<span class="subst">\n</span>&quot;</span> )</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.<span class="type">Printf</span>(<span class="string">&quot;差<span class="subst">\n</span>&quot;</span> )</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.<span class="type">Printf</span>(<span class="string">&quot;你的等级是 %s<span class="subst">\n</span>&quot;</span>, grade )</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优秀!</span><br><span class="line">你的等级是 <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure>

<h3 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h3><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。<br>Type Switch 语法格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s)      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s)</span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//写法一：</span></span><br><span class="line">    <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123; <span class="comment">// 带初始化语句</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot; x 的类型 :%T\r\n&quot;</span>, i)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 int 型&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 float64 型&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">float64</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 func(int) 型&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>, <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 bool 或 string 型&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;未知型&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法二</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> j &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法三</span></span><br><span class="line">    <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> k &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;fallthrough&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；</span></span><br><span class="line"><span class="comment">            而如果switch没有表达式，它会匹配true。</span></span><br><span class="line"><span class="comment">            Go里面switch默认相当于每个case最后带有break，</span></span><br><span class="line"><span class="comment">            匹配成功后不会自动向下执行其他case，而是跳出整个switch,</span></span><br><span class="line"><span class="comment">            但是可以使用fallthrough强制执行后面的case代码。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法三</span></span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> m &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法四</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> &#123; <span class="comment">//省略条件表达式，可当 if...else if...else</span></span><br><span class="line">    <span class="keyword">case</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;i &gt; 0 and i &lt; 10&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> n &gt; <span class="number">10</span> &amp;&amp; n &lt; <span class="number">20</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;i &gt; 10 and i &lt; 20&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果为：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x 的类型 <span class="symbol">:&lt;nil&gt;</span></span><br><span class="line">fallthrough</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span></span></span><br></pre></td></tr></table></figure>
<h2 id="条件语句select"><a href="#条件语句select" class="headerlink" title="条件语句select"></a>条件语句select</h2><p>select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。select 是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。<br>Go 编程语言中 select 语句的语法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       <span class="keyword">statement</span>(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       <span class="keyword">statement</span>(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       <span class="keyword">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下描述了 select 语句的语法：</p>
<ul>
<li>每个case都必须是一个通信</li>
<li>所有channel表达式都会被求值</li>
<li>所有被发送的表达式都会被求值</li>
<li>如果任意某个通信可以进行，它就执行；其他被忽略。</li>
<li>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。</li>
<li>否则：<br>  如果有default子句，则执行该语句。<br>  如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</li>
</ul>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="type">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果为：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">no</span> communication</span><br></pre></td></tr></table></figure>
<p>select可以监听channel的数据流动<br>select的用法与switch语法非常类似，由select开始的一个新的选择块，每个选择条件由case语句来描述<br>与switch语句可以选择任何使用相等比较的条件相比，select由比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select &#123; <span class="regexp">//</span>不停的在这里检测</span><br><span class="line">    case &lt;-chanl : <span class="regexp">//</span>检测有没有数据可以读</span><br><span class="line">    <span class="regexp">//</span>如果chanl成功读取到数据，则进行该case处理语句</span><br><span class="line">    case chan2 &lt;- <span class="number">1</span> : <span class="regexp">//</span>检测有没有可以写</span><br><span class="line">    <span class="regexp">//</span>如果成功向chan2写入数据，则进行该case处理语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span>假如没有default，那么在以上两个条件都不成立的情况下，就会在此阻塞<span class="regexp">//</span>一般default会不写在里面，select中的default子句总是可运行的，因为会很消耗CPU资源</span><br><span class="line">    default:</span><br><span class="line">    <span class="regexp">//</span>如果以上都没有符合条件，那么则进行default处理流程</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在一个select语句中，Go会按顺序从头到尾评估每一个发送和接收的语句。如果其中的任意一个语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。 如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况： ①如果给出了default语句，那么就会执行default的流程，同时程序的执行会从select语句后的语句中恢复。 ②如果没有default语句，那么select语句将被阻塞，直到至少有一个case可以进行下去。</p>
<h3 id="Golang-select的使用及典型用法"><a href="#Golang-select的使用及典型用法" class="headerlink" title="Golang select的使用及典型用法"></a>Golang select的使用及典型用法</h3><h4 id="超时判断"><a href="#超时判断" class="headerlink" title="超时判断"></a>超时判断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如在下面的场景中，使用全局resChan来接受response，如果时间超过3S,resChan中还没有数据返回，则第二条case将执行</span></span><br><span class="line"><span class="keyword">var</span> resChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">// do requestfunc test() &#123;</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-resChan:</span><br><span class="line">        doData(data)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):</span><br><span class="line">        fmt.Println(<span class="string">&quot;request time out&quot;</span>)</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doData</span><span class="params">(data <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程（协程）中如下：var shouldQuit=make(chan struct&#123;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//loop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...out of the loop</span></span><br><span class="line">    select &#123;</span><br><span class="line">        case &lt;-c.shouldQuit:</span><br><span class="line">            cleanUp()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        default:</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向shouldQuit发送数据通知程序停止运行</span></span><br><span class="line">close(shouldQuit)</span><br></pre></td></tr></table></figure>

<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断</span></span><br><span class="line">ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)<span class="comment">//...</span></span><br><span class="line">data：=<span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- data:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//做相应操作，比如丢弃data。视需求而定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h2><p>Golang for支持三种循环方式，包括类似 while 的语法。for循环是一个循环控制结构，可以执行指定次数的循环。<br>Go语言的For循环有3中形式，只有其中的一种使用分号。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> init; <span class="keyword">condition</span>; post &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">condition</span> &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br><span class="line">init： 一般为赋值表达式，给控制变量赋初值；</span><br><span class="line"><span class="keyword">condition</span>： 关系表达式或逻辑表达式，循环控制条件；</span><br><span class="line">post： 一般为赋值表达式，给控制变量增量或减量。</span><br><span class="line"><span class="keyword">for</span>语句执行过程如下：</span><br><span class="line">①先对表达式 init 赋初值；</span><br><span class="line">②判别赋值表达式 init 是否满足给定 <span class="keyword">condition</span> 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 <span class="keyword">condition</span>；否则判断 <span class="keyword">condition</span> 的值为假，不满足条件，就终止<span class="keyword">for</span>循环，执行循环体外语句。</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, n := <span class="number">0</span>, <span class="built_in">len</span>(s); i &lt; n; i++ &#123; <span class="comment">// 常见的 for 循环，支持初始化语句。</span></span><br><span class="line">    <span class="built_in">println</span>(s[i])&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="built_in">len</span>(s)<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;                <span class="comment">// 替代 while (n &gt; 0) &#123;&#125;</span></span><br><span class="line">    <span class="built_in">println</span>(s[n])        <span class="comment">// 替代 for (; n &gt; 0;) &#123;&#125;</span></span><br><span class="line">    n-- </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;                    <span class="comment">// 替代 while (true) &#123;&#125;</span></span><br><span class="line">    <span class="built_in">println</span>(s)            <span class="comment">// 替代 for (;;) &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要期望编译器能理解你的想法，在初始化语句中计算出全部结果是个好主意。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">length</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;call length.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;abcd&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="number">0</span>, length(s); i &lt; n; i++ &#123;     <span class="comment">// 避免多次调用 length 函数。</span></span><br><span class="line">        <span class="built_in">println</span>(i, s[i])</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">call</span> length.</span><br><span class="line"><span class="attribute">0</span> <span class="number">97</span></span><br><span class="line"><span class="attribute">1</span> <span class="number">98</span></span><br><span class="line"><span class="attribute">2</span> <span class="number">99</span></span><br><span class="line"><span class="attribute">3</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>以下为 Go 语言嵌套循环的格式：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for <span class="selector-attr">[condition |  ( init; condition; increment ) | Range]</span>&#123;</span><br><span class="line">   for <span class="selector-attr">[condition |  ( init; condition; increment ) | Range]</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">statement</span>(s)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">statement</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>如过循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span>  &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;这是无限循环。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环语句range"><a href="#循环语句range" class="headerlink" title="循环语句range"></a>循环语句range</h2><p>Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">key</span>, value := <span class="built_in">range</span> oldMap &#123;</span><br><span class="line">    newMap[<span class="built_in">key</span>] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>1st value</th>
<th>2nd value</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>index</td>
<td>s[index]</td>
<td>unicode, rune</td>
</tr>
<tr>
<td>array/slice</td>
<td>index</td>
<td>s[index]</td>
<td></td>
</tr>
<tr>
<td>map</td>
<td>key</td>
<td>m[key]</td>
<td></td>
</tr>
<tr>
<td>channel</td>
<td>element</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>可忽略不想要的返回值，或 “ _ “ 这个特殊变量。   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="comment">// 忽略 2nd value，支持 string/array/slice/map。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="built_in">println</span>(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 忽略 index。</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="built_in">println</span>(c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 忽略全部返回值，仅迭代。</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// 返回 (key, value)。</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        <span class="built_in">println</span>(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">97</span></span><br><span class="line"><span class="attribute">98</span></span><br><span class="line"><span class="attribute">99</span></span><br><span class="line"><span class="attribute">97</span></span><br><span class="line"><span class="attribute">98</span></span><br><span class="line"><span class="attribute">99</span></span><br><span class="line"><span class="attribute">a</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">b</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：range 会复制对象。</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">a</span> := <span class="selector-attr">[3]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span>, v := range <span class="selector-tag">a</span> &#123; <span class="comment">// index、value 都是从复制品中取出。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">i</span> == <span class="number">0</span> &#123; <span class="comment">// 在修改前，我们先修改原数组。</span></span><br><span class="line">            <span class="selector-tag">a</span><span class="selector-attr">[1]</span>, <span class="selector-tag">a</span><span class="selector-attr">[2]</span> = <span class="number">999</span>, <span class="number">999</span></span><br><span class="line">            fmt<span class="selector-class">.Println</span>(a) <span class="comment">// 确认修改有效，输出 [0, 999, 999]。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-attr">[i]</span> = v + <span class="number">100</span> <span class="comment">// 使用复制品中取出的 value 修改原数组。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(a) <span class="comment">// 输出 [100, 101, 102]。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0 999 999]</span></span><br><span class="line"><span class="string">[100 101 102]</span></span><br></pre></td></tr></table></figure>
<p>建议改用引用类型，其底层数据不会被复制。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    s := <span class="selector-attr">[]</span>int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span>, v := range s &#123; <span class="comment">// 复制 struct slice &#123; pointer, len, cap &#125;。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">i</span> == <span class="number">0</span> &#123;</span><br><span class="line">            s = s<span class="selector-attr">[:3]</span>  <span class="comment">// 对 slice 的修改，不会影响 range。</span></span><br><span class="line">            s<span class="selector-attr">[2]</span> = <span class="number">100</span> <span class="comment">// 对底层数据的修改。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println</span>(<span class="selector-tag">i</span>, v)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">100</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>另外两种引用类型 map、channel 是指针包装，而不像 slice 是 struct。</p>
<p>for 和 for range有什么区别?主要是使用场景不同<br>for可以</p>
<ul>
<li>遍历array和slice</li>
<li>遍历key为整型递增的map</li>
<li>遍历string</li>
</ul>
<p>for range可以</p>
<ul>
<li>完成所有for可以做的事情，却能做到for不能做的，包括遍历key为string类型的map并同时获取key和value</li>
<li>遍历channel</li>
</ul>
<h2 id="循环控制Goto、Break、Continue"><a href="#循环控制Goto、Break、Continue" class="headerlink" title="循环控制Goto、Break、Continue"></a>循环控制Goto、Break、Continue</h2><p>循环控制语句循环控制语句可以控制循环体内语句的执行过程。GO 语言支持以下几种循环控制语句：Goto、Break、Continue</p>
<ul>
<li>三个语句都可以配合标签(label)使用</li>
<li>标签名区分大小写，定以后若不使用会造成编译错误</li>
<li>continue、break配合标签(label)可用于多层循环跳出</li>
<li>goto是调整执行位置，与continue、break配合标签(label)的结果并不相同</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><h3 id="golang函数特点"><a href="#golang函数特点" class="headerlink" title="golang函数特点"></a>golang函数特点</h3><ul>
<li>无需声明原型</li>
<li>支持不定变参</li>
<li>支持多返回值</li>
<li>支持命名返回参数</li>
<li>支持匿名函数和闭包</li>
<li>函数也是一种类型，一个函数可以赋值给变量</li>
<li>不支持 嵌套 (nested) 一个包不能有两个名字一样的函数</li>
<li>不支持 重载 (overload) </li>
<li>不支持 默认参数 (default parameter)</li>
</ul>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明包含一个函数名，参数列表， 返回值列表和函数体。如果函数没有返回值，则返回列表可以省略。函数从第一条语句开始执行，直到执行return语句或者执行函数的最后一条语句。</p>
<p>函数可以没有参数或接受多个参数。注意类型在变量名之后 。当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。函数可以返回任意数量的返回值。使用关键字 func 定义函数，左大括号依旧不能另起一行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>, s <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="comment">// 类型相同的相邻参数，参数类型可合并。 多返回值必须用括号。</span></span><br><span class="line">    n := x + y          </span><br><span class="line">    <span class="keyword">return</span> n, fmt.Sprintf(s, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数是第一类对象，可作为参数传递。建议将复杂签名定义为函数类型，以便于阅读。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(fn <span class="keyword">func</span>()</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn()&#125;<span class="comment">// 定义函数类型。type FormatFunc func(s string, x, y int) string </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(fn FormatFunc, s <span class="type">string</span>, x, y <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(s, x, y)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := test(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">100</span> &#125;) <span class="comment">// 直接将匿名函数当参数。</span></span><br><span class="line"></span><br><span class="line">    s2 := format(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>, x, y <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(s, x, y)</span><br><span class="line">    &#125;, <span class="string">&quot;%d, %d&quot;</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(s1, s2)&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">100 </span><span class="number">10</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>有返回值的函数，必须有明确的终止语句，否则会引发编译错误。你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="type">float64</span>)</span></span> float <span class="comment">//implemented in assembly language</span></span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数定义时指出，函数定义时有参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量。但当调用函数，传递过来的变量就是函数的实参，函数可以通过两种方式来传递参数：值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    temp = *x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">    *x = *y   <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">    *y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用 swap() 函数</span></span><br><span class="line"><span class="comment">        &amp;a 指向 a 指针，a 变量的地址</span></span><br><span class="line"><span class="comment">        &amp;b 指向 b 指针，b 变量的地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line">    fmt.Println(a, b)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<p><strong>注意1：无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。<br>注意2：map、slice、chan、指针、interface默认以引用的方式传递。</strong></p>
<p>不定参数传值 就是函数的参数不是固定的，后面的类型是固定的。（可变参数）Golang 可变参数本质上就是 slice。只能有一个，且必须是最后一个。在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="type">int</span>)</span></span> &#123;    <span class="comment">//0个或多个参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, args…<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;    <span class="comment">//1个或多个参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>, args…<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;    <span class="comment">//2个或多个参数</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意：其中args是一个slice，我们可以通过arg[index]依次访问所有参数,通过len(arg)来判断传递参数的个数.</p>
<p>任意类型的不定参数： 就是函数的参数和每个参数的类型都不是固定的。用interface{}传递任意类型数据是Go语言的惯例用法，而且interface{}是类型安全的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">myfunc</span>(<span class="params">args ...<span class="keyword">interface</span>&#123;&#125;</span>) &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="type">string</span>, n ...<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</span><br><span class="line">        x += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(s, x)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(test(<span class="string">&quot;sum: %d&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sum</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>使用 slice 对象做变参时，必须展开。（slice…）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="type">string</span>, n ...<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</span><br><span class="line">        x += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(s, x)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    res := test(<span class="string">&quot;sum: %d&quot;</span>, s...)    <span class="comment">// slice... 展开slice</span></span><br><span class="line">    <span class="built_in">println</span>(res)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>“ _ “标识符，用来忽略函数的某个返回值<br>Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。<br>返回值的名称应当具有一定的意义，可以作为文档使用。<br>没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。<br>直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<p>Golang返回值不能用容器对象接收多返回值。只能用多个变量，或 “_ “ 忽略。</p>
<p>多返回值可直接作为其他函数调用实参。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</span><br><span class="line">        x += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(test()))</span><br><span class="line">    <span class="built_in">println</span>(sum(test()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>命名返回参数可看做与形参类似的局部变量，最后由 return 隐式返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>命名返回参数可被同名局部变量遮蔽，此时需要显式返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    &#123; <span class="comment">// 不能在一个级别，引发 &quot;z redeclared in this block&quot; 错误。</span></span><br><span class="line">        <span class="keyword">var</span> z = x + y</span><br><span class="line">        <span class="comment">// return   // Error: z is shadowed during return</span></span><br><span class="line">        <span class="keyword">return</span> z <span class="comment">// 必须显式返回。</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>命名返回参数允许 defer 延迟调用通过闭包读取和修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        z += <span class="number">100</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">103</span><br></pre></td></tr></table></figure>
<p>显式 return 返回前，会先修改命名返回参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(z) <span class="comment">// 输出: 203</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> z + <span class="number">200</span> <span class="comment">// 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (return)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 输出: 203&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">203</span><br><span class="line">203</span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数是指不需要定义函数名的一种函数实现方式。1958年LISP首先采用匿名函数。<br>在Go里面，函数可以像普通变量一样被传递或使用，Go语言支持随时在代码里定义匿名函数。匿名函数由一个不带函数名的函数声明和函数体组成。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    getSqrt := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(a)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(getSqrt(<span class="number">4</span>))&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p>上面先定义了一个名为getSqrt 的变量，初始化该变量时和之前的变量初始化有些不同，使用了func，func是定义函数的，可是这个函数和上面说的函数最大不同就是没有函数名，也就是匿名函数。这里将一个函数当做一个变量一样的操作。</p>
<p>Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// --- function variable ---</span></span><br><span class="line">    fn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;Hello, World!&quot;</span>) &#125;</span><br><span class="line">    fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- function collection ---</span></span><br><span class="line">    fns := [](<span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + <span class="number">2</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(fns[<span class="number">0</span>](<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- function as field ---</span></span><br><span class="line">    d := <span class="keyword">struct</span> &#123;</span><br><span class="line">        fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        fn: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(d.fn())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- channel of function ---</span></span><br><span class="line">    fc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    fc &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;</span><br><span class="line">    <span class="built_in">println</span>((&lt;-fc)())</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> World!</span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="built_in">Hello,</span> World!</span><br><span class="line"><span class="built_in">Hello,</span> World!</span><br></pre></td></tr></table></figure>
<h2 id="闭包、递归"><a href="#闭包、递归" class="headerlink" title="闭包、递归"></a>闭包、递归</h2><h3 id="闭包详解"><a href="#闭包详解" class="headerlink" title="闭包详解"></a>闭包详解</h3><p>闭包的应该都听过，但到底什么是闭包呢？<br>闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。<br>“官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    b := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := a()</span><br><span class="line">    c()</span><br><span class="line">    c()</span><br><span class="line">    c()</span><br><span class="line"></span><br><span class="line">    a() <span class="comment">//不会输出i&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>闭包复制的是原对象指针，这就很容易解释延迟引用现象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;x (%p) = %d\n&quot;</span>, &amp;x, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x (%p) = %d\n&quot;</span>, &amp;x, x)</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := test()</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span> (<span class="number">0</span>xc42007c008) = <span class="number">100</span></span><br><span class="line"><span class="attribute">x</span> (<span class="number">0</span>xc42007c008) = <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>在汇编层 ，test 实际返回的是 FuncVal 对象，其中包含了匿名函数地址、闭包对象指针。当调匿名函数时，只需以某个寄存器传递该对象即可。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">FuncVal </span><span class="template-variable">&#123; func_address, closure_var_pointer ... &#125;</span></span><br></pre></td></tr></table></figure>


<p>外部引用函数参数局部变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用函数参数局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(base <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        base += i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tmp1 := add(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(tmp1(<span class="number">1</span>), tmp1(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 此时tmp1和tmp2不是一个实体了</span></span><br><span class="line">    tmp2 := add(<span class="number">100</span>)</span><br><span class="line">    fmt.Println(tmp2(<span class="number">1</span>), tmp2(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时可以返回多个闭包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回2个函数类型的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义2个函数，并返回</span></span><br><span class="line">    <span class="comment">// 相加</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        base += i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相减</span></span><br><span class="line">    sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        base -= i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f1, f2 := test01(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// base一直是没有消</span></span><br><span class="line">    fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 此时base是9</span></span><br><span class="line">    fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Go-语言递归函数"><a href="#Go-语言递归函数" class="headerlink" title="Go 语言递归函数"></a>Go 语言递归函数</h3><p>斐波那契数列(Fibonacci)：</p>
<p>这个数列从第3项开始，每一项都等于前两项之和。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonaci</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonaci(i<span class="number">-1</span>) + fibonaci(i<span class="number">-2</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, fibonaci(i))</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延迟调用（defer）"><a href="#延迟调用（defer）" class="headerlink" title="延迟调用（defer）"></a>延迟调用（defer）</h2><h3 id="Golang延迟调用"><a href="#Golang延迟调用" class="headerlink" title="Golang延迟调用"></a>Golang延迟调用</h3><h4 id="defer特性"><a href="#defer特性" class="headerlink" title="defer特性"></a>defer特性</h4><ol>
<li>关键字 defer 用于注册延迟调用。</li>
<li>这些调用直到 return 前才被执。因此，可以用来做资源清理。</li>
<li>多个defer语句，按先进后出的方式执行。</li>
<li>defer语句中的变量，在defer声明时就决定了。</li>
</ol>
<h4 id="defer用途"><a href="#defer用途" class="headerlink" title="defer用途"></a>defer用途</h4><ol>
<li>关闭文件句柄</li>
<li>锁资源释放</li>
<li>数据库连接释放</li>
</ol>
<p>go 语言的defer功能强大，对于资源管理非常方便，但是如果没用好，也会有陷阱。defer 是先进后出这个很自然,后面的语句会依赖前面的资源，因此如果先前面的资源先释放了，后面的语句就没法执行了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="defer-碰上闭包"><a href="#defer-碰上闭包" class="headerlink" title="defer 碰上闭包"></a>defer 碰上闭包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(i) &#125;()</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>其实go说的很清楚,我们一起来看看go spec如何说的</p>
<blockquote>
<p>Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usualand saved anew but the actual function is not invoked.</p>
</blockquote>
<p>也就是说函数正常执行,由于闭包用到的变量 i 在执行的时候已经变成4,所以输出全都是4.</p>
<h4 id="defer-f-Close"><a href="#defer-f-Close" class="headerlink" title="defer f.Close"></a>defer f.Close</h4><p>这个大家用的都很频繁,但是go语言编程举了一个可能一不小心会犯错的例子.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span></span> Close() &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">&quot; closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        <span class="keyword">defer</span> t.Close()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c  <span class="keyword">closed</span></span><br><span class="line">c  <span class="keyword">closed</span></span><br><span class="line">c  <span class="keyword">closed</span></span><br></pre></td></tr></table></figure>

<p>这个输出并不会像我们预计的输出c b a,而是输出c c c可是按照前面的go spec中的说明,应该输出c b a才对啊.那我们换一种方式来调用一下.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span></span> Close() &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">&quot; closed&quot;</span>)&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Close</span><span class="params">(t Test)</span></span> &#123;</span><br><span class="line">    t.Close()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        <span class="keyword">defer</span> Close(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c  <span class="keyword">closed</span></span><br><span class="line">b  <span class="keyword">closed</span></span><br><span class="line">a  <span class="keyword">closed</span></span><br></pre></td></tr></table></figure>
<p>当然,如果你不想多写一个函数,也很简单,可以像下面这样,同样会输出c b a看似多此一举的声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span></span> Close() &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">&quot; closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        t2 := t</span><br><span class="line">        <span class="keyword">defer</span> t2.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c  <span class="keyword">closed</span></span><br><span class="line">b  <span class="keyword">closed</span></span><br><span class="line">a  <span class="keyword">closed</span></span><br></pre></td></tr></table></figure>

<p>可以得出下面的结论：defer后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。但是并没有说struct这里的this指针如何处理，通过这个例子可以看出go语言并没有把这个明确写出来的this指针当作参数来看待。多个 defer 注册，按 FILO 次序执行 ( 先进后出 )。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="number">100</span> / x) <span class="comment">// div0 异常未被捕获，逐步往外传递，最终终止进程。</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">b</span><br><span class="line"><span class="keyword">a</span></span><br><span class="line">panic: runtime error: <span class="keyword">integer</span> <span class="built_in">divide</span> <span class="keyword">by</span> <span class="literal">zero</span></span><br></pre></td></tr></table></figure>

<p>延迟调用参数在注册时求值或复制，可用指针或闭包 “延迟” 读取。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;defer:&quot;</span>, i, y) <span class="comment">// y 闭包引用</span></span><br><span class="line">    &#125;(x) <span class="comment">// x 被复制</span></span><br><span class="line"></span><br><span class="line">    x += <span class="number">10</span></span><br><span class="line">    y += <span class="number">100</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;x =&quot;</span>, x, <span class="string">&quot;y =&quot;</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span> = <span class="number">20</span> y = <span class="number">120</span></span><br><span class="line"><span class="attribute">defer</span>: <span class="number">10</span> <span class="number">120</span></span><br></pre></td></tr></table></figure>

<p>滥用 defer 可能会导致性能问题，尤其是在一个 “大循环” 里。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> lock sync<span class="selector-class">.Mutex</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">test</span>() &#123;</span><br><span class="line">    lock<span class="selector-class">.Lock</span>()</span><br><span class="line">    lock<span class="selector-class">.Unlock</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">testdefer</span>() &#123;</span><br><span class="line">    lock<span class="selector-class">.Lock</span>()</span><br><span class="line">    defer lock<span class="selector-class">.Unlock</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="built_in">func</span>() &#123;</span><br><span class="line">        t1 := time.<span class="built_in">Now</span>()</span><br><span class="line"></span><br><span class="line">        for i := <span class="number">0</span>; <span class="selector-tag">i</span> &lt; <span class="number">10000</span>; <span class="selector-tag">i</span>++ &#123;</span><br><span class="line">            <span class="built_in">test</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        elapsed := time.<span class="built_in">Since</span>(t1)</span><br><span class="line">        fmt.<span class="built_in">Println</span>(<span class="string">&quot;test elapsed: &quot;</span>, elapsed)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">func</span>() &#123;</span><br><span class="line">        t1 := time.<span class="built_in">Now</span>()</span><br><span class="line"></span><br><span class="line">        for i := <span class="number">0</span>; <span class="selector-tag">i</span> &lt; <span class="number">10000</span>; <span class="selector-tag">i</span>++ &#123;</span><br><span class="line">            <span class="built_in">testdefer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        elapsed := time.<span class="built_in">Since</span>(t1)</span><br><span class="line">        fmt.<span class="built_in">Println</span>(<span class="string">&quot;testdefer elapsed: &quot;</span>, elapsed)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>elapsed:  223.162µs</span><br><span class="line">testdefer elapsed:  781.304µs</span><br></pre></td></tr></table></figure>

<h4 id="defer陷阱"><a href="#defer陷阱" class="headerlink" title="defer陷阱"></a>defer陷阱</h4><h5 id="defer-与-closure"><a href="#defer-与-closure" class="headerlink" title="defer 与 closure"></a>defer 与 closure</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a, b <span class="type">int</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;first defer err %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(err <span class="type">error</span>)</span></span> &#123; fmt.Printf(<span class="string">&quot;second defer err %v\n&quot;</span>, err) &#125;(err)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;third defer err %v\n&quot;</span>, err) &#125;()</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        err = errors.New(<span class="string">&quot;divided by zero!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = a / b</span><br><span class="line">    <span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo(<span class="number">2</span>, <span class="number">0</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">third <span class="keyword">defer</span> err divided by zero!</span><br><span class="line">second <span class="keyword">defer</span> err &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">first <span class="keyword">defer</span> err &lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure>
<p>解释：如果 defer 后面跟的不是一个 closure 最后执行的时候我们得到的并不是最新的值。</p>
<h5 id="defer-与-return"><a href="#defer-与-return" class="headerlink" title="defer 与 return"></a>defer 与 return</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>解释：在有具名返回值的函数中（这里具名返回值为 i），执行 return 2 的时候实际上已经将 i 的值重新赋值为 2。所以defer closure 输出结果为 2 而不是 1。</p>
<h5 id="defer-nil-函数"><a href="#defer-nil-函数" class="headerlink" title="defer nil 函数"></a>defer nil 函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> run <span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">defer</span> run()</span><br><span class="line">    fmt.Println(<span class="string">&quot;runs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runs</span><br><span class="line">runtime <span class="type">error</span>: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure>
<p>解释：名为 test 的函数一直运行至结束，然后 defer 函数会被执行且会因为值为 nil 而产生 panic 异常。然而值得注意的是，run() 的声明是没有问题，因为在test函数运行完成后它才会被调用。</p>
<h5 id="在错误的位置使用-defer"><a href="#在错误的位置使用-defer" class="headerlink" title="在错误的位置使用 defer"></a>在错误的位置使用 defer</h5><p>当 http.Get 失败时会抛出异常。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    res, err := http.Get(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure>

<p>因为在这里我们并没有检查我们的请求是否成功执行，当它失败的时候，我们访问了 Body 中的空变量 res ，因此会抛出异常</p>
<p><strong>解决方案：</strong></p>
<p>总是在一次成功的资源分配下面使用 defer ，对于这种情况来说意味着：当且仅当 http.Get 成功执行时才使用 defer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    res, err := http.Get(<span class="string">&quot;http://xxxxxxxxxx&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的代码中，当有错误的时候，err 会被返回，否则当整个函数返回的时候，会关闭 res.Body 。<br>解释：在这里，你同样需要检查 res 的值是否为 nil ，这是 http.Get 中的一个警告。通常情况下，出错的时候，返回的内容应为空并且错误会被返回，可当你获得的是一个重定向 error 时， res 的值并不会为 nil ，但其又会将错误返回。上面的代码保证了无论如何 Body 都会被关闭，如果你没有打算使用其中的数据，那么你还需要丢弃已经接收的数据。</p>
<h5 id="不检查错误"><a href="#不检查错误" class="headerlink" title="不检查错误"></a>不检查错误</h5><p>在这里，f.Close() 可能会返回一个错误，可这个错误会被我们忽略掉。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">&quot;book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再改进一下通过命名的返回变量来返回 defer 内的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">&quot;book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ferr := f.Close(); ferr != <span class="literal">nil</span> &#123;</span><br><span class="line">                err = ferr</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放相同的资源如果你尝试使用相同的变量释放不同的资源，那么这个操作可能无法正常执行。</p>
<p>当延迟函数执行时，只有最后一个变量会被用到，因此，f 变量 会成为最后那个资源 (another-book.txt)。而且两个 defer 都会将这个资源作为最后的资源来关闭解决方案：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">&quot;book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(f io.Closer)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;defer close book.txt err %v\n&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    f, err = os.Open(<span class="string">&quot;another-book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(f io.Closer)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;defer close another-book.txt err %v\n&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。异常的使用场景简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</p>
<p><strong>panic：</strong></p>
<ol>
<li>内置函数</li>
<li>假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行</li>
<li>返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行</li>
<li>直到goroutine整个退出，并报告错误</li>
</ol>
<p><strong>recover：</strong></p>
<ol>
<li>内置函数</li>
<li>用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</li>
<li>一般的调用建议<pre><code> a). 在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行
 b). 可以获取通过panic传递的error
</code></pre>
</li>
</ol>
<p>注意:</p>
<ol>
<li>利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。否则当panic时，recover无法捕获到panic，无法防止panic扩散。</li>
<li>recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。</li>
<li>多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(err.(<span class="type">string</span>)) <span class="comment">// 将 interface&#123;&#125; 转型为具体类型。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic error!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span> <span class="type">error</span>!</span><br></pre></td></tr></table></figure>
<p>由于 panic、recover 参数类型为 interface{}，因此可抛出任何类型对象。</p>
<p>向已关闭的通道发送数据会引发panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">send</span> <span class="keyword">on</span> <span class="title">closed</span> <span class="title">channel</span></span><br></pre></td></tr></table></figure>
<p>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="built_in">panic</span></span><br></pre></td></tr></table></figure>
<p>捕获函数 recover 只有在延迟调用内直接调用才会终止错误，否则总是返回 nil。任何未捕获的错误都会沿调用堆栈向外传递。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>()) <span class="comment">//有效</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">recover</span>()              <span class="comment">//无效！</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="built_in">recover</span>()) <span class="comment">//无效！</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;defer inner&quot;</span>)</span><br><span class="line">            <span class="built_in">recover</span>() <span class="comment">//无效！</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defer inner</span><br><span class="line">&lt;nil&gt;</span><br><span class="line"><span class="keyword">test </span>panic</span><br></pre></td></tr></table></figure>
<p>使用延迟匿名函数或下面这样都是有效的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">except</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> except()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>panic</span><br></pre></td></tr></table></figure>
<p>如果需要保护代码段，可将代码块重构成匿名函数，如此可确保后续代码被执 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">                z = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">        z = x / y</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;x / y = %d\n&quot;</span>, z)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x / y <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>除用 panic 引发中断性错误外，还可返回 error 类型错误对象来表示函数调用状态。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type <span class="built_in">error</span><span class="built_in"> interface </span>&#123;</span><br><span class="line">    <span class="built_in">Error</span>() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库 errors.New 和 fmt.Errorf 函数用于创建实现 error 接口的错误对象。通过判断错误对象实例来确定具体错误类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrDivByZero = errors.New(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrDivByZero</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x / y, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">switch</span> z, err := div(<span class="number">10</span>, <span class="number">0</span>); err &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="built_in">println</span>(z)</span><br><span class="line">    <span class="keyword">case</span> ErrDivByZero:</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">division </span><span class="keyword">by </span><span class="built_in">zero</span></span><br></pre></td></tr></table></figure>
<p>Go实现类似 try catch 的异常处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Try</span><span class="params">(fun <span class="keyword">func</span>()</span></span>, handler <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            handler(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Try(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>panic</span><br></pre></td></tr></table></figure>
<p>惯例是:导致关键流程出现不可修复性错误的使用 panic，其他使用 error。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。</p>
<ul>
<li>只能为当前包内命名类型定义方法。</li>
<li>参数 receiver 可任意命名。如方法中未曾使用 ，可省略参数名。</li>
<li>参数 receiver 类型可以是 T 或 * T。基类型 T 不能是接口或指针。</li>
<li>不支持方法重载，receiver 只是参数签名的组成部分。</li>
<li>可用实例 value 或 pointer 调用全部方法，编译器自动转换。</li>
</ul>
<p>一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。</p>
<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func</span> (recevier <span class="keyword">type</span>) methodName(参数列表)(返回值列表)&#123;&#125;</span><br><span class="line"></span><br><span class="line">参数和返回值可以省略</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">type Test struct&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、无返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method0</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单参数、无返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method1</span>(i int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数、无返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method2</span>(x, y int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、单返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method3</span>() (i int) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数、多返回值</span></span><br><span class="line">func (t Test) <span class="built_in">method4</span>(x, y int) (z int, err error) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、无返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method5</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单参数、无返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method6</span>(i int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数、无返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method7</span>(x, y int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、单返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method8</span>() (i int) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数、多返回值</span></span><br><span class="line">func (t *Test) <span class="built_in">method9</span>(x, y int) (z int, err error) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下面定义一个结构体类型和该类型的一个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> Notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v : %v \n&quot;</span>, u.Name, u.Email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 值类型调用方法</span></span><br><span class="line">    u1 := User&#123;<span class="string">&quot;golang&quot;</span>, <span class="string">&quot;golang@golang.com&quot;</span>&#125;</span><br><span class="line">    u1.Notify()</span><br><span class="line">    <span class="comment">// 指针类型调用方法</span></span><br><span class="line">    u2 := User&#123;<span class="string">&quot;go&quot;</span>, <span class="string">&quot;go@go.com&quot;</span>&#125;</span><br><span class="line">    u3 := &amp;u2</span><br><span class="line">    u3.Notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">golang : golang@golang.com </span><br><span class="line"><span class="keyword">go</span> : <span class="keyword">go</span>@<span class="keyword">go</span>.com</span><br></pre></td></tr></table></figure>

<p>解释： 首先我们定义了一个叫做 User 的结构体类型，然后定义了一个该类型的方法叫做 Notify，该方法的接受者是一个 User 类型的值。要调用 Notify 方法我们需要一个 User 类型的值或者指针。</p>
<p>在这个例子中当我们使用指针时，Go 调整和解引用指针使得调用可以被执行。注意，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。</p>
<p>我们修改 Notify 方法，让它的接受者使用指针类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> Notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v : %v \n&quot;</span>, u.Name, u.Email)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 值类型调用方法</span></span><br><span class="line">    u1 := User&#123;<span class="string">&quot;golang&quot;</span>, <span class="string">&quot;golang@golang.com&quot;</span>&#125;</span><br><span class="line">    u1.Notify()</span><br><span class="line">    <span class="comment">// 指针类型调用方法</span></span><br><span class="line">    u2 := User&#123;<span class="string">&quot;go&quot;</span>, <span class="string">&quot;go@go.com&quot;</span>&#125;</span><br><span class="line">    u3 := &amp;u2</span><br><span class="line">    u3.Notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">golang : golang@golang.com </span><br><span class="line"><span class="keyword">go</span> : <span class="keyword">go</span>@<span class="keyword">go</span>.com</span><br></pre></td></tr></table></figure>

<p>注意：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作。</p>
<p>方法不过是一种特殊的函数，只需将其还原，就知道 receiver T 和 * T 的差别。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">type Data struct &#123;</span><br><span class="line">    x int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self Data) <span class="built_in">ValueTest</span>() &#123; <span class="comment">// func ValueTest(self Data);</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;Value: %p\n&quot;</span>, &amp;self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (self *Data) <span class="built_in">PointerTest</span>() &#123; <span class="comment">// func PointerTest(self *Data);</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;Pointer: %p\n&quot;</span>, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    d := Data&#123;&#125;</span><br><span class="line">    <span class="selector-tag">p</span> := &amp;d</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;Data: %p\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    d<span class="selector-class">.ValueTest</span>()   <span class="comment">// ValueTest(d)</span></span><br><span class="line">    d<span class="selector-class">.PointerTest</span>() <span class="comment">// PointerTest(&amp;d)</span></span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.ValueTest</span>()   <span class="comment">// ValueTest(*p)</span></span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.PointerTest</span>() <span class="comment">// PointerTest(p)&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Data</span>: <span class="number">0</span>xc42007c008</span><br><span class="line"><span class="attribute">Value</span>: <span class="number">0</span>xc42007c018</span><br><span class="line"><span class="attribute">Pointer</span>: <span class="number">0</span>xc42007c008</span><br><span class="line"><span class="attribute">Value</span>: <span class="number">0</span>xc42007c020</span><br><span class="line"><span class="attribute">Pointer</span>: <span class="number">0</span>xc42007c008</span><br></pre></td></tr></table></figure>

<h3 id="普通函数与方法的区别"><a href="#普通函数与方法的区别" class="headerlink" title="普通函数与方法的区别"></a>普通函数与方法的区别</h3><ol>
<li>对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。</li>
<li>对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数与方法的区别（在接收者分别为值类型和指针类型的时候）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.普通函数//接收值类型参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">valueIntTest</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收指针类型参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pointerIntTest</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structTestValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">2</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;valueIntTest:&quot;</span>, valueIntTest(a))</span><br><span class="line">    <span class="comment">//函数的参数为值类型，则不能直接将指针作为参数传递</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;valueIntTest:&quot;, valueIntTest(&amp;a))</span></span><br><span class="line">    <span class="comment">//compile error: cannot use &amp;a (type *int) as type int in function argument</span></span><br><span class="line"></span><br><span class="line">    b := <span class="number">5</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;pointerIntTest:&quot;</span>, pointerIntTest(&amp;b))</span><br><span class="line">    <span class="comment">//同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(b))</span></span><br><span class="line">    <span class="comment">//compile error:cannot use b (type int) as type *int in function argument&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.方法</span></span><br><span class="line"><span class="keyword">type</span> PersonD <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者为值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PersonD)</span></span> valueShowName() &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者为指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PersonD)</span></span> pointShowName() &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structTestFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//值类型调用方法</span></span><br><span class="line">    personValue := PersonD&#123;<span class="number">101</span>, <span class="string">&quot;hello world&quot;</span>&#125;</span><br><span class="line">    personValue.valueShowName()</span><br><span class="line">    personValue.pointShowName()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针类型调用方法</span></span><br><span class="line">    personPointer := &amp;PersonD&#123;<span class="number">102</span>, <span class="string">&quot;hello golang&quot;</span>&#125;</span><br><span class="line">    personPointer.valueShowName()</span><br><span class="line">    personPointer.pointShowName()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与普通函数不同，接收者为指针类型和值类型的方法，指针类型和值类型的变量均可相互调用&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    structTestValue()</span><br><span class="line">    structTestFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">valueIntTest</span>: <span class="number">12</span></span><br><span class="line"><span class="attribute">pointerIntTest</span>: <span class="number">15</span></span><br><span class="line"><span class="attribute">hello</span> world</span><br><span class="line"><span class="attribute">hello</span> world</span><br><span class="line"><span class="attribute">hello</span> golang</span><br><span class="line"><span class="attribute">hello</span> golang</span><br></pre></td></tr></table></figure>
<h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>Golang匿名字段 ：可以像字段成员那样访问匿名字段方法，编译器负责查找。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span></span> ToString() <span class="type">string</span> &#123; <span class="comment">// receiver = &amp;(Manager.User)</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Manager: %p\n&quot;</span>, &amp;m)</span><br><span class="line">    fmt.Println(m.ToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Manager</span>: <span class="number">0</span>xc42000a060</span><br><span class="line"><span class="attribute">User</span>: <span class="number">0</span>xc42000a060, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure>

<p>通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User</span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span></span> ToString() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Manager)</span></span> ToString() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Manager: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;, <span class="string">&quot;Administrator&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.ToString())</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.User.ToString())&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">Manager: 0xc420074180, &amp;</span><span class="template-variable">&#123;&#123;<span class="name">1</span> Tom&#125; Administrator&#125;</span></span><br><span class="line"><span class="template-variable">User: <span class="number">0</span>xc420074180, &amp;&#123;<span class="number">1</span> Tom&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>Golang方法集 ：每个类型都有与之关联的方法集，这会影响到接口实现规则。</p>
<ul>
<li>类型 T 方法集包含全部 receiver T 方法。</li>
<li>类型 * T 方法集包含全部 receiver T + * T 方法。</li>
<li>如类型 S 包含匿名字段 T，则 S 和 * S 方法集包含 T 方法。 </li>
<li>如类型 S 包含匿名字段 * T，则 S 和 * S 方法集包含 T + * T 方法。</li>
<li>不管嵌入 T 或 * T，* S 方法集总是包含 T + * T 方法。</li>
</ul>
<p>用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。</p>
<p>Go 语言中内部类型方法集提升的规则：类型 T 方法集包含全部 receiver T 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> test() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型 T 方法集包含全部 receiver T 方法。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := T&#123;<span class="number">1</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;t1 is : %v\n&quot;</span>, t1)</span><br><span class="line">    t1.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 <span class="keyword">is</span> : &#123;1&#125;</span><br><span class="line">类型 T 方法集包含全部 receiver T 方法。</span><br></pre></td></tr></table></figure>
<p>类型 * T 方法集包含全部 receiver T + * T 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> testT() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型 *T 方法集包含全部 receiver T 方法。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> testP() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型 *T 方法集包含全部 receiver *T 方法。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := T&#123;<span class="number">1</span>&#125;</span><br><span class="line">    t2 := &amp;t1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;t2 is : %v\n&quot;</span>, t2)</span><br><span class="line">    t2.testT()</span><br><span class="line">    t2.testP()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">t2</span> is <span class="symbol">:</span> &amp;&#123;<span class="number">1</span>&#125;</span><br><span class="line">类型 *<span class="built_in">T</span> 方法集包含全部 receiver <span class="built_in">T</span> 方法。</span><br><span class="line">类型 *<span class="built_in">T</span> 方法集包含全部 receiver *<span class="built_in">T</span> 方法。</span><br></pre></td></tr></table></figure>

<p>给定一个结构体类型 S 和一个命名为 T 的类型，方法提升像下面规定的这样被包含在结构体方法集中：<br>如类型 S 包含匿名字段 T，则 S 和 * S 方法集包含 T 方法。<br>这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为值类型的方法将被提升，可以被外部类型的值和指针调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> testT() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := S&#123;T&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">    s2 := &amp;s1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s1 is : %v\n&quot;</span>, s1)</span><br><span class="line">    s1.testT()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s2 is : %v\n&quot;</span>, s2)</span><br><span class="line">    s2.testT()&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">s1 is : </span><span class="template-variable">&#123;&#123;<span class="name">1</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</span></span><br><span class="line"><span class="language-xml">s2 is : &amp;</span><span class="template-variable">&#123;&#123;<span class="name">1</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</span></span><br></pre></td></tr></table></figure>
<p>如类型 S 包含匿名字段 * T，则 S 和 * S 方法集包含 T + * T 方法。</p>
<p>这条规则说的是当我们嵌入一个类型的指针，嵌入类型的接受者为值类型或指针类型的方法将被提升，可以被外部类型的值或者指针调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> testT() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> testP() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := S&#123;T&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">    s2 := &amp;s1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s1 is : %v\n&quot;</span>, s1)</span><br><span class="line">    s1.testT()</span><br><span class="line">    s1.testP()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s2 is : %v\n&quot;</span>, s2)</span><br><span class="line">    s2.testT()</span><br><span class="line">    s2.testP()&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">s1</span> is <span class="symbol">:</span> &#123;&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">如类型 S 包含匿名字段 *<span class="built_in">T</span>，则 S 和 *S 方法集包含 <span class="built_in">T</span> 方法</span><br><span class="line">如类型 S 包含匿名字段 *<span class="built_in">T</span>，则 S 和 *S 方法集包含 *<span class="built_in">T</span> 方法</span><br><span class="line"><span class="symbol">s2</span> is <span class="symbol">:</span> &amp;&#123;&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">如类型 S 包含匿名字段 *<span class="built_in">T</span>，则 S 和 *S 方法集包含 <span class="built_in">T</span> 方法</span><br><span class="line">如类型 S 包含匿名字段 *<span class="built_in">T</span>，则 S 和 *S 方法集包含 *<span class="built_in">T</span> 方法</span><br></pre></td></tr></table></figure>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>Golang 表达式 ：根据调用者不同，方法分为两种表现形式:</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">instance</span>.method(args...) ---&gt; &lt;<span class="keyword">type</span>&gt;.<span class="keyword">func</span>(<span class="keyword">instance</span>, args...)</span><br></pre></td></tr></table></figure>
<p>前者称为 method value，后者 method expression。<br>两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span></span> Test() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">    u.Test()</span><br><span class="line"></span><br><span class="line">    mValue := u.Test</span><br><span class="line">    mValue() <span class="comment">// 隐式传递 receiver</span></span><br><span class="line"></span><br><span class="line">    mExpression := (*User).Test</span><br><span class="line">    mExpression(&amp;u) <span class="comment">// 显式传递 receiver&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>xc42000a060, <span class="meta">&amp;&#123;1 Tom&#125;</span></span><br><span class="line"><span class="number">0</span>xc42000a060, <span class="meta">&amp;&#123;1 Tom&#125;</span></span><br><span class="line"><span class="number">0</span>xc42000a060, <span class="meta">&amp;&#123;1 Tom&#125;</span></span><br></pre></td></tr></table></figure>
<p>需要注意，method value 会复制 receiver。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self User)</span></span> Test() &#123;</span><br><span class="line">    fmt.Println(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">    mValue := u.Test <span class="comment">// 立即复制 receiver，因为不是指针类型，不受后续修改影响。</span></span><br><span class="line"></span><br><span class="line">    u.id, u.name = <span class="number">2</span>, <span class="string">&quot;Jack&quot;</span></span><br><span class="line">    u.Test()</span><br><span class="line"></span><br><span class="line">    mValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;2 Jack&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-variable">&#123;1 Tom&#125;</span></span><br></pre></td></tr></table></figure>

<p>在汇编层面，method value 和闭包的实现方式相同，实际返回 FuncVal 类型对象。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">FuncVal </span><span class="template-variable">&#123; method_address, receiver_copy &#125;</span></span><br></pre></td></tr></table></figure>

<p>可依据方法集转换 method expression，注意 receiver 类型的差异。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span></span> TestPointer() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;TestPointer: %p, %v\n&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self User)</span></span> TestValue() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;TestValue: %p, %v\n&quot;</span>, &amp;self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;User: %p, %v\n&quot;</span>, &amp;u, u)</span><br><span class="line"></span><br><span class="line">    mv := User.TestValue</span><br><span class="line">    mv(u)</span><br><span class="line"></span><br><span class="line">    mp := (*User).TestPointer</span><br><span class="line">    mp(&amp;u)</span><br><span class="line"></span><br><span class="line">    mp2 := (*User).TestValue <span class="comment">// *User 方法集包含 TestValue。签名变为 func TestValue(self *User)。实际依然是 receiver value copy。</span></span><br><span class="line">    mp2(&amp;u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User</span>: <span class="number">0</span>xc42000a060, &#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="attribute">TestValue</span>: <span class="number">0</span>xc42000a0a0, &#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="attribute">TestPointer</span>: <span class="number">0</span>xc42000a060, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="attribute">TestValue</span>: <span class="number">0</span>xc42000a100, &#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure>
<p>将方法 “还原” 成函数，就容易理解下面的代码了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Data)</span></span> TestValue() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Data)</span></span> TestPointer() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *Data = <span class="literal">nil</span></span><br><span class="line">    p.TestPointer()</span><br><span class="line"></span><br><span class="line">    (*Data)(<span class="literal">nil</span>).TestPointer() <span class="comment">// method value</span></span><br><span class="line">    (*Data).TestPointer(<span class="literal">nil</span>)   <span class="comment">// method expression</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p.TestValue()            // invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Data)(nil).TestValue()  // cannot convert nil to type Data</span></span><br><span class="line">    <span class="comment">// Data.TestValue(nil)      // cannot use nil as type Data in function argument&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义error"><a href="#自定义error" class="headerlink" title="自定义error"></a>自定义error</h2><h3 id="系统抛"><a href="#系统抛" class="headerlink" title="系统抛"></a>系统抛</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统抛</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">   a[<span class="number">1</span>] = <span class="number">123</span></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">   <span class="comment">//a[10] = 11</span></span><br><span class="line">   index := <span class="number">10</span></span><br><span class="line">   a[index] = <span class="number">10</span></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCircleArea</span><span class="params">(radius <span class="type">float32</span>)</span></span> (area <span class="type">float32</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 自己抛</span></span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;半径不能为负&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span> &#123;</span><br><span class="line">   getCircleArea(<span class="number">-5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test03</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 延时执行匿名函数</span></span><br><span class="line">   <span class="comment">// 延时到何时？（1）程序正常结束   （2）发生异常时</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// recover() 复活 恢复</span></span><br><span class="line">      <span class="comment">// 会返回程序为什么挂了</span></span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   getCircleArea(<span class="number">-5</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;这里有没有执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test04</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   test03()</span><br><span class="line">   fmt.Println(<span class="string">&quot;test04&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test04()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回异常"><a href="#返回异常" class="headerlink" title="返回异常"></a>返回异常</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;errors&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCircleArea</span><span class="params">(radius <span class="type">float32</span>)</span></span> (area <span class="type">float32</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 构建个异常对象</span></span><br><span class="line">      err = errors.New(<span class="string">&quot;半径不能为负&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   area = <span class="number">3.14</span> * radius * radius</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   area, err := getCircleArea(<span class="number">-5</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(area)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义error-1"><a href="#自定义error-1" class="headerlink" title="自定义error"></a>自定义error</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    path       <span class="type">string</span></span><br><span class="line">    op         <span class="type">string</span></span><br><span class="line">    createTime <span class="type">string</span></span><br><span class="line">    message    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;path=%s \nop=%s \ncreateTime=%s \nmessage=%s&quot;</span>, p.path,</span><br><span class="line">        p.op, p.createTime, p.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(filename <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">    file, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;PathError&#123;</span><br><span class="line">            path:       filename,</span><br><span class="line">            op:         <span class="string">&quot;read&quot;</span>,</span><br><span class="line">            message:    err.Error(),</span><br><span class="line">            createTime: fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, time.Now()),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := Open(<span class="string">&quot;/Users/5lmh/Desktop/go/src/test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">switch</span> v := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *PathError:</span><br><span class="line">        fmt.Println(<span class="string">&quot;get path error,&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get path error, path=<span class="regexp">/Users/</span>pprof<span class="regexp">/Desktop/g</span>o<span class="regexp">/src/</span>test.txt </span><br><span class="line">op=<span class="keyword">read</span> </span><br><span class="line">createTime=<span class="number">2018</span>-<span class="number">04</span>-<span class="number">05</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">17.331915</span> +<span class="number">0800</span> CST m=+<span class="number">0.000441790</span> </span><br><span class="line">message=open <span class="regexp">/Users/</span>pprof<span class="regexp">/Desktop/g</span>o<span class="regexp">/src/</span>test.txt: no such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="匿名字段-1"><a href="#匿名字段-1" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex  <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    addr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    s1 := Student&#123;Person&#123;<span class="string">&quot;5lmh&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">20</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">    s2 := Student&#123;Person: Person&#123;<span class="string">&quot;5lmh&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">20</span>&#125;&#125;</span><br><span class="line">    fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">    s3 := Student&#123;Person: Person&#123;name: <span class="string">&quot;5lmh&quot;</span>&#125;&#125;</span><br><span class="line">    fmt.Println(s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;<span class="name">5lmh</span> man <span class="number">20</span>&#125; <span class="number">1</span> bj&#125;</span></span><br><span class="line"><span class="template-variable">&#123;&#123;<span class="number">5</span>lmh man <span class="number">20</span>&#125; <span class="number">0</span> &#125;</span></span><br><span class="line"><span class="template-variable">&#123;&#123;<span class="number">5</span>lmh  <span class="number">0</span>&#125; <span class="number">0</span> &#125;</span></span><br></pre></td></tr></table></figure>

<p>同名字段的情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex  <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    addr <span class="type">string</span></span><br><span class="line">    <span class="comment">//同名字段</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student</span><br><span class="line">    <span class="comment">// 给自己字段赋值了</span></span><br><span class="line">    s.name = <span class="string">&quot;5lmh&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若给父类同名字段赋值，如下</span></span><br><span class="line">    s.Person.name = <span class="string">&quot;枯藤&quot;</span></span><br><span class="line">    fmt.Println(s)&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;  <span class="name">0</span>&#125; <span class="number">0</span>  <span class="number">5</span>lmh&#125;</span></span><br><span class="line"><span class="template-variable">&#123;&#123;枯藤  <span class="number">0</span>&#125; <span class="number">0</span>  <span class="number">5</span>lmh&#125;</span></span><br></pre></td></tr></table></figure>

<p>所有的内置类型和自定义类型都是可以作为匿名字段去使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex  <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">type</span> mystr <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">    mystr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;Person&#123;<span class="string">&quot;5lmh&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;<span class="name">5lmh</span> man <span class="number">18</span>&#125; <span class="number">1</span> bj&#125;</span></span><br></pre></td></tr></table></figure>

<p>指针类型匿名字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex  <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Person</span><br><span class="line">    id   <span class="type">int</span></span><br><span class="line">    addr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;&amp;Person&#123;<span class="string">&quot;5lmh&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">    fmt.Println(s1.name)</span><br><span class="line">    fmt.Println(s1.Person.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>xc<span class="number">00005c360</span> <span class="number">1</span> bj&#125;</span><br><span class="line">zs</span><br><span class="line">zs</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。<br>interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。<br>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。</p>
<h3 id="为什么要使用接口"><a href="#为什么要使用接口" class="headerlink" title="为什么要使用接口"></a>为什么要使用接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Say() <span class="type">string</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;喵喵喵&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Say() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;汪汪汪&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Cat&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;猫:&quot;</span>, c.Say())</span><br><span class="line">    d := Dog&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;狗:&quot;</span>, d.Say())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？<br>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p>
<h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>Go语言提倡面向接口编程。</p>
<p>接口是一个或多个方法签名的集合。<br>    任何类型的方法集中只要拥有该接口’对应的全部方法’签名。<br>    就表示它 “实现” 了该接口，无须在该类型上显式声明实现了哪个接口。<br>    这称为Structural Typing。<br>    所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。<br>    当然，该类型还可以有其他方法。</p>
<pre><code>接口只有方法声明，没有实现，没有数据字段。
接口可以匿名嵌入其他接口，或嵌入到结构中。
对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。
只有当接口存储的类型和对象都为nil时，接口才等于nil。
接口调用不会做receiver的自动转换。
接口同样支持匿名字段方法。
接口也可实现类似OOP中的多态。
空接口可以作为任何类型数据的容器。
一个类型可实现多个接口。
接口命名习惯以 er 结尾。
</code></pre>
<p>每个接口由数个方法组成，接口的定义格式如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">接口类型名 </span><span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>   1.接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。<br>    2.方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。<br>    3.参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</p>
<h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h3><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。我们来定义一个Sayer接口：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Sayer 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Sayer </span><span class="keyword">interface</span> &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义dog和cat两个结构体：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog struct &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat struct &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line">func (d dog) <span class="built_in">say</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(&quot;汪汪汪&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line">func (c cat) <span class="built_in">say</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(&quot;喵喵喵&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。</p>
<h3 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h3><p>那实现了接口有什么用呢？接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    var x Sayer <span class="regexp">//</span> 声明一个Sayer类型的变量x</span><br><span class="line">    a := cat&#123;&#125;  <span class="regexp">//</span> 实例化一个cat</span><br><span class="line">    b := dog&#123;&#125;  <span class="regexp">//</span> 实例化一个dog</span><br><span class="line">    x = a       <span class="regexp">//</span> 可以把cat实例直接赋值给x</span><br><span class="line">    x.say()     <span class="regexp">//</span> 喵喵喵</span><br><span class="line">    x = b       <span class="regexp">//</span> 可以把dog实例直接赋值给x</span><br><span class="line">    x.say()     <span class="regexp">//</span> 汪汪汪</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h3><p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。我们有一个Mover接口和一个dog结构体。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Mover</span> interface &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog struct &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时实现接口的是dog类型：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    var x Mover</span><br><span class="line">    var wangcai = dog&#123;&#125; <span class="regexp">//</span> 旺财是dog类型</span><br><span class="line">    x = wangcai         <span class="regexp">//</span> x可以接收dog类型</span><br><span class="line">    var fugui = &amp;dog&#123;&#125;  <span class="regexp">//</span> 富贵是*dog类型</span><br><span class="line">    x = fugui           <span class="regexp">//</span> x可以接收*dog类型</span><br><span class="line">    x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针* dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值* fugui。</p>
<h4 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h4><p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span></span> move() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;狗会动&quot;</span>)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x Mover</span><br><span class="line">    <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">    x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line">    <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">    x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时实现Mover接口的是* dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储* dog类型的值。</p>
<h4 id="下面的代码是一个比较好的面试题"><a href="#下面的代码是一个比较好的面试题" class="headerlink" title="下面的代码是一个比较好的面试题"></a>下面的代码是一个比较好的面试题</h4><p>请问下面的代码是否能通过编译？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak(<span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Stduent)</span></span> Speak(think <span class="type">string</span>) (talk <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> think == <span class="string">&quot;sb&quot;</span> &#123;</span><br><span class="line">        talk = <span class="string">&quot;你是个大帅比&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        talk = <span class="string">&quot;您好&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> peo People = Student&#123;&#125;</span><br><span class="line">    think := <span class="string">&quot;bitch&quot;</span></span><br><span class="line">    fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h3><h4 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a>一个类型实现多个接口</h4><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： Mover接口。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Sayer 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Sayer </span><span class="keyword">interface</span> &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Mover 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Mover </span><span class="keyword">interface</span> &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dog既可以实现Sayer接口，也可以实现Mover接口。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type dog struct &#123;</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Sayer接口</span></span><br><span class="line">func (d dog) <span class="built_in">say</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%s会叫汪汪汪\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Mover接口</span></span><br><span class="line">func (d dog) <span class="built_in">move</span>() &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;%s会动\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> x Sayer</span><br><span class="line">    <span class="selector-tag">var</span> y Mover</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">    x = <span class="selector-tag">a</span></span><br><span class="line">    y = <span class="selector-tag">a</span></span><br><span class="line">    x<span class="selector-class">.say</span>()</span><br><span class="line">    y<span class="selector-class">.move</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多个类型实现同一接口"><a href="#多个类型实现同一接口" class="headerlink" title="多个类型实现同一接口"></a>多个类型实现同一接口</h4><p>Go语言中不同的类型还可以实现同一接口 首先我们定义一个Mover接口，它要求必须由一个move方法。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Mover 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Mover </span><span class="keyword">interface</span> &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> car <span class="keyword">struct</span> &#123;</span><br><span class="line">    brand <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog类型实现Mover接口</span></span><br><span class="line">func (d dog) move<span class="literal">()</span> &#123;</span><br><span class="line">    fmt.<span class="constructor">Printf(<span class="string">&quot;%s会跑\n&quot;</span>, <span class="params">d</span>.<span class="params">name</span>)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// car类型实现Mover接口</span></span><br><span class="line">func (c car) move<span class="literal">()</span> &#123;</span><br><span class="line">    fmt.<span class="constructor">Printf(<span class="string">&quot;%s速度70迈\n&quot;</span>, <span class="params">c</span>.<span class="params">brand</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> x Mover</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> = car&#123;brand: <span class="string">&quot;保时捷&quot;</span>&#125;</span><br><span class="line">    x = <span class="selector-tag">a</span></span><br><span class="line">    x<span class="selector-class">.move</span>()</span><br><span class="line">    x = <span class="selector-tag">b</span></span><br><span class="line">    x<span class="selector-class">.move</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码执行结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旺财会跑</span><br><span class="line">保时捷速度70迈</span><br></pre></td></tr></table></figure>

<p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WashingMachine 洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">    wash()</span><br><span class="line">    dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干器</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> dry() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">    dryer <span class="comment">//嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span></span> wash() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h3><p>接口与接口间可以通过嵌套创造出新的接口。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Sayer</span> 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Sayer</span> interface &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="type">Mover</span> 接口</span><br><span class="line"><span class="keyword">type</span> <span class="type">Mover</span> interface &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接口嵌套</span><br><span class="line"><span class="keyword">type</span> animal interface &#123;</span><br><span class="line">    <span class="type">Sayer</span></span><br><span class="line">    <span class="type">Mover</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> move() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;猫会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x animal</span><br><span class="line">    x = cat&#123;name: <span class="string">&quot;花花&quot;</span>&#125;</span><br><span class="line">    x.move()</span><br><span class="line">    x.say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><h4 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a>空接口的定义</h4><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。<br>空接口类型的变量可以存储任意类型的变量。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 定义一个空接口x</span></span><br><span class="line">    <span class="selector-tag">var</span> x interface&#123;&#125;</span><br><span class="line">    s := <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    x = s</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">    <span class="selector-tag">i</span> := <span class="number">100</span></span><br><span class="line">    x = <span class="selector-tag">i</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">    <span class="selector-tag">b</span> := true</span><br><span class="line">    x = <span class="selector-tag">b</span></span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h4><h5 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h5><p>使用空接口实现可以接收任意类型的函数参数。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line">func <span class="built_in">show</span>(<span class="selector-tag">a</span> interface&#123;&#125;) &#123;</span><br><span class="line">    fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;type:%T value:%v\n&quot;</span>, <span class="selector-tag">a</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="空接口作为map的值"><a href="#空接口作为map的值" class="headerlink" title="空接口作为map的值"></a>空接口作为map的值</h5><p>使用空接口实现可以保存任意值的字典。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line">    <span class="selector-tag">var</span> studentInfo = <span class="built_in">make</span>(map<span class="selector-attr">[string]</span>interface&#123;&#125;)</span><br><span class="line">    studentInfo<span class="selector-attr">[<span class="string">&quot;name&quot;</span>]</span> = <span class="string">&quot;李白&quot;</span></span><br><span class="line">    studentInfo<span class="selector-attr">[<span class="string">&quot;age&quot;</span>]</span> = <span class="number">18</span></span><br><span class="line">    studentInfo<span class="selector-attr">[<span class="string">&quot;married&quot;</span>]</span> = false</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(studentInfo)</span><br></pre></td></tr></table></figure>

<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？</p>
<h5 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h5><p>一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。我们来看一个具体的例子：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line"><span class="attribute">w</span> <span class="operator">=</span> os.Stdout</span><br><span class="line"><span class="attribute">w</span> <span class="operator">=</span> new(bytes.Buffer)</span><br><span class="line"><span class="attribute">w</span> <span class="operator">=</span> nil</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80.png"></p>
<p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<p>其中：<br>    x：表示类型为interface{}的变量<br>    T：表示断言x可能是的类型。</p>
<p>该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    x = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    v, ok := x.(<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例中如果要断言多次就需要写多个if判断，这个时候我们可以使用switch语句来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="GORM"><a href="#GORM" class="headerlink" title="GORM"></a>GORM</h2><h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><ul>
<li>全特性 ORM (几乎包含所有特性)</li>
<li>模型关联 (一对一， 一对多，一对多（反向）， 多对多， 多态关联)</li>
<li>钩子 (Before/After Create/Save/Update/Delete/Find)</li>
<li>预加载</li>
<li>事务</li>
<li>复合主键</li>
<li>SQL 构造器</li>
<li>自动迁移</li>
<li>日志</li>
<li>基于GORM回调编写可扩展插件</li>
<li>全特性测试覆盖</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/jinzhu/gorm</span><br></pre></td></tr></table></figure>

<h4 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product struct &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Code string</span><br><span class="line">  Price uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  <span class="keyword">db</span>, <span class="keyword">err</span> := gorm.<span class="keyword">Open</span>(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;test.db&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    panic(<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  defer <span class="keyword">db</span>.<span class="keyword">Close</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自动检查 Product 结构是否变化，变化则进行迁移</span></span><br><span class="line">  <span class="keyword">db</span>.AutoMigrate(&amp;Product&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增</span></span><br><span class="line">  <span class="keyword">db</span>.Create(&amp;Product&#123;Code: <span class="string">&quot;L1212&quot;</span>, Price: 1000&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查</span></span><br><span class="line">  <span class="keyword">var</span> product Product</span><br><span class="line">  <span class="keyword">db</span>.First(&amp;product, 1) <span class="comment">// 找到id为1的产品</span></span><br><span class="line">  <span class="keyword">db</span>.First(&amp;product, <span class="string">&quot;code = ?&quot;</span>, <span class="string">&quot;L1212&quot;</span>) <span class="comment">// 找出 code 为 l1212 的产品</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 改 - 更新产品的价格为 2000</span></span><br><span class="line">  <span class="keyword">db</span>.Model(&amp;product).<span class="keyword">Update</span>(<span class="string">&quot;Price&quot;</span>, 2000)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删 - 删除产品</span></span><br><span class="line">  <span class="keyword">db</span>.Delete(&amp;product)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p>模型一般都是普通的 Golang 的结构体，Go的基本数据类型，或者指针。sql.Scanner 和 driver.Valuer，同时也支持接口。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm<span class="variable">.Model</span></span><br><span class="line">  Name         <span class="keyword">string</span></span><br><span class="line">  Age          sql<span class="variable">.NullInt64</span></span><br><span class="line">  Birthday     *<span class="keyword">time</span><span class="variable">.Time</span></span><br><span class="line">  Email        <span class="keyword">string</span>  `gorm:<span class="string">&quot;type:varchar(100);unique_index&quot;</span>`</span><br><span class="line">  Role         <span class="keyword">string</span>  `gorm:<span class="string">&quot;size:255&quot;</span>` <span class="comment">//设置字段的大小为255个字节</span></span><br><span class="line">  MemberNumber *<span class="keyword">string</span> `gorm:<span class="string">&quot;unique;not null&quot;</span>` <span class="comment">// 设置 memberNumber 字段唯一且不为空</span></span><br><span class="line">  Num          <span class="keyword">int</span>     `gorm:<span class="string">&quot;AUTO_INCREMENT&quot;</span>` <span class="comment">// 设置 Num字段自增</span></span><br><span class="line">  Address      <span class="keyword">string</span>  `gorm:<span class="string">&quot;index:addr&quot;</span>` <span class="comment">// 给Address 创建一个名字是  `addr`的索引</span></span><br><span class="line">  IgnoreMe     <span class="keyword">int</span>     `gorm:<span class="string">&quot;-&quot;</span>` <span class="comment">//忽略这个字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h4><p>标签是声明模型时可选的标记。GORM 支持以下标记：</p>
<h5 id="支持的结构标签"><a href="#支持的结构标签" class="headerlink" title="支持的结构标签"></a><strong>支持的结构标签</strong></h5><table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Column</td>
<td>指定列的名称</td>
</tr>
<tr>
<td>Type</td>
<td>指定列的类型</td>
</tr>
<tr>
<td>Size</td>
<td>指定列的大小，默认是 255</td>
</tr>
<tr>
<td>PRIMARY_KEY</td>
<td>指定一个列作为主键</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>指定一个唯一的列</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>指定一个列的默认值</td>
</tr>
<tr>
<td>PRECISION</td>
<td>指定列的数据的精度</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>指定列的数据不为空</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>指定一个列的数据是否自增</td>
</tr>
<tr>
<td>INDEX</td>
<td>创建带或不带名称的索引，同名创建复合索引</td>
</tr>
<tr>
<td>UNIQUE_INDEX</td>
<td>类似 索引，创建一个唯一的索引</td>
</tr>
<tr>
<td>EMBEDDED</td>
<td>将 struct 设置为 embedded</td>
</tr>
<tr>
<td>EMBEDDED_PREFIX</td>
<td>设置嵌入式结构的前缀名称</td>
</tr>
<tr>
<td>-</td>
<td>忽略这些字段</td>
</tr>
</tbody></table>
<h5 id="关联的结构标签"><a href="#关联的结构标签" class="headerlink" title="关联的结构标签"></a>关联的结构标签</h5><table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MANY2MANY</td>
<td>指定连接表名称</td>
</tr>
<tr>
<td>FOREIGNKEY</td>
<td>指定外键</td>
</tr>
<tr>
<td>ASSOCIATION_FOREIGNKEY</td>
<td>指定关联外键</td>
</tr>
<tr>
<td>POLYMORPHIC</td>
<td>指定多态类型</td>
</tr>
<tr>
<td>POLYMORPHIC_VALUE</td>
<td>指定多态的值</td>
</tr>
<tr>
<td>JOINTABLE_FOREIGNKEY</td>
<td>指定连接表的外键</td>
</tr>
<tr>
<td>ASSOCIATION_JOINTABLE_FOREIGNKEY</td>
<td>指定连接表的关联外键</td>
</tr>
<tr>
<td>SAVE_ASSOCIATIONS</td>
<td>是否自动保存关联</td>
</tr>
<tr>
<td>ASSOCIATION_AUTOUPDATE</td>
<td>是否自动更新关联</td>
</tr>
<tr>
<td>ASSOCIATION_AUTOCREATE</td>
<td>是否自动创建关联</td>
</tr>
<tr>
<td>ASSOCIATION_SAVE_REFERENCE</td>
<td>是否引用自动保存的关联</td>
</tr>
<tr>
<td>PRELOAD</td>
<td>是否自动预加载关联</td>
</tr>
</tbody></table>
<h3 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h3><h4 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h4><p>gorm.Model 是一个包含一些基本字段的结构体, 包含的字段有 ID，CreatedAt， UpdatedAt， DeletedAt。</p>
<p>你可以用它来嵌入到你的模型中，或者也可以用它来建立自己的模型。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// gorm.<span class="type">Model</span> 定义</span><br><span class="line"><span class="keyword">type</span> <span class="type">Model</span> struct &#123;</span><br><span class="line">  <span class="type">ID</span>        uint `gorm:&quot;primary_key&quot;`</span><br><span class="line">  <span class="type">CreatedAt</span> time.<span class="type">Time</span></span><br><span class="line">  <span class="type">UpdatedAt</span> time.<span class="type">Time</span></span><br><span class="line">  <span class="type">DeletedAt</span> *time.<span class="type">Time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将字段 `<span class="type">ID</span>`, `<span class="type">CreatedAt</span>`, `<span class="type">UpdatedAt</span>`, `<span class="type">DeletedAt</span>` 注入到 `<span class="type">User</span>` 模型中</span><br><span class="line"><span class="keyword">type</span> <span class="type">User</span> struct &#123;</span><br><span class="line">  gorm.<span class="type">Model</span></span><br><span class="line">  <span class="type">Name</span> string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明 gorm.<span class="type">Model</span> 模型</span><br><span class="line"><span class="keyword">type</span> <span class="type">User</span> struct &#123;</span><br><span class="line">  <span class="type">ID</span>   int</span><br><span class="line">  <span class="type">Name</span> string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ID-作为主键"><a href="#ID-作为主键" class="headerlink" title="ID 作为主键"></a>ID 作为主键</h4><p>GORM 默认使用 ID 作为主键名。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">User</span> struct &#123;</span><br><span class="line">  <span class="type">ID</span>   string // 字段名 `<span class="type">ID</span>` 将被作为默认的主键名</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置字段 `<span class="type">AnimalID</span>` 为默认主键</span><br><span class="line"><span class="keyword">type</span> <span class="type">Animal</span> struct &#123;</span><br><span class="line">  <span class="type">AnimalID</span> int64 `gorm:&quot;primary_key&quot;`</span><br><span class="line">  <span class="type">Name</span>     string</span><br><span class="line">  <span class="type">Age</span>      int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复数表名"><a href="#复数表名" class="headerlink" title="复数表名"></a>复数表名</h4><p>表名是结构体名称的复数形式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认的表名是 `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 `User` 的表名为 `profiles`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;profiles&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin_users&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;users&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果设置禁用表名复数形式属性为 true，`User` 的表名将是 `user`</span></span><br><span class="line">db.SingularTable(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h4 id="指定表名"><a href="#指定表名" class="headerlink" title="指定表名"></a>指定表名</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 用 `<span class="keyword">User</span>` 结构体创建 `delete_users` 表</span><br><span class="line">db.<span class="keyword">Table</span>(&quot;deleted_users&quot;).CreateTable(&amp;<span class="keyword">User</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">var deleted_users []<span class="keyword">User</span></span><br><span class="line">db.<span class="keyword">Table</span>(&quot;deleted_users&quot;).Find(&amp;deleted_users)</span><br><span class="line">//// <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> deleted_users;</span><br><span class="line"></span><br><span class="line">db.<span class="keyword">Table</span>(&quot;deleted_users&quot;).<span class="keyword">Where</span>(&quot;name = ?&quot;, &quot;jinzhu&quot;).<span class="keyword">Delete</span>()</span><br><span class="line">//// <span class="keyword">DELETE</span> <span class="keyword">FROM</span> deleted_users <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;jinzhu&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="修改默认表名"><a href="#修改默认表名" class="headerlink" title="修改默认表名"></a>修改默认表名</h4><p>你可以通过定义 DefaultTableNameHandler 字段来对表名使用任何规则。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gorm.DefaultTableNameHandler = <span class="function"><span class="keyword">func</span> <span class="params">(db *gorm.DB, defaultTableName <span class="type">string</span>)</span></span> <span class="type">string</span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;prefix_&quot;</span> + defaultTableName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="蛇形列名"><a href="#蛇形列名" class="headerlink" title="蛇形列名"></a>蛇形列名</h4><p>列名是字段名的蛇形小写形式</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">  ID        uint      // 字段名是 `id`</span><br><span class="line">  Name      string    // 字段名是 `name`</span><br><span class="line">  Birthday  time.Time // 字段名是 `birthday`</span><br><span class="line">  CreatedAt time.Time // 字段名是 `created_at`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写列名</span><br><span class="line">type Animal struct &#123;</span><br><span class="line"><span class="title">    AnimalId    int64     `gorm:</span><span class="string">&quot;column:beast_id&quot;</span>`         // 设置列名为 `beast_id`</span><br><span class="line"><span class="title">    Birthday    time.Time `gorm:</span><span class="string">&quot;column:day_of_the_beast&quot;</span>` // 设置列名为 `day_of_the_beast`</span><br><span class="line"><span class="title">    Age         int64     `gorm:</span><span class="string">&quot;column:age_of_the_beast&quot;</span>` // 设置列名为 `age_of_the_beast`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间戳跟踪"><a href="#时间戳跟踪" class="headerlink" title="时间戳跟踪"></a>时间戳跟踪</h4><h5 id="CreatedAt"><a href="#CreatedAt" class="headerlink" title="CreatedAt"></a>CreatedAt</h5><p>对于有 CreatedAt 字段的模型，它将被设置为首次创建记录的当前时间。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="constructor">Create(&amp;<span class="params">user</span>)</span> <span class="comment">// 将设置 `CreatedAt` 为当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以使用 `Update` 方法来更改默认时间</span></span><br><span class="line">db.<span class="constructor">Model(&amp;<span class="params">user</span>)</span>.<span class="constructor">Update(<span class="string">&quot;CreatedAt&quot;</span>, <span class="params">time</span>.Now()</span>)</span><br></pre></td></tr></table></figure>

<h5 id="UpdatedAt"><a href="#UpdatedAt" class="headerlink" title="UpdatedAt"></a>UpdatedAt</h5><p>对于有 UpdatedAt 字段的模型，它将被设置为记录更新时的当前时间。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="constructor">Save(&amp;<span class="params">user</span>)</span> <span class="comment">// 将设置 `UpdatedAt` 为当前时间</span></span><br><span class="line"></span><br><span class="line">db.<span class="constructor">Model(&amp;<span class="params">user</span>)</span>.<span class="constructor">Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span> <span class="comment">// 将设置 `UpdatedAt` 为当前时间</span></span><br></pre></td></tr></table></figure>

<h5 id="DeletedAt"><a href="#DeletedAt" class="headerlink" title="DeletedAt"></a>DeletedAt</h5><p>对于有 DeletedAt 字段的模型，当删除它们的实例时，它们并没有被从数据库中删除，只是将 DeletedAt 字段设置为当前时间。参考 Soft Delete</p>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>为了连接数据库，你首先要导入数据库驱动程序。例如：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="literal">_</span> <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br></pre></td></tr></table></figure>

<p>GORM 已经包含了一些驱动程序，为了方便的去记住它们的导入路径，你可以像下面这样导入 mysql 驱动程序</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line"><span class="regexp">//</span> import _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line"><span class="regexp">//</span> import _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line"><span class="regexp">//</span> import _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mssql&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="支持的数据库"><a href="#支持的数据库" class="headerlink" title="支持的数据库"></a>支持的数据库</h4><h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><p>注意： 为了正确的处理 time.Time ，你需要包含 parseTime 作为参数。 (More supported parameters)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;host=myhost port=myport user=gorm dbname=gorm password=mypassword&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Sqlite3"><a href="#Sqlite3" class="headerlink" title="Sqlite3"></a>Sqlite3</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;/tmp/gorm.db&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h5><p><a target="_blank" rel="noopener" href="https://sqlchoice.azurewebsites.net/en-us/sql-server/developer-get-started/go/windows/">Get started with SQL Server</a>，它可以通过 Docker 运行在你的 Mac， Linux 上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mssql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;mssql&quot;</span>, <span class="string">&quot;sqlserver://username:password@localhost:1433?database=dbname&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="并发介绍"><a href="#并发介绍" class="headerlink" title="并发介绍"></a>并发介绍</h2><p>多线程程序在一个核的cpu上运行，就是并发。<br>多线程程序在多个核的cpu上运行，就是并行。</p>
<h3 id="协程和线程"><a href="#协程和线程" class="headerlink" title="协程和线程"></a>协程和线程</h3><p>协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。<br>线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p>
<p>goroutine 只是由官方实现的超级”线程池”。每个实例4~5KB的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因。</p>
<p>并发主要由切换时间片来实现”同时”运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。</p>
<p>goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</p>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。</p>
<h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><p>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p>
<h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">func</span> <span class="function"><span class="title">hello</span>() &#123;</span></span><br><span class="line"><span class="function">    <span class="variable">fmt.Println</span>(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="variable">func</span> <span class="function"><span class="title">main</span>() &#123;</span></span><br><span class="line"><span class="function">    <span class="title">hello</span>()</span></span><br><span class="line">    <span class="variable">fmt.Println</span>(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完Hello Goroutine!后打印main goroutine done!。接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="function">go <span class="title">hello</span>() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span></span><br><span class="line"><span class="function">    fmt.<span class="title">Println</span>(<span class="params"><span class="string">&quot;main goroutine done!&quot;</span></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    go <span class="built_in">hello</span>() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">    <span class="selector-tag">time</span><span class="selector-class">.Sleep</span>(<span class="selector-tag">time</span>.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的代码你会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!。首先为什么会先打印main goroutine done!是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。</p>
<h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">        <span class="keyword">go</span> hello(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p>
<p>注意：</p>
<p>如果主协程退出了，其他任务还执行吗（运行下面的代码测试一下吧）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 合起来写</span></span><br><span class="line">    go <span class="built_in">func</span>() &#123;</span><br><span class="line">        <span class="selector-tag">i</span> := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">            fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">            <span class="selector-tag">time</span><span class="selector-class">.Sleep</span>(<span class="selector-tag">time</span>.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="selector-tag">i</span> := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt<span class="selector-class">.Printf</span>(<span class="string">&quot;main goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">        <span class="selector-tag">time</span><span class="selector-class">.Sleep</span>(<span class="selector-tag">time</span>.Second)</span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">i</span> == <span class="number">2</span> &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h3><h4 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h4><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</p>
<h4 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h4><p>GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ol>
<li>G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li>P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li>M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>
</ol>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
<h2 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h2><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p>让出CPU时间片，重新等待安排任务(大概意思就是本来计划的好好的周末出去烧烤，但是你妈让你去相亲,两种情况第一就是你相亲速度非常快，见面就黄不耽误你继续烧烤，第二种情况就是你相亲速度特别慢，见面就是你侬我侬的，耽误了烧烤，但是还馋就是耽误了烧烤你还得去烧烤)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="comment">// 主协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 切一下，再次分配任务</span></span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h3><p>退出当前协程(一边烧烤一边相亲，突然发现相亲对象太丑影响烧烤，果断让她滚蛋，然后也就没有然后了)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">            <span class="comment">// 结束协程</span></span><br><span class="line">            runtime.Goexit()</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;C.defer&quot;</span>)</span><br><span class="line">            fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS"></a>runtime.GOMAXPROCS</h3><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> a()</span><br><span class="line">    <span class="keyword">go</span> b()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> a()</span><br><span class="line">    <span class="keyword">go</span> b()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ul>
<li>一个操作系统线程对应用户态多个goroutine。</li>
<li>go程序可以同时使用多个操作系统线程。</li>
<li>goroutine和OS线程是多对多的关系，即m:n。</li>
</ul>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>
<p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>
<p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p>
<p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><p>channel是一种类型，一种引用类型。声明通道类型的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure>

<h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>通道是引用类型，通道类型的空值是nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>
<p>声明的通道后需要使用make函数初始化之后才能使用。<br>创建channel的格式如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">make</span><span class="params">(chan 元素类型, [缓冲大小])</span></span></span><br></pre></td></tr></table></figure>

<p>channel的缓冲大小是可选的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。<br>发送和接收都使用&lt;-符号。现在我们先使用以下语句定义一个通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>将一个值发送到通道中。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ch</span> &lt;- <span class="number">10</span> // 把<span class="number">10</span>发送到ch中</span><br></pre></td></tr></table></figure>

<h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>从一个通道中接收值。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="regexp">//</span> 从ch中接收值并赋值给变量x</span><br><span class="line">&lt;-ch       <span class="regexp">//</span> 从ch中接收值，忽略结果</span><br></pre></td></tr></table></figure>

<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>我们通过调用内置的close函数来关闭通道。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">close</span><span class="params">(ch)</span></span></span><br></pre></td></tr></table></figure>

<p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<ol>
<li>对一个关闭的通道再发送值就会导致panic。</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>关闭一个已经关闭的通道会导致panic。</li>
</ol>
<h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93.png"></p>
<p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        ...<span class="regexp">/src/gi</span>thub.com<span class="regexp">/pprof/</span>studygo<span class="regexp">/day06/</span>channel02/main.go:<span class="number">8</span> +<span class="number">0</span>x54</span><br></pre></td></tr></table></figure>

<p>为什么会出现deadlock错误呢？</p>
<p>因为我们使用ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。<br>上面的代码会阻塞在ch &lt;- 10这一行代码形成死锁，那如何解决这个问题呢？一种方法是启用一个goroutine去接收值，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ret := &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">&quot;接收成功&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。</p>
<h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93.png"></p>
<p>我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。<br>我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。</p>
<h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>可以通过内置的close()函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> data, ok := &lt;-c; ok &#123;</span><br><span class="line">            fmt.Println(data)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何优雅的从通道循环取值"><a href="#如何优雅的从通道循环取值" class="headerlink" title="如何优雅的从通道循环取值"></a>如何优雅的从通道循环取值</h3><p>当通过通道发送有限的数据时，我们可以通过close函数关闭通道来告知从该通道接收值的goroutine停止等待。当通道被关闭时，往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？我们来看下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel 练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">            ch1 &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(ch1)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ch2 &lt;- i * i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(ch2)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 在主goroutine中从ch2中接收值打印</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ch2 &#123; <span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子中我们看到有两种方式在接收值的时候判断通道是否被关闭，我们通常使用的是for range的方式。</p>
<h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。<br>Go语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- i * i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)&#125;<span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(ch1)</span><br><span class="line">    <span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">    printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">chan</span>&lt;- <span class="type">int</span>是一个只能发送的通道，可以发送但是不能接收；</span><br><span class="line"><span class="number">2.</span>&lt;-<span class="keyword">chan</span> <span class="type">int</span>是一个只能接收的通道，可以接收但是不能发送。</span><br></pre></td></tr></table></figure>

<p>在函数传参及任何赋值操作中将双向通道转换为单向通道是可以的，但反过来是不可以的。</p>
<h3 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h3><p>channel常见的异常总结，如下图：<br><img src="/2023/01/25/go%E5%9F%BA%E7%A1%80/%E9%80%9A%E9%81%93%E6%80%BB%E7%BB%93.png"><br>注意:关闭已经关闭的channel也会引发panic。</p>
<h2 id="Goroutine池"><a href="#Goroutine池" class="headerlink" title="Goroutine池"></a>Goroutine池</h2><h3 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a>worker pool（goroutine池）</h3><ul>
<li>本质上是生产者消费者模型</li>
<li>可以有效控制goroutine数量，防止暴涨</li>
</ul>
<p>需求：</p>
<ul>
<li>计算一个数字的各个位数之和，例如数字123，结果为1+2+3=6</li>
<li>随机生成数字进行计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// id</span></span><br><span class="line">    Id <span class="type">int</span></span><br><span class="line">    <span class="comment">// 需要计算的随机数</span></span><br><span class="line">    RandNum <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 这里必须传对象实例</span></span><br><span class="line">    job *Job</span><br><span class="line">    <span class="comment">// 求和</span></span><br><span class="line">    sum <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要2个管道</span></span><br><span class="line">    <span class="comment">// 1.job管道</span></span><br><span class="line">    jobChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *Job, <span class="number">128</span>)</span><br><span class="line">    <span class="comment">// 2.结果管道</span></span><br><span class="line">    resultChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *Result, <span class="number">128</span>)</span><br><span class="line">    <span class="comment">// 3.创建工作池</span></span><br><span class="line">    createPool(<span class="number">64</span>, jobChan, resultChan)</span><br><span class="line">    <span class="comment">// 4.开个打印的协程</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(resultChan <span class="keyword">chan</span> *Result)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 遍历结果管道打印</span></span><br><span class="line">        <span class="keyword">for</span> result := <span class="keyword">range</span> resultChan &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;job id:%v randnum:%v result:%d\n&quot;</span>, result.job.Id,</span><br><span class="line">                result.job.RandNum, result.sum)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(resultChan)</span><br><span class="line">    <span class="keyword">var</span> id <span class="type">int</span></span><br><span class="line">    <span class="comment">// 循环创建job，输入到管道</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        id++</span><br><span class="line">        <span class="comment">// 生成随机数</span></span><br><span class="line">        r_num := rand.Int()</span><br><span class="line">        job := &amp;Job&#123;</span><br><span class="line">            Id:      id,</span><br><span class="line">            RandNum: r_num,</span><br><span class="line">        &#125;</span><br><span class="line">        jobChan &lt;- job</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建工作池// 参数1：开几个协程func createPool(num int, jobChan chan *Job, resultChan chan *Result) &#123;</span></span><br><span class="line">    <span class="comment">// 根据开协程个数，去跑运行</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(jobChan <span class="keyword">chan</span> *Job, resultChan <span class="keyword">chan</span> *Result)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 执行运算</span></span><br><span class="line">            <span class="comment">// 遍历job管道所有数据，进行相加</span></span><br><span class="line">            <span class="keyword">for</span> job := <span class="keyword">range</span> jobChan &#123;</span><br><span class="line">                <span class="comment">// 随机数接过来</span></span><br><span class="line">                r_num := job.RandNum</span><br><span class="line">                <span class="comment">// 随机数每一位相加</span></span><br><span class="line">                <span class="comment">// 定义返回值</span></span><br><span class="line">                <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">                <span class="keyword">for</span> r_num != <span class="number">0</span> &#123;</span><br><span class="line">                    tmp := r_num % <span class="number">10</span></span><br><span class="line">                    sum += tmp</span><br><span class="line">                    r_num /= <span class="number">10</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 想要的结果是Result</span></span><br><span class="line">                r := &amp;Result&#123;</span><br><span class="line">                    job: job,</span><br><span class="line">                    sum: sum,</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//运算结果扔到管道</span></span><br><span class="line">                resultChan &lt;- r</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(jobChan, resultChan)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>Timer：时间到了，执行只执行1次</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="number">1</span>.timer基本使用</span><br><span class="line">    <span class="regexp">//</span>timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="regexp">//</span>t1 := time.Now()</span><br><span class="line">    <span class="regexp">//</span>fmt.Printf(<span class="string">&quot;t1:%v\n&quot;</span>, t1)</span><br><span class="line">    <span class="regexp">//</span>t2 := &lt;-timer1.C</span><br><span class="line">    <span class="regexp">//</span>fmt.Printf(<span class="string">&quot;t2:%v\n&quot;</span>, t2)</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> <span class="number">2</span>.验证timer只能响应<span class="number">1</span>次</span><br><span class="line">    <span class="regexp">//</span>timer2 := time.NewTimer(time.Second)</span><br><span class="line">    <span class="regexp">//</span><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> &lt;-timer2.C</span><br><span class="line">    <span class="regexp">//</span> fmt.Println(<span class="string">&quot;时间到&quot;</span>)</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> <span class="number">3</span>.timer实现延时的功能</span><br><span class="line">    <span class="regexp">//</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="regexp">//</span>time.Sleep(time.Second)</span><br><span class="line">    <span class="regexp">//</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="regexp">//</span>timer3 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="regexp">//</span>&lt;-timer3.C</span><br><span class="line">    <span class="regexp">//</span>fmt.Println(<span class="string">&quot;2秒到&quot;</span>)</span><br><span class="line">    <span class="regexp">//</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="regexp">//</span>&lt;-time.After(<span class="number">2</span>*time.Second)</span><br><span class="line">    <span class="regexp">//</span>fmt.Println(<span class="string">&quot;2秒到&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> <span class="number">4</span>.停止定时器</span><br><span class="line">    <span class="regexp">//</span>timer4 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="regexp">//g</span>o <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="regexp">//</span> &lt;-timer4.C</span><br><span class="line">    <span class="regexp">//</span> fmt.Println(<span class="string">&quot;定时器执行了&quot;</span>)</span><br><span class="line">    <span class="regexp">//</span>&#125;()</span><br><span class="line">    <span class="regexp">//</span>b := timer4.Stop()</span><br><span class="line">    <span class="regexp">//i</span>f b &#123;</span><br><span class="line">    <span class="regexp">//</span> fmt.Println(<span class="string">&quot;timer4已经关闭&quot;</span>)</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> <span class="number">5</span>.重置定时器</span><br><span class="line">    timer5 := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">    timer5.Reset(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(time.Now())</span><br><span class="line">    fmt.Println(&lt;-timer5.C)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ticker：时间到了，多次执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取ticker对象</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 子协程</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;-ticker.C</span></span><br><span class="line">            i++</span><br><span class="line">            fmt.Println(&lt;-ticker.C)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">                <span class="comment">//停止</span></span><br><span class="line">                ticker.Stop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h3><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">for</span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从ch1接收值</span></span><br><span class="line">    <span class="meta">data</span>, ok := &lt;-ch1</span><br><span class="line">    <span class="comment">// 尝试从ch2接收值</span></span><br><span class="line">    <span class="meta">data</span>, ok := &lt;-ch2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。</p>
<p>select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">   // 如果chan1成功读到数据，则进行该<span class="keyword">case</span>处理语句</span><br><span class="line"><span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">   // 如果成功向chan2写入数据，则进行该<span class="keyword">case</span>处理语句</span><br><span class="line"><span class="literal">default</span>:</span><br><span class="line">   // 如果上面都没有成功，则进入<span class="literal">default</span>处理流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select可以同时监听一个或多个channel，直到其中一个channel ready</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">   ch &lt;- <span class="string">&quot;test1&quot;</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">   ch &lt;- <span class="string">&quot;test2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 2个管道</span></span><br><span class="line">   output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">   output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">   <span class="comment">// 跑2个子协程，写数据</span></span><br><span class="line">   <span class="keyword">go</span> test1(output1)</span><br><span class="line">   <span class="keyword">go</span> test2(output2)</span><br><span class="line">   <span class="comment">// 用select监控</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">      fmt.Println(<span class="string">&quot;s1=&quot;</span>, s1)</span><br><span class="line">   <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">      fmt.Println(<span class="string">&quot;s2=&quot;</span>, s2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果多个channel同时ready，则随机选择一个执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建2个管道</span></span><br><span class="line">   int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">   string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//time.Sleep(2 * time.Second)</span></span><br><span class="line">      int_chan &lt;- <span class="number">1</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">      fmt.Println(<span class="string">&quot;int:&quot;</span>, value)</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">      fmt.Println(<span class="string">&quot;string:&quot;</span>, value)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用于判断管道是否存满</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断管道有没有存满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建管道</span></span><br><span class="line">   output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="comment">// 子协程写数据</span></span><br><span class="line">   <span class="keyword">go</span> write(output1)</span><br><span class="line">   <span class="comment">// 取数据</span></span><br><span class="line">   <span class="keyword">for</span> s := <span class="keyword">range</span> output1 &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;res:&quot;</span>, s)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      <span class="keyword">case</span> ch &lt;- <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;write hello&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;channel full&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x int64var wg sync.<span class="function">WaitGroup</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">func <span class="title">add</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">func <span class="title">main</span>()</span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="function">go <span class="title">add</span>()</span></span><br><span class="line"><span class="function">    go <span class="title">add</span>()</span></span><br><span class="line"><span class="function">    wg.<span class="title">Wait</span>()</span></span><br><span class="line"><span class="function">    fmt.<span class="title">Println</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x int64var wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">lock</span> sync.<span class="function">Mutex</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">func <span class="title">add</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">lock</span>.Lock() <span class="comment">// 加锁</span></span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        <span class="keyword">lock</span>.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()&#125;<span class="function">func <span class="title">main</span>()</span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="function">go <span class="title">add</span>()</span></span><br><span class="line"><span class="function">    go <span class="title">add</span>()</span></span><br><span class="line"><span class="function">    wg.<span class="title">Wait</span>()</span></span><br><span class="line"><span class="function">    fmt.<span class="title">Println</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。</p>
<h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    x      int64</span><br><span class="line">    wg     sync.WaitGroup</span><br><span class="line">    lock   sync.Mutex</span><br><span class="line">    rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> write() &#123;</span><br><span class="line">    <span class="regexp">//</span> lock.Lock()   <span class="regexp">//</span> 加互斥锁</span><br><span class="line">    rwlock.Lock() <span class="regexp">//</span> 加写锁</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="regexp">//</span> 假设读操作耗时<span class="number">10</span>毫秒</span><br><span class="line">    rwlock.Unlock()                   <span class="regexp">//</span> 解写锁</span><br><span class="line">    <span class="regexp">//</span> lock.Unlock()                     <span class="regexp">//</span> 解互斥锁</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> read() &#123;</span><br><span class="line">    <span class="regexp">//</span> lock.Lock()                  <span class="regexp">//</span> 加互斥锁</span><br><span class="line">    rwlock.RLock()               <span class="regexp">//</span> 加读锁</span><br><span class="line">    time.Sleep(time.Millisecond) <span class="regexp">//</span> 假设读操作耗时<span class="number">1</span>毫秒</span><br><span class="line">    rwlock.RUnlock()             <span class="regexp">//</span> 解读锁</span><br><span class="line">    <span class="regexp">//</span> lock.Unlock()                <span class="regexp">//</span> 解互斥锁</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        go write()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        go read()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    end := time.Now()</span><br><span class="line">    fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>
<h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(wg * WaitGroup) Add(delta int)</td>
<td>计数器+delta</td>
</tr>
<tr>
<td>(wg * WaitGroup) Done()</td>
<td>计数器-1</td>
</tr>
<tr>
<td>(wg * WaitGroup) Wait()</td>
<td>阻塞直到计数器变为0</td>
</tr>
</tbody></table>
<p>sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> wg sync<span class="selector-class">.WaitGroup</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">hello</span>() &#123;</span><br><span class="line">    defer wg<span class="selector-class">.Done</span>()</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;Hello Goroutine!&quot;</span>)&#125;func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    wg<span class="selector-class">.Add</span>(<span class="number">1</span>)</span><br><span class="line">    go <span class="built_in">hello</span>() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">    wg<span class="selector-class">.Wait</span>()&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。</p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>说在前面的话：这是一个进阶知识点。在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。<br>Go语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。sync.Once只有一个Do方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果要执行的函数f需要传递参数就需要搭配闭包来使用。</p>
<h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> icons map<span class="selector-attr">[string]</span>image<span class="selector-class">.Image</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">loadIcons</span>() &#123;</span><br><span class="line">    icons = map<span class="selector-attr">[string]</span>image.Image&#123;</span><br><span class="line">        <span class="string">&quot;left&quot;</span>:  <span class="built_in">loadIcon</span>(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;up&quot;</span>:    <span class="built_in">loadIcon</span>(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: <span class="built_in">loadIcon</span>(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;down&quot;</span>:  <span class="built_in">loadIcon</span>(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的func Icon(name string) image.Image &#123;</span></span><br><span class="line">    <span class="keyword">if</span> icons == nil &#123;</span><br><span class="line">        <span class="built_in">loadIcons</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    return icons<span class="selector-attr">[name]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="built_in">loadIcons</span>() &#123;</span><br><span class="line">    icons = <span class="built_in">make</span>(map<span class="selector-attr">[string]</span>image.Image)</span><br><span class="line">    icons<span class="selector-attr">[<span class="string">&quot;left&quot;</span>]</span> = <span class="built_in">loadIcon</span>(<span class="string">&quot;left.png&quot;</span>)</span><br><span class="line">    icons<span class="selector-attr">[<span class="string">&quot;up&quot;</span>]</span> = <span class="built_in">loadIcon</span>(<span class="string">&quot;up.png&quot;</span>)</span><br><span class="line">    icons<span class="selector-attr">[<span class="string">&quot;right&quot;</span>]</span> = <span class="built_in">loadIcon</span>(<span class="string">&quot;right.png&quot;</span>)</span><br><span class="line">    icons<span class="selector-attr">[<span class="string">&quot;down&quot;</span>]</span> = <span class="built_in">loadIcon</span>(<span class="string">&quot;down.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。<br>使用sync.Once改造的示例代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> icons map<span class="selector-attr">[string]</span>image<span class="selector-class">.Image</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> loadIconsOnce sync<span class="selector-class">.Once</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">loadIcons</span>() &#123;</span><br><span class="line">    icons = map<span class="selector-attr">[string]</span>image.Image&#123;</span><br><span class="line">        <span class="string">&quot;left&quot;</span>:  <span class="built_in">loadIcon</span>(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;up&quot;</span>:    <span class="built_in">loadIcon</span>(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: <span class="built_in">loadIcon</span>(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;down&quot;</span>:  <span class="built_in">loadIcon</span>(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line">func <span class="built_in">Icon</span>(name string) image<span class="selector-class">.Image</span> &#123;</span><br><span class="line">    loadIconsOnce<span class="selector-class">.Do</span>(loadIcons)</span><br><span class="line">    return icons<span class="selector-attr">[name]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            set(key, n)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, get(key))</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。<br>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            m.Store(key, n)</span><br><span class="line">            value, _ := m.Load(key)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子操作-atomic包"><a href="#原子操作-atomic包" class="headerlink" title="原子操作(atomic包)"></a>原子操作(atomic包)</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/go%E5%9F%BA%E7%A1%80/" rel="tag"># go基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/24/MySQL/" rel="prev" title="MySQL">
      <i class="fa fa-chevron-left"></i> MySQL
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/25/gin%E6%A1%86%E6%9E%B6/" rel="next" title="gin框架">
      gin框架 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-number">1.</span> <span class="nav-text">开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">1.1.</span> <span class="nav-text">go的安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#windows"><span class="nav-number">1.2.</span> <span class="nav-text">windows</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEGOPATH"><span class="nav-number">1.3.</span> <span class="nav-text">配置GOPATH</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">go的项目目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%89%8D%E6%B5%81%E8%A1%8C%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">目前流行的项目结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">go基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81"><span class="nav-number">2.1.</span> <span class="nav-text">Go语言的主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E6%83%B3"><span class="nav-number">2.1.1.</span> <span class="nav-text">思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E5%91%BD%E5%90%8D"><span class="nav-number">2.1.2.</span> <span class="nav-text">Go语言命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E"><span class="nav-number">2.1.3.</span> <span class="nav-text">Go语言声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8F%8A%E7%BC%96%E8%AF%91"><span class="nav-number">2.1.4.</span> <span class="nav-text">Go项目构建及编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.5.</span> <span class="nav-text">go 编译问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Golang%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">Golang内置类型和函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">内置类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">引用类型：(指针类型)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">内置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E6%8E%A5%E5%8F%A3error"><span class="nav-number">2.2.3.</span> <span class="nav-text">内置接口error</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Init%E5%87%BD%E6%95%B0%E5%92%8Cmain%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">Init函数和main函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#init%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.1.</span> <span class="nav-text">init函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">main函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init%E5%87%BD%E6%95%B0%E5%92%8Cmain%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">2.3.3.</span> <span class="nav-text">init函数和main函数的异同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-number">2.4.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.1.</span> <span class="nav-text">算数运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.2.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.4.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.5.</span> <span class="nav-text">赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF"><span class="nav-number">2.6.</span> <span class="nav-text">下划线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF%E5%9C%A8import%E4%B8%AD"><span class="nav-number">2.6.1.</span> <span class="nav-text">下划线在import中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD"><span class="nav-number">2.6.2.</span> <span class="nav-text">下划线在代码中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="nav-number">2.7.</span> <span class="nav-text">变量和常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.7.1.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">变量类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">变量声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%A3%B0%E6%98%8E"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">标准声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">2.7.1.4.</span> <span class="nav-text">批量声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.7.1.5.</span> <span class="nav-text">变量的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">2.7.1.5.1.</span> <span class="nav-text">短变量声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F"><span class="nav-number">2.7.1.5.2.</span> <span class="nav-text">匿名变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">2.7.2.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#iota"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">iota</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84iota%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">几个常见的iota示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.8.</span> <span class="nav-text">基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.8.1.</span> <span class="nav-text">基本类型介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%95%B0"><span class="nav-number">2.8.1.3.</span> <span class="nav-text">复数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC"><span class="nav-number">2.8.1.4.</span> <span class="nav-text">布尔值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.8.1.5.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89%E7%AC%A6"><span class="nav-number">2.8.1.6.</span> <span class="nav-text">字符串转义符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.8.1.7.</span> <span class="nav-text">多行字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.1.8.</span> <span class="nav-text">字符串的常用操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#byte%E5%92%8Crune%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.8.1.9.</span> <span class="nav-text">byte和rune类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.8.1.10.</span> <span class="nav-text">修改字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.8.1.11.</span> <span class="nav-text">类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84Array"><span class="nav-number">2.9.</span> <span class="nav-text">数组Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.9.1.</span> <span class="nav-text">数组初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">2.9.1.1.</span> <span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">2.9.1.2.</span> <span class="nav-text">多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="nav-number">2.9.1.2.1.</span> <span class="nav-text">多维数组遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E4%BC%A0%E5%8F%82"><span class="nav-number">2.9.2.</span> <span class="nav-text">数组拷贝和传参</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87Slice"><span class="nav-number">2.10.</span> <span class="nav-text">切片Slice</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">2.10.1.</span> <span class="nav-text">创建切片的各种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.10.2.</span> <span class="nav-text">切片初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87make%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="nav-number">2.10.3.</span> <span class="nav-text">通过make来创建切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8append%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%E5%88%87%E7%89%87%EF%BC%88%E5%88%87%E7%89%87%E8%BF%BD%E5%8A%A0%EF%BC%89"><span class="nav-number">2.10.4.</span> <span class="nav-text">用append内置函数操作切片（切片追加）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E5%87%BA%E5%8E%9F-slice-cap-%E9%99%90%E5%88%B6%EF%BC%8C%E5%B0%B1%E4%BC%9A%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%EF%BC%8C%E5%8D%B3%E4%BE%BF%E5%8E%9F%E6%95%B0%E7%BB%84%E5%B9%B6%E6%9C%AA%E5%A1%AB%E6%BB%A1%E3%80%82"><span class="nav-number">2.10.5.</span> <span class="nav-text">超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice%E4%B8%ADcap%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E8%A7%84%E5%BE%8B%EF%BC%9A"><span class="nav-number">2.10.6.</span> <span class="nav-text">slice中cap重新分配规律：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E6%8B%B7%E8%B4%9D"><span class="nav-number">2.10.7.</span> <span class="nav-text">切片拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice%E9%81%8D%E5%8E%86"><span class="nav-number">2.10.8.</span> <span class="nav-text">slice遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87resize%EF%BC%88%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F%EF%BC%89"><span class="nav-number">2.10.9.</span> <span class="nav-text">切片resize（调整大小）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.10.10.</span> <span class="nav-text">数组和切片的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%87%E7%89%87%EF%BC%88string-and-slice%EF%BC%89"><span class="nav-number">2.10.11.</span> <span class="nav-text">字符串和切片（string and slice）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.10.11.1.</span> <span class="nav-text">英文字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.10.11.2.</span> <span class="nav-text">中文字符串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">2.11.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">2.11.1.</span> <span class="nav-text">Go语言中的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%9C%B0%E5%9D%80%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.11.1.1.</span> <span class="nav-text">指针地址和指针类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%8F%96%E5%80%BC"><span class="nav-number">2.11.1.2.</span> <span class="nav-text">指针取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="nav-number">2.11.1.3.</span> <span class="nav-text">空指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new%E5%92%8Cmake"><span class="nav-number">2.11.1.4.</span> <span class="nav-text">new和make</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#new"><span class="nav-number">2.11.1.4.1.</span> <span class="nav-text">new</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#make"><span class="nav-number">2.11.1.4.2.</span> <span class="nav-text">make</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#new%E4%B8%8Emake%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.11.1.4.3.</span> <span class="nav-text">new与make的区别</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">2.12.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E5%AE%9A%E4%B9%89"><span class="nav-number">2.12.1.</span> <span class="nav-text">map定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">2.12.2.</span> <span class="nav-text">map基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-number">2.12.3.</span> <span class="nav-text">判断某个键是否存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">2.12.4.</span> <span class="nav-text">map的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8delete-%E5%87%BD%E6%95%B0%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-number">2.12.5.</span> <span class="nav-text">使用delete()函数删除键值对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E6%8C%87%E5%AE%9A%E9%A1%BA%E5%BA%8F%E9%81%8D%E5%8E%86map"><span class="nav-number">2.12.6.</span> <span class="nav-text">按照指定顺序遍历map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E4%B8%BAmap%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%87%E7%89%87"><span class="nav-number">2.12.7.</span> <span class="nav-text">元素为map类型的切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E4%B8%BA%E5%88%87%E7%89%87%E7%B1%BB%E5%9E%8B%E7%9A%84map"><span class="nav-number">2.12.8.</span> <span class="nav-text">值为切片类型的map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.13.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.13.1.</span> <span class="nav-text">类型别名和自定义类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.13.1.1.</span> <span class="nav-text">自定义类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">2.13.1.2.</span> <span class="nav-text">类型别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.13.1.3.</span> <span class="nav-text">类型定义和类型别名的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-1"><span class="nav-number">2.13.2.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.13.2.1.</span> <span class="nav-text">结构体的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.13.2.2.</span> <span class="nav-text">结构体实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.13.2.3.</span> <span class="nav-text">基本实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.13.2.4.</span> <span class="nav-text">匿名结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.13.2.5.</span> <span class="nav-text">创建指针类型结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%9C%B0%E5%9D%80%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.13.2.6.</span> <span class="nav-text">取结构体的地址实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.13.2.7.</span> <span class="nav-text">结构体初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%94%AE%E5%80%BC%E5%AF%B9%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.13.2.7.1.</span> <span class="nav-text">使用键值对初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%80%BC%E7%9A%84%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.13.2.7.2.</span> <span class="nav-text">使用值的列表初始化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.13.2.8.</span> <span class="nav-text">结构体内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.13.2.9.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">2.13.2.10.</span> <span class="nav-text">方法和接收者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">2.13.2.11.</span> <span class="nav-text">指针类型的接收者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">2.13.2.12.</span> <span class="nav-text">值类型的接收者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">2.13.2.13.</span> <span class="nav-text">什么时候应该使用指针类型接收者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.13.2.14.</span> <span class="nav-text">任意类型添加方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="nav-number">2.13.2.15.</span> <span class="nav-text">结构体的匿名字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.13.2.16.</span> <span class="nav-text">嵌套结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.13.2.17.</span> <span class="nav-text">嵌套匿名结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E5%86%B2%E7%AA%81"><span class="nav-number">2.13.2.18.</span> <span class="nav-text">嵌套结构体的字段名冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D"><span class="nav-number">2.13.2.19.</span> <span class="nav-text">结构体的“继承”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">2.13.2.20.</span> <span class="nav-text">结构体字段的可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8EJSON%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">2.13.2.21.</span> <span class="nav-text">结构体与JSON序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%EF%BC%88Tag%EF%BC%89"><span class="nav-number">2.13.2.22.</span> <span class="nav-text">结构体标签（Tag）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5if"><span class="nav-number">3.1.</span> <span class="nav-text">条件语句if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5switch"><span class="nav-number">3.2.</span> <span class="nav-text">条件语句switch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Type-Switch"><span class="nav-number">3.2.1.</span> <span class="nav-text">Type Switch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5select"><span class="nav-number">3.3.</span> <span class="nav-text">条件语句select</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang-select%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B8%E5%9E%8B%E7%94%A8%E6%B3%95"><span class="nav-number">3.3.1.</span> <span class="nav-text">Golang select的使用及典型用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E5%88%A4%E6%96%AD"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">超时判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%80%E5%87%BA"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">判断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5for"><span class="nav-number">3.4.</span> <span class="nav-text">循环语句for</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97"><span class="nav-number">3.4.1.</span> <span class="nav-text">循环嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.4.2.</span> <span class="nav-text">无限循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5range"><span class="nav-number">3.5.</span> <span class="nav-text">循环语句range</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6Goto%E3%80%81Break%E3%80%81Continue"><span class="nav-number">3.6.</span> <span class="nav-text">循环控制Goto、Break、Continue</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">函数定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#golang%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9"><span class="nav-number">4.1.1.</span> <span class="nav-text">golang函数特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">4.1.2.</span> <span class="nav-text">函数声明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">4.2.1.</span> <span class="nav-text">函数参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.3.</span> <span class="nav-text">返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.3.1.</span> <span class="nav-text">函数返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E3%80%81%E9%80%92%E5%BD%92"><span class="nav-number">4.5.</span> <span class="nav-text">闭包、递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.5.1.</span> <span class="nav-text">闭包详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E8%AF%AD%E8%A8%80%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.2.</span> <span class="nav-text">Go 语言递归函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8%EF%BC%88defer%EF%BC%89"><span class="nav-number">4.6.</span> <span class="nav-text">延迟调用（defer）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8"><span class="nav-number">4.6.1.</span> <span class="nav-text">Golang延迟调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#defer%E7%89%B9%E6%80%A7"><span class="nav-number">4.6.1.1.</span> <span class="nav-text">defer特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer%E7%94%A8%E9%80%94"><span class="nav-number">4.6.1.2.</span> <span class="nav-text">defer用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer-%E7%A2%B0%E4%B8%8A%E9%97%AD%E5%8C%85"><span class="nav-number">4.6.1.3.</span> <span class="nav-text">defer 碰上闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer-f-Close"><span class="nav-number">4.6.1.4.</span> <span class="nav-text">defer f.Close</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer%E9%99%B7%E9%98%B1"><span class="nav-number">4.6.1.5.</span> <span class="nav-text">defer陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#defer-%E4%B8%8E-closure"><span class="nav-number">4.6.1.5.1.</span> <span class="nav-text">defer 与 closure</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#defer-%E4%B8%8E-return"><span class="nav-number">4.6.1.5.2.</span> <span class="nav-text">defer 与 return</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#defer-nil-%E5%87%BD%E6%95%B0"><span class="nav-number">4.6.1.5.3.</span> <span class="nav-text">defer nil 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E9%94%99%E8%AF%AF%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BD%BF%E7%94%A8-defer"><span class="nav-number">4.6.1.5.4.</span> <span class="nav-text">在错误的位置使用 defer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E6%A3%80%E6%9F%A5%E9%94%99%E8%AF%AF"><span class="nav-number">4.6.1.5.5.</span> <span class="nav-text">不检查错误</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">4.7.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">4.8.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="nav-number">4.9.</span> <span class="nav-text">压力测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.</span> <span class="nav-text">方法定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.1.</span> <span class="nav-text">普通函数与方法的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="nav-number">5.2.</span> <span class="nav-text">匿名字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%9B%86"><span class="nav-number">5.3.</span> <span class="nav-text">方法集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89error"><span class="nav-number">5.5.</span> <span class="nav-text">自定义error</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%8A%9B"><span class="nav-number">5.5.1.</span> <span class="nav-text">系统抛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%BC%82%E5%B8%B8"><span class="nav-number">5.5.2.</span> <span class="nav-text">返回异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89error-1"><span class="nav-number">5.5.3.</span> <span class="nav-text">自定义error</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5-1"><span class="nav-number">6.1.</span> <span class="nav-text">匿名字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.2.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.2.1.</span> <span class="nav-text">接口类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.2.2.</span> <span class="nav-text">为什么要使用接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">6.2.3.</span> <span class="nav-text">接口的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.2.4.</span> <span class="nav-text">实现接口的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-number">6.2.5.</span> <span class="nav-text">接口类型变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.6.</span> <span class="nav-text">值接收者和指针接收者实现接口的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.2.6.1.</span> <span class="nav-text">值接收者实现接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.2.6.2.</span> <span class="nav-text">指针接收者实现接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">6.2.6.3.</span> <span class="nav-text">下面的代码是一个比较好的面试题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.2.7.</span> <span class="nav-text">类型与接口的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.2.7.1.</span> <span class="nav-text">一个类型实现多个接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%90%8C%E4%B8%80%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.2.7.2.</span> <span class="nav-text">多个类型实现同一接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97"><span class="nav-number">6.2.8.</span> <span class="nav-text">接口嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.2.9.</span> <span class="nav-text">空接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">6.2.9.1.</span> <span class="nav-text">空接口的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">6.2.9.2.</span> <span class="nav-text">空接口的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">6.2.9.2.1.</span> <span class="nav-text">空接口作为函数的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BAmap%E7%9A%84%E5%80%BC"><span class="nav-number">6.2.9.2.2.</span> <span class="nav-text">空接口作为map的值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">6.2.9.3.</span> <span class="nav-text">类型断言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="nav-number">6.2.9.3.1.</span> <span class="nav-text">接口值</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">网络编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-number">8.</span> <span class="nav-text">数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GORM"><span class="nav-number">8.1.</span> <span class="nav-text">GORM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97"><span class="nav-number">8.1.1.</span> <span class="nav-text">入门指南</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="nav-number">8.1.1.3.</span> <span class="nav-text">快速开始</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">8.1.2.</span> <span class="nav-text">模型定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E6%A0%87%E7%AD%BE"><span class="nav-number">8.1.2.1.</span> <span class="nav-text">结构标签</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E7%BB%93%E6%9E%84%E6%A0%87%E7%AD%BE"><span class="nav-number">8.1.2.1.1.</span> <span class="nav-text">支持的结构标签</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E7%9A%84%E7%BB%93%E6%9E%84%E6%A0%87%E7%AD%BE"><span class="nav-number">8.1.2.1.2.</span> <span class="nav-text">关联的结构标签</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%AF%E4%BE%8B"><span class="nav-number">8.1.3.</span> <span class="nav-text">惯例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gorm-Model"><span class="nav-number">8.1.3.1.</span> <span class="nav-text">gorm.Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ID-%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE"><span class="nav-number">8.1.3.2.</span> <span class="nav-text">ID 作为主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%95%B0%E8%A1%A8%E5%90%8D"><span class="nav-number">8.1.3.3.</span> <span class="nav-text">复数表名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E8%A1%A8%E5%90%8D"><span class="nav-number">8.1.3.4.</span> <span class="nav-text">指定表名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E8%A1%A8%E5%90%8D"><span class="nav-number">8.1.3.5.</span> <span class="nav-text">修改默认表名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%9B%87%E5%BD%A2%E5%88%97%E5%90%8D"><span class="nav-number">8.1.3.6.</span> <span class="nav-text">蛇形列名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E8%B7%9F%E8%B8%AA"><span class="nav-number">8.1.3.7.</span> <span class="nav-text">时间戳跟踪</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CreatedAt"><span class="nav-number">8.1.3.7.1.</span> <span class="nav-text">CreatedAt</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UpdatedAt"><span class="nav-number">8.1.3.7.2.</span> <span class="nav-text">UpdatedAt</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DeletedAt"><span class="nav-number">8.1.3.7.3.</span> <span class="nav-text">DeletedAt</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">8.1.4.</span> <span class="nav-text">连接数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">8.1.4.1.</span> <span class="nav-text">支持的数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL"><span class="nav-number">8.1.4.1.1.</span> <span class="nav-text">MySQL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PostgreSQL"><span class="nav-number">8.1.4.1.2.</span> <span class="nav-text">PostgreSQL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sqlite3"><span class="nav-number">8.1.4.1.3.</span> <span class="nav-text">Sqlite3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL-Server"><span class="nav-number">8.1.4.1.4.</span> <span class="nav-text">SQL Server</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D"><span class="nav-number">9.1.</span> <span class="nav-text">并发介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.1.1.</span> <span class="nav-text">协程和线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Goroutine"><span class="nav-number">9.2.</span> <span class="nav-text">Goroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8goroutine"><span class="nav-number">9.2.1.</span> <span class="nav-text">使用goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%8D%95%E4%B8%AAgoroutine"><span class="nav-number">9.2.2.</span> <span class="nav-text">启动单个goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AAgoroutine"><span class="nav-number">9.2.3.</span> <span class="nav-text">启动多个goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#goroutine%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.2.4.</span> <span class="nav-text">goroutine与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%A2%9E%E9%95%BF%E7%9A%84%E6%A0%88"><span class="nav-number">9.2.4.1.</span> <span class="nav-text">可增长的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#goroutine%E8%B0%83%E5%BA%A6"><span class="nav-number">9.2.4.2.</span> <span class="nav-text">goroutine调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime%E5%8C%85"><span class="nav-number">9.3.</span> <span class="nav-text">runtime包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-Gosched"><span class="nav-number">9.3.1.</span> <span class="nav-text">runtime.Gosched()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-Goexit"><span class="nav-number">9.3.2.</span> <span class="nav-text">runtime.Goexit()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-GOMAXPROCS"><span class="nav-number">9.3.3.</span> <span class="nav-text">runtime.GOMAXPROCS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel"><span class="nav-number">9.4.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#channel%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.4.1.</span> <span class="nav-text">channel类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAchannel"><span class="nav-number">9.4.2.</span> <span class="nav-text">创建channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#channel%E6%93%8D%E4%BD%9C"><span class="nav-number">9.4.3.</span> <span class="nav-text">channel操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81"><span class="nav-number">9.4.3.1.</span> <span class="nav-text">发送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6"><span class="nav-number">9.4.3.2.</span> <span class="nav-text">接收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%97%AD"><span class="nav-number">9.4.3.3.</span> <span class="nav-text">关闭</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="nav-number">9.4.4.</span> <span class="nav-text">无缓冲的通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="nav-number">9.4.5.</span> <span class="nav-text">有缓冲的通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close"><span class="nav-number">9.4.6.</span> <span class="nav-text">close()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BB%8E%E9%80%9A%E9%81%93%E5%BE%AA%E7%8E%AF%E5%8F%96%E5%80%BC"><span class="nav-number">9.4.7.</span> <span class="nav-text">如何优雅的从通道循环取值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E9%80%9A%E9%81%93"><span class="nav-number">9.4.8.</span> <span class="nav-text">单向通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E6%80%BB%E7%BB%93"><span class="nav-number">9.4.9.</span> <span class="nav-text">通道总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Goroutine%E6%B1%A0"><span class="nav-number">9.5.</span> <span class="nav-text">Goroutine池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#worker-pool%EF%BC%88goroutine%E6%B1%A0%EF%BC%89"><span class="nav-number">9.5.1.</span> <span class="nav-text">worker pool（goroutine池）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">9.6.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select"><span class="nav-number">9.7.</span> <span class="nav-text">select</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">9.7.1.</span> <span class="nav-text">select多路复用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81"><span class="nav-number">9.8.</span> <span class="nav-text">并发安全和锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">9.8.1.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">9.8.2.</span> <span class="nav-text">读写互斥锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sync"><span class="nav-number">9.9.</span> <span class="nav-text">Sync</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sync-WaitGroup"><span class="nav-number">9.9.1.</span> <span class="nav-text">sync.WaitGroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sync-Once"><span class="nav-number">9.9.2.</span> <span class="nav-text">sync.Once</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="nav-number">9.9.2.1.</span> <span class="nav-text">加载配置文件示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sync-Map"><span class="nav-number">9.9.3.</span> <span class="nav-text">sync.Map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-atomic%E5%8C%85"><span class="nav-number">9.10.</span> <span class="nav-text">原子操作(atomic包)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">9.10.1.</span> <span class="nav-text">原子操作</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="拓荒者"
      src="/images/touxiang.png">
  <p class="site-author-name" itemprop="name">拓荒者</p>
  <div class="site-description" itemprop="description">欢迎来到程序猿的世界</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/shenhongwei33" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenhongwei33" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/shenhongweihhu@163.com" title="E-Mail → shenhongweihhu@163.com">E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">拓荒者</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">226k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:41</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : '[object Object]',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://shenhongwei33.github.io/2023/01/25/go%E5%9F%BA%E7%A1%80/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'fFqrBFTPRs63Tzp2ncGtrYbR-MdYXbMMI',
      appKey     : 'gWOiLxTMiii3J3T3NlOHomTl',
      placeholder: "说出你的看法~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
